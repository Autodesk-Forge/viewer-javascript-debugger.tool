var IS_CONCAT_BUILD = true;
var BUILD_LMV_WORKER_URL = "viewer3D.js";
var LMV_WORKER_URL = BUILD_LMV_WORKER_URL;
var ENABLE_DEBUG = false;
var ENABLE_TRACE = false;
var ENABLE_INLINE_WORKER = true;
var FORCE_USE_LOCAL_WORKER_SCRIPT = false;
AutodeskNamespace = function(s) {
  var ns = this;
  var parts = s.split(".");
  for (var i = 0;i < parts.length;++i) {
    ns[parts[i]] = ns[parts[i]] || {};
    ns = ns[parts[i]];
  }
  return ns;
};
var _isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
if (typeof window !== "undefined" && _isIE11) {
  (function() {
    function CustomEvent(event, params) {
      params = params || {bubbles:false, cancelable:false, detail:undefined};
      var evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }
    CustomEvent.prototype = window.CustomEvent.prototype;
    window.CustomEvent = CustomEvent;
  })();
}
if (!ArrayBuffer.prototype.slice) {
  ArrayBuffer.prototype.slice = function(start, end) {
    if (!end || end > this.byteLength) {
      end = this.byteLength;
    } else {
      if (end < 0) {
        end = this.byteLength + end;
        if (end < 0) {
          end = 0;
        }
      }
    }
    if (start < 0) {
      start = this.byteLength + start;
      if (start < 0) {
        start = 0;
      }
    }
    if (end <= start) {
      return new ArrayBuffer;
    }
    var len = end - start;
    var view = new Uint8Array(this, start, len);
    var out = new Uint8Array(len);
    for (var i = 0;i < len;i++) {
      out[i] = view[i];
    }
    return out.buffer;
  };
}
if (typeof window !== "undefined") {
  window.BlobBuilder = window.BlobBuilder || (window.WebKitBlobBuilder || (window.MozBlobBuilder || window.MSBlobBuilder));
}
function launchFullscreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else {
    if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else {
      if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
      } else {
        if (element.msRequestFullscreen) {
          element.msRequestFullscreen();
        }
      }
    }
  }
}
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else {
    if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else {
      if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else {
        if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
      }
    }
  }
}
function inFullscreen() {
  return document.fullscreenEnabled || (document.mozFullScreenElement || (document.webkitIsFullScreen || document.msFullscreenElement)) ? true : false;
}
function fullscreenElement() {
  return document.fullscreenElement || (document.mozFullScreenElement || (document.webkitFullscreenElement || document.msFullscreenElement));
}
function isFullscreenAvailable(element) {
  return element.requestFullscreen || (element.mozRequestFullScreen || (element.webkitRequestFullscreen || element.msRequestFullscreen));
}
;/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ESCAPE_EVENT = "escape";
Autodesk.Viewing.PROGRESS_UPDATE_EVENT = "progress";
Autodesk.Viewing.FULLSCREEN_MODE_EVENT = "fullScreenMode";
Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT = "navmode";
Autodesk.Viewing.Viewer = function(container, config) {
  this.clientContainer = container;
  this.container = document.createElement("div");
  this.container.className = "adsk-viewing-viewer";
  this.container.style.height = "100%";
  this.container.style.width = "100%";
  this.container.style.overflow = "hidden";
  this.clientContainer.appendChild(this.container);
  this.listeners = {};
  this.dockingPanels = [];
  this.config = config;
  this.screenModeDelegate = null;
  this.screenModeDelegateClass = null;
  this.setScreenModeDelegate(config ? config.screenModeDelegate : undefined);
};
Autodesk.Viewing.Viewer.prototype = {load:function(urn, onLoadCallback) {
  throw "bool load(urn, function(void)) must be implemented.  For more details, read the Viewer class documentation.";
}};
Autodesk.Viewing.Viewer.prototype.initialize = function() {
  var self = this;
  this.onResizeCallback = function(e) {
    self.resize();
  };
  window.addEventListener("resize", this.onResizeCallback, false);
};
Autodesk.Viewing.Viewer.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  if (this.screenModeDelegate) {
    this.screenModeDelegate.uninitialize();
    this.screenModeDelegate = null;
  }
  this.clientContainer = null;
  this.config = null;
  this.listeners = {};
  this.dockingPanels = [];
  window.removeEventListener("resize", this.onResizeCallback, false);
};
Autodesk.Viewing.Viewer.prototype.addEventListener = function(type, listener) {
  if (typeof this.listeners[type] == "undefined") {
    this.listeners[type] = [];
  }
  this.listeners[type].push(listener);
};
Autodesk.Viewing.Viewer.prototype.removeEventListener = function(type, listener) {
  if (this.listeners[type] instanceof Array) {
    var li = this.listeners[type];
    for (var i = 0, len = li.length;i < len;i++) {
      if (li[i] === listener) {
        li.splice(i, 1);
        break;
      }
    }
  }
};
Autodesk.Viewing.Viewer.prototype.fireEvent = function(event) {
  if (typeof event == "string") {
    event = {type:event};
  }
  if (!event.target) {
    event.target = this;
  }
  if (!event.type) {
    throw new Error("event type unknown.");
  }
  if (this.listeners[event.type] instanceof Array) {
    var typeListeners = this.listeners[event.type].slice();
    for (var i = 0;i < typeListeners.length;i++) {
      typeListeners[i].call(this, event);
    }
  }
};
Autodesk.Viewing.Viewer.prototype.getDimensions = function() {
  if (this.container) {
    var rect = {};
    if (this.getScreenMode() === this.ScreenMode.kFullScreen) {
      rect.width = screen.width;
      rect.height = screen.height;
    } else {
      rect = this.container.getBoundingClientRect();
    }
    return{width:rect.width, height:rect.height};
  }
  return null;
};
Autodesk.Viewing.Viewer.prototype.setViewFromArray = function(params) {
};
Autodesk.Viewing.Viewer.prototype.setViewFromFile = function() {
};
Autodesk.Viewing.Viewer.prototype.resize = function() {
  this.resizePanels();
};
Autodesk.Viewing.Viewer.prototype.addPanel = function(panel) {
  var index = this.dockingPanels.indexOf(panel);
  if (index === -1) {
    this.dockingPanels.push(panel);
    return true;
  }
  return false;
};
Autodesk.Viewing.Viewer.prototype.removePanel = function(panel) {
  var index = this.dockingPanels.indexOf(panel);
  if (index > -1) {
    this.dockingPanels.splice(index, 1);
    return true;
  }
  return false;
};
Autodesk.Viewing.Viewer.prototype.resizePanels = function(options) {
  var viewer = options ? options.viewer : null;
  if (!viewer) {
    viewer = this;
  }
  var dockingPanels = options ? options.dockingPanels : null;
  if (!dockingPanels) {
    dockingPanels = viewer.dockingPanels;
  }
  var viewerRect = viewer.container.getBoundingClientRect(), vt = viewerRect.top, vb = viewerRect.bottom, vl = viewerRect.left, vr = viewerRect.right, vw = viewerRect.width, vh = viewerRect.height;
  for (var i = 0;i < dockingPanels.length;++i) {
    var panel = dockingPanels[i].container, panelRect = panel.getBoundingClientRect(), pt = panelRect.top, pb = panelRect.bottom, pl = panelRect.left, pr = panelRect.right, pw = panelRect.width, ph = panelRect.height;
    if (pw && ph) {
      if (vw < pw) {
        pw = Math.round(vw);
        panel.style.width = pw + "px";
      }
      if (vh < ph) {
        ph = Math.round(vh);
        panel.style.height = ph + "px";
      }
      if (vr < pr || panel.dockRight) {
        pl = Math.round(vr - pw - vl);
        panel.style.left = pl + "px";
      }
      if (vb < pb || panel.dockBottom) {
        pt = Math.round(vb - ph - vt);
        panel.style.top = pt + "px";
      }
      panel.style.maxWidth = Math.round(vw) + "px";
      panel.style.maxHeight = Math.round(vh) + "px";
    }
  }
};
Autodesk.Viewing.Viewer.prototype.search = function(text, onSuccessCallback, onErrorCallback) {
};
Autodesk.Viewing.Viewer.prototype.ScreenMode = {kNormal:0, kFullBrowser:1, kFullScreen:2};
Autodesk.Viewing.Viewer.prototype.setScreenModeDelegate = function(delegate) {
  if (this.screenModeDelegate) {
    this.screenModeDelegate.uninitialize();
    this.screenModeDelegate = null;
  }
  if (delegate) {
    this.screenModeDelegateClass = delegate;
  } else {
    if (delegate === null) {
      this.screenModeDelegateClass = Autodesk.Viewing.NullScreenModeDelegate;
    } else {
      this.screenModeDelegateClass = Autodesk.Viewing.ViewerScreenModeDelegate;
    }
  }
};
Autodesk.Viewing.Viewer.prototype.getScreenModeDelegate = function() {
  if (!this.screenModeDelegate) {
    this.screenModeDelegate = new this.screenModeDelegateClass(this);
  }
  return this.screenModeDelegate;
};
Autodesk.Viewing.Viewer.prototype.isScreenModeSupported = function(mode) {
  return this.getScreenModeDelegate().isModeSupported(mode);
};
Autodesk.Viewing.Viewer.prototype.canChangeScreenMode = function() {
  return this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.kNormal);
};
Autodesk.Viewing.Viewer.prototype.setScreenMode = function(mode) {
  return this.getScreenModeDelegate().setMode(mode);
};
Autodesk.Viewing.Viewer.prototype.getScreenMode = function() {
  return this.getScreenModeDelegate().getMode();
};
Autodesk.Viewing.Viewer.prototype.nextScreenMode = function() {
  var mode = this.getScreenModeDelegate().getNextMode();
  return mode !== undefined ? this.setScreenMode(mode) : false;
};
Autodesk.Viewing.Viewer.prototype.escapeScreenMode = function() {
  var mode = this.getScreenModeDelegate().getEscapeMode();
  return mode !== undefined ? this.setScreenMode(mode) : false;
};
Autodesk.Viewing.ScreenModeDelegate = function(viewer) {
  this.viewer = viewer;
  this.bindFullscreenEventListener = this.fullscreenEventListener.bind(this);
  if (this.getMode() === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) {
    document.addEventListener("fullscreenchange", this.bindFullscreenEventListener, false);
    document.addEventListener("mozfullscreenchange", this.bindFullscreenEventListener, false);
    document.addEventListener("webkitfullscreenchange", this.bindFullscreenEventListener, false);
    document.addEventListener("MSFullscreenChange", this.bindFullscreenEventListener, false);
  }
};
Autodesk.Viewing.ScreenModeDelegate.prototype.uninitialize = function() {
  document.removeEventListener("fullscreenchange", this.bindFullscreenEventListener, false);
  document.removeEventListener("mozfullscreenchange", this.bindFullscreenEventListener, false);
  document.removeEventListener("webkitfullscreenchange", this.bindFullscreenEventListener, false);
  document.removeEventListener("MSFullscreenChange", this.bindFullscreenEventListener, false);
  this.viewer = null;
};
Autodesk.Viewing.ScreenModeDelegate.prototype.isModeSupported = function(mode) {
  return true;
};
Autodesk.Viewing.ScreenModeDelegate.prototype.setMode = function(mode) {
  var currentMode = this.getMode();
  if (mode !== currentMode && this.isModeSupported(mode)) {
    this.doScreenModeChange(currentMode, mode);
    if (currentMode !== Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) {
      this.onScreenModeChanged(currentMode, mode);
    }
    return true;
  }
  return false;
};
Autodesk.Viewing.ScreenModeDelegate.prototype.getMode = function() {
  throw "Implement getMode() in derived class";
};
Autodesk.Viewing.ScreenModeDelegate.prototype.getNextMode = function() {
  var currentMode = this.getMode(), newMode;
  if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
    newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser;
  } else {
    if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
      newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen;
    } else {
      if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
        newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen;
      } else {
        if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal)) {
          newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
        } else {
          if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal)) {
            newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
          } else {
            if (currentMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen && this.isModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
              newMode = Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser;
            }
          }
        }
      }
    }
  }
  return newMode;
};
Autodesk.Viewing.ScreenModeDelegate.prototype.getEscapeMode = function() {
  return this.getMode() !== Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal ? Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal : undefined;
};
Autodesk.Viewing.ScreenModeDelegate.prototype.fullscreenEventListener = function() {
  if (inFullscreen()) {
    this.viewer.resize();
  } else {
    var ScreenMode = Autodesk.Viewing.Viewer.prototype.ScreenMode;
    this.doScreenModeChange(ScreenMode.kFullScreen, ScreenMode.kNormal);
    this.onScreenModeChanged(ScreenMode.kFullScreen, ScreenMode.kNormal);
  }
};
Autodesk.Viewing.ScreenModeDelegate.prototype.doScreenModeChange = function(oldMode, newMode) {
  throw "Implement doScreenModeChange() in derived class";
};
Autodesk.Viewing.ScreenModeDelegate.prototype.onScreenModeChanged = function(oldMode, newMode) {
  if (oldMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) {
    document.removeEventListener("fullscreenchange", this.bindFullscreenEventListener, false);
    document.removeEventListener("mozfullscreenchange", this.bindFullscreenEventListener, false);
    document.removeEventListener("webkitfullscreenchange", this.bindFullscreenEventListener, false);
    document.removeEventListener("MSFullscreenChange", this.bindFullscreenEventListener, false);
  } else {
    if (newMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) {
      document.addEventListener("fullscreenchange", this.bindFullscreenEventListener, false);
      document.addEventListener("mozfullscreenchange", this.bindFullscreenEventListener, false);
      document.addEventListener("webkitfullscreenchange", this.bindFullscreenEventListener, false);
      document.addEventListener("MSFullscreenChange", this.bindFullscreenEventListener, false);
    }
  }
  this.viewer.resize();
  this.viewer.fireEvent({type:Autodesk.Viewing.FULLSCREEN_MODE_EVENT, mode:newMode});
};
Autodesk.Viewing.ViewerScreenModeDelegate = function(viewer) {
  Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ViewerScreenModeDelegate;
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.getMode = function() {
  if (inFullscreen() && fullscreenElement() === this.viewer.container) {
    return Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen;
  } else {
    if (this.viewer.container.classList.contains("viewer-fill-browser")) {
      return Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser;
    }
  }
  return Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
};
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.doScreenModeChange = function(oldMode, newMode) {
  var container = this.viewer.container;
  switch(newMode) {
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
      container.classList.remove("viewer-fill-browser");
      exitFullscreen();
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
      container.classList.add("viewer-fill-browser");
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
      container.classList.add("viewer-fill-browser");
      launchFullscreen(container);
      break;
  }
};
Autodesk.Viewing.ApplicationScreenModeDelegate = function(viewer) {
  Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ApplicationScreenModeDelegate;
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.isModeSupported = function(mode) {
  return mode !== Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser;
};
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.getMode = function() {
  return inFullscreen() && fullscreenElement() === document.documentElement ? Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen : Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
};
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.doScreenModeChange = function(oldMode, newMode) {
  if (newMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal) {
    exitFullscreen();
  } else {
    if (newMode === Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen) {
      launchFullscreen(document.documentElement);
    }
  }
};
Autodesk.Viewing.NullScreenModeDelegate = function(viewer) {
  Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};
Autodesk.Viewing.NullScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.NullScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ScreenModeDelegate;
Autodesk.Viewing.NullScreenModeDelegate.prototype.isModeSupported = function(mode) {
  return false;
};
Autodesk.Viewing.NullScreenModeDelegate.prototype.getMode = function() {
  return Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal;
};
var THREE = {REVISION:"66"};
self.console = self.console || {info:function() {
}, log:function() {
}, debug:function() {
}, warn:function() {
}, error:function() {
}};
(function() {
  for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0;c < b.length && !self.requestAnimationFrame;++c) {
    self.requestAnimationFrame = self[b[c] + "RequestAnimationFrame"], self.cancelAnimationFrame = self[b[c] + "CancelAnimationFrame"] || self[b[c] + "CancelRequestAnimationFrame"];
  }
  void 0 === self.requestAnimationFrame && (void 0 !== self.setTimeout && (self.requestAnimationFrame = function(b) {
    var c = Date.now(), f = Math.max(0, 16 - (c - a)), g = self.setTimeout(function() {
      b(c + f);
    }, f);
    a = c + f;
    return g;
  }));
  void 0 === self.cancelAnimationFrame && (void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function(a) {
    self.clearTimeout(a);
  }));
})();
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function() {
};
THREE.CubeReflectionMapping = function() {
};
THREE.CubeRefractionMapping = function() {
};
THREE.SphericalReflectionMapping = function() {
};
THREE.SphericalRefractionMapping = function() {
};
THREE.RepeatWrapping = 1E3;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1099;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function(a) {
  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
};
THREE.Color.prototype = {constructor:THREE.Color, r:1, g:1, b:1, set:function(a) {
  a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
  return this;
}, setHex:function(a) {
  a = Math.floor(a);
  this.r = (a >> 16 & 255) / 255;
  this.g = (a >> 8 & 255) / 255;
  this.b = (a & 255) / 255;
  return this;
}, setRGB:function(a, b, c) {
  this.r = a;
  this.g = b;
  this.b = c;
  return this;
}, setHSL:function(a, b, c) {
  if (0 === b) {
    this.r = this.g = this.b = c;
  } else {
    var d = function(a, b, c) {
      0 > c && (c += 1);
      1 < c && (c -= 1);
      return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
    };
    b = 0.5 >= c ? c * (1 + b) : c + b - c * b;
    c = 2 * c - b;
    this.r = d(c, b, a + 1 / 3);
    this.g = d(c, b, a);
    this.b = d(c, b, a - 1 / 3);
  }
  return this;
}, setStyle:function(a) {
  if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a)) {
    return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
  }
  if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a)) {
    return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
  }
  if (/^\#([0-9a-f]{6})$/i.test(a)) {
    return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
  }
  if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) {
    return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
  }
  if (/^(\w+)$/i.test(a)) {
    return this.setHex(THREE.ColorKeywords[a]), this;
  }
}, copy:function(a) {
  this.r = a.r;
  this.g = a.g;
  this.b = a.b;
  return this;
}, copyGammaToLinear:function(a) {
  this.r = a.r * a.r;
  this.g = a.g * a.g;
  this.b = a.b * a.b;
  return this;
}, copyLinearToGamma:function(a) {
  this.r = Math.sqrt(a.r);
  this.g = Math.sqrt(a.g);
  this.b = Math.sqrt(a.b);
  return this;
}, convertGammaToLinear:function() {
  var a = this.r, b = this.g, c = this.b;
  this.r = a * a;
  this.g = b * b;
  this.b = c * c;
  return this;
}, convertLinearToGamma:function() {
  this.r = Math.sqrt(this.r);
  this.g = Math.sqrt(this.g);
  this.b = Math.sqrt(this.b);
  return this;
}, getHex:function() {
  return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
}, getHexString:function() {
  return("000000" + this.getHex().toString(16)).slice(-6);
}, getHSL:function(a) {
  a = a || {h:0, s:0, l:0};
  var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
  if (f === e) {
    f = g = 0;
  } else {
    var k = e - f, f = 0.5 >= h ? k / (e + f) : k / (2 - e - f);
    switch(e) {
      case b:
        g = (c - d) / k + (c < d ? 6 : 0);
        break;
      case c:
        g = (d - b) / k + 2;
        break;
      case d:
        g = (b - c) / k + 4;
    }
    g /= 6;
  }
  a.h = g;
  a.s = f;
  a.l = h;
  return a;
}, getStyle:function() {
  return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
}, offsetHSL:function(a, b, c) {
  var d = this.getHSL();
  d.h += a;
  d.s += b;
  d.l += c;
  this.setHSL(d.h, d.s, d.l);
  return this;
}, add:function(a) {
  this.r += a.r;
  this.g += a.g;
  this.b += a.b;
  return this;
}, addColors:function(a, b) {
  this.r = a.r + b.r;
  this.g = a.g + b.g;
  this.b = a.b + b.b;
  return this;
}, addScalar:function(a) {
  this.r += a;
  this.g += a;
  this.b += a;
  return this;
}, multiply:function(a) {
  this.r *= a.r;
  this.g *= a.g;
  this.b *= a.b;
  return this;
}, multiplyScalar:function(a) {
  this.r *= a;
  this.g *= a;
  this.b *= a;
  return this;
}, lerp:function(a, b) {
  this.r += (a.r - this.r) * b;
  this.g += (a.g - this.g) * b;
  this.b += (a.b - this.b) * b;
  return this;
}, equals:function(a) {
  return a.r === this.r && (a.g === this.g && a.b === this.b);
}, fromArray:function(a) {
  this.r = a[0];
  this.g = a[1];
  this.b = a[2];
  return this;
}, toArray:function() {
  return[this.r, this.g, this.b];
}, clone:function() {
  return(new THREE.Color).setRGB(this.r, this.g, this.b);
}};
THREE.ColorKeywords = {aliceblue:15792383, antiquewhite:16444375, aqua:65535, aquamarine:8388564, azure:15794175, beige:16119260, bisque:16770244, black:0, blanchedalmond:16772045, blue:255, blueviolet:9055202, brown:10824234, burlywood:14596231, cadetblue:6266528, chartreuse:8388352, chocolate:13789470, coral:16744272, cornflowerblue:6591981, cornsilk:16775388, crimson:14423100, cyan:65535, darkblue:139, darkcyan:35723, darkgoldenrod:12092939, darkgray:11119017, darkgreen:25600, darkgrey:11119017, 
darkkhaki:12433259, darkmagenta:9109643, darkolivegreen:5597999, darkorange:16747520, darkorchid:10040012, darkred:9109504, darksalmon:15308410, darkseagreen:9419919, darkslateblue:4734347, darkslategray:3100495, darkslategrey:3100495, darkturquoise:52945, darkviolet:9699539, deeppink:16716947, deepskyblue:49151, dimgray:6908265, dimgrey:6908265, dodgerblue:2003199, firebrick:11674146, floralwhite:16775920, forestgreen:2263842, fuchsia:16711935, gainsboro:14474460, ghostwhite:16316671, gold:16766720, 
goldenrod:14329120, gray:8421504, green:32768, greenyellow:11403055, grey:8421504, honeydew:15794160, hotpink:16738740, indianred:13458524, indigo:4915330, ivory:16777200, khaki:15787660, lavender:15132410, lavenderblush:16773365, lawngreen:8190976, lemonchiffon:16775885, lightblue:11393254, lightcoral:15761536, lightcyan:14745599, lightgoldenrodyellow:16448210, lightgray:13882323, lightgreen:9498256, lightgrey:13882323, lightpink:16758465, lightsalmon:16752762, lightseagreen:2142890, lightskyblue:8900346, 
lightslategray:7833753, lightslategrey:7833753, lightsteelblue:11584734, lightyellow:16777184, lime:65280, limegreen:3329330, linen:16445670, magenta:16711935, maroon:8388608, mediumaquamarine:6737322, mediumblue:205, mediumorchid:12211667, mediumpurple:9662683, mediumseagreen:3978097, mediumslateblue:8087790, mediumspringgreen:64154, mediumturquoise:4772300, mediumvioletred:13047173, midnightblue:1644912, mintcream:16121850, mistyrose:16770273, moccasin:16770229, navajowhite:16768685, navy:128, 
oldlace:16643558, olive:8421376, olivedrab:7048739, orange:16753920, orangered:16729344, orchid:14315734, palegoldenrod:15657130, palegreen:10025880, paleturquoise:11529966, palevioletred:14381203, papayawhip:16773077, peachpuff:16767673, peru:13468991, pink:16761035, plum:14524637, powderblue:11591910, purple:8388736, red:16711680, rosybrown:12357519, royalblue:4286945, saddlebrown:9127187, salmon:16416882, sandybrown:16032864, seagreen:3050327, seashell:16774638, sienna:10506797, silver:12632256, 
skyblue:8900331, slateblue:6970061, slategray:7372944, slategrey:7372944, snow:16775930, springgreen:65407, steelblue:4620980, tan:13808780, teal:32896, thistle:14204888, tomato:16737095, turquoise:4251856, violet:15631086, wheat:16113331, white:16777215, whitesmoke:16119285, yellow:16776960, yellowgreen:10145074};
THREE.Quaternion = function(a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._w = void 0 !== d ? d : 1;
};
THREE.Quaternion.prototype = {constructor:THREE.Quaternion, _x:0, _y:0, _z:0, _w:0, _euler:void 0, _updateEuler:function(a) {
  void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1);
}, get x() {
  return this._x;
}, set x(a) {
  this._x = a;
  this._updateEuler();
}, get y() {
  return this._y;
}, set y(a) {
  this._y = a;
  this._updateEuler();
}, get z() {
  return this._z;
}, set z(a) {
  this._z = a;
  this._updateEuler();
}, get w() {
  return this._w;
}, set w(a) {
  this._w = a;
  this._updateEuler();
}, set:function(a, b, c, d) {
  this._x = a;
  this._y = b;
  this._z = c;
  this._w = d;
  this._updateEuler();
  return this;
}, copy:function(a) {
  this._x = a._x;
  this._y = a._y;
  this._z = a._z;
  this._w = a._w;
  this._updateEuler();
  return this;
}, setFromEuler:function(a, b) {
  if (!1 === a instanceof THREE.Euler) {
    throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
  }
  var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
  "XYZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a.order ? (this._x = f * 
  d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
  !1 !== b && this._updateEuler();
  return this;
}, setFromAxisAngle:function(a, b) {
  var c = b / 2, d = Math.sin(c);
  this._x = a.x * d;
  this._y = a.y * d;
  this._z = a.z * d;
  this._w = Math.cos(c);
  this._updateEuler();
  return this;
}, setFromRotationMatrix:function(a) {
  var b = a.elements, c = b[0];
  a = b[4];
  var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b;
  0 < l ? (c = 0.5 / Math.sqrt(l + 1), this._w = 0.25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = 0.25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = 0.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + 
  k) / c, this._z = 0.25 * c);
  this._updateEuler();
  return this;
}, inverse:function() {
  this.conjugate().normalize();
  return this;
}, conjugate:function() {
  this._x *= -1;
  this._y *= -1;
  this._z *= -1;
  this._updateEuler();
  return this;
}, lengthSq:function() {
  return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
}, length:function() {
  return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
}, normalize:function() {
  var a = this.length();
  0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
  return this;
}, multiply:function(a, b) {
  return void 0 !== b ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
}, multiplyQuaternions:function(a, b) {
  var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, k = b._z, l = b._w;
  this._x = c * l + f * g + d * k - e * h;
  this._y = d * l + f * h + e * g - c * k;
  this._z = e * l + f * k + c * h - d * g;
  this._w = f * l - c * g - d * h - e * k;
  this._updateEuler();
  return this;
}, multiplyVector3:function(a) {
  console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return a.applyQuaternion(this);
}, slerp:function(a, b) {
  var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
  0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
  if (1 <= g) {
    return this._w = f, this._x = c, this._y = d, this._z = e, this;
  }
  var h = Math.acos(g), k = Math.sqrt(1 - g * g);
  if (0.001 > Math.abs(k)) {
    return this._w = 0.5 * (f + this._w), this._x = 0.5 * (c + this._x), this._y = 0.5 * (d + this._y), this._z = 0.5 * (e + this._z), this;
  }
  g = Math.sin((1 - b) * h) / k;
  h = Math.sin(b * h) / k;
  this._w = f * g + this._w * h;
  this._x = c * g + this._x * h;
  this._y = d * g + this._y * h;
  this._z = e * g + this._z * h;
  this._updateEuler();
  return this;
}, equals:function(a) {
  return a._x === this._x && (a._y === this._y && (a._z === this._z && a._w === this._w));
}, fromArray:function(a) {
  this._x = a[0];
  this._y = a[1];
  this._z = a[2];
  this._w = a[3];
  this._updateEuler();
  return this;
}, toArray:function() {
  return[this._x, this._y, this._z, this._w];
}, clone:function() {
  return new THREE.Quaternion(this._x, this._y, this._z, this._w);
}};
THREE.Quaternion.slerp = function(a, b, c, d) {
  return c.copy(a).slerp(b, d);
};
THREE.Vector2 = function(a, b) {
  this.x = a || 0;
  this.y = b || 0;
};
THREE.Vector2.prototype = {constructor:THREE.Vector2, set:function(a, b) {
  this.x = a;
  this.y = b;
  return this;
}, setX:function(a) {
  this.x = a;
  return this;
}, setY:function(a) {
  this.y = a;
  return this;
}, setComponent:function(a, b) {
  switch(a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    default:
      throw Error("index is out of range: " + a);;
  }
}, getComponent:function(a) {
  switch(a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw Error("index is out of range: " + a);;
  }
}, copy:function(a) {
  this.x = a.x;
  this.y = a.y;
  return this;
}, add:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
  }
  this.x += a.x;
  this.y += a.y;
  return this;
}, addVectors:function(a, b) {
  this.x = a.x + b.x;
  this.y = a.y + b.y;
  return this;
}, addScalar:function(a) {
  this.x += a;
  this.y += a;
  return this;
}, sub:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
  }
  this.x -= a.x;
  this.y -= a.y;
  return this;
}, subVectors:function(a, b) {
  this.x = a.x - b.x;
  this.y = a.y - b.y;
  return this;
}, multiplyScalar:function(a) {
  this.x *= a;
  this.y *= a;
  return this;
}, divideScalar:function(a) {
  0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
  return this;
}, min:function(a) {
  this.x > a.x && (this.x = a.x);
  this.y > a.y && (this.y = a.y);
  return this;
}, max:function(a) {
  this.x < a.x && (this.x = a.x);
  this.y < a.y && (this.y = a.y);
  return this;
}, clamp:function(a, b) {
  this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
  this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
  return this;
}, clampScalar:function() {
  var a, b;
  return function(c, d) {
    void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2);
    a.set(c, c);
    b.set(d, d);
    return this.clamp(a, b);
  };
}(), floor:function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  return this;
}, ceil:function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  return this;
}, round:function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  return this;
}, roundToZero:function() {
  this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
  this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
  return this;
}, negate:function() {
  return this.multiplyScalar(-1);
}, dot:function(a) {
  return this.x * a.x + this.y * a.y;
}, lengthSq:function() {
  return this.x * this.x + this.y * this.y;
}, length:function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
}, normalize:function() {
  return this.divideScalar(this.length());
}, distanceTo:function(a) {
  return Math.sqrt(this.distanceToSquared(a));
}, distanceToSquared:function(a) {
  var b = this.x - a.x;
  a = this.y - a.y;
  return b * b + a * a;
}, setLength:function(a) {
  var b = this.length();
  0 !== b && (a !== b && this.multiplyScalar(a / b));
  return this;
}, lerp:function(a, b) {
  this.x += (a.x - this.x) * b;
  this.y += (a.y - this.y) * b;
  return this;
}, equals:function(a) {
  return a.x === this.x && a.y === this.y;
}, fromArray:function(a) {
  this.x = a[0];
  this.y = a[1];
  return this;
}, toArray:function() {
  return[this.x, this.y];
}, clone:function() {
  return new THREE.Vector2(this.x, this.y);
}};
THREE.Vector3 = function(a, b, c) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
};
THREE.Vector3.prototype = {constructor:THREE.Vector3, set:function(a, b, c) {
  this.x = a;
  this.y = b;
  this.z = c;
  return this;
}, setX:function(a) {
  this.x = a;
  return this;
}, setY:function(a) {
  this.y = a;
  return this;
}, setZ:function(a) {
  this.z = a;
  return this;
}, setComponent:function(a, b) {
  switch(a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    default:
      throw Error("index is out of range: " + a);;
  }
}, getComponent:function(a) {
  switch(a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw Error("index is out of range: " + a);;
  }
}, copy:function(a) {
  this.x = a.x;
  this.y = a.y;
  this.z = a.z;
  return this;
}, add:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
  }
  this.x += a.x;
  this.y += a.y;
  this.z += a.z;
  return this;
}, addScalar:function(a) {
  this.x += a;
  this.y += a;
  this.z += a;
  return this;
}, addVectors:function(a, b) {
  this.x = a.x + b.x;
  this.y = a.y + b.y;
  this.z = a.z + b.z;
  return this;
}, sub:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
  }
  this.x -= a.x;
  this.y -= a.y;
  this.z -= a.z;
  return this;
}, subVectors:function(a, b) {
  this.x = a.x - b.x;
  this.y = a.y - b.y;
  this.z = a.z - b.z;
  return this;
}, multiply:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
  }
  this.x *= a.x;
  this.y *= a.y;
  this.z *= a.z;
  return this;
}, multiplyScalar:function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a;
  return this;
}, multiplyVectors:function(a, b) {
  this.x = a.x * b.x;
  this.y = a.y * b.y;
  this.z = a.z * b.z;
  return this;
}, applyEuler:function() {
  var a;
  return function(b) {
    !1 === b instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
    void 0 === a && (a = new THREE.Quaternion);
    this.applyQuaternion(a.setFromEuler(b));
    return this;
  };
}(), applyAxisAngle:function() {
  var a;
  return function(b, c) {
    void 0 === a && (a = new THREE.Quaternion);
    this.applyQuaternion(a.setFromAxisAngle(b, c));
    return this;
  };
}(), applyMatrix3:function(a) {
  var b = this.x, c = this.y, d = this.z;
  a = a.elements;
  this.x = a[0] * b + a[3] * c + a[6] * d;
  this.y = a[1] * b + a[4] * c + a[7] * d;
  this.z = a[2] * b + a[5] * c + a[8] * d;
  return this;
}, applyMatrix4:function(a) {
  var b = this.x, c = this.y, d = this.z;
  a = a.elements;
  this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
  this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
  this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
  return this;
}, applyProjection:function(a) {
  var b = this.x, c = this.y, d = this.z;
  a = a.elements;
  var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
  this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
  this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
  this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
  return this;
}, applyQuaternion:function(a) {
  var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
  a = a.w;
  var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d;
  this.x = h * a + b * -e + k * -g - l * -f;
  this.y = k * a + b * -f + l * -e - h * -g;
  this.z = l * a + b * -g + h * -f - k * -e;
  return this;
}, transformDirection:function(a) {
  var b = this.x, c = this.y, d = this.z;
  a = a.elements;
  this.x = a[0] * b + a[4] * c + a[8] * d;
  this.y = a[1] * b + a[5] * c + a[9] * d;
  this.z = a[2] * b + a[6] * c + a[10] * d;
  this.normalize();
  return this;
}, divide:function(a) {
  this.x /= a.x;
  this.y /= a.y;
  this.z /= a.z;
  return this;
}, divideScalar:function(a) {
  0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
  return this;
}, min:function(a) {
  this.x > a.x && (this.x = a.x);
  this.y > a.y && (this.y = a.y);
  this.z > a.z && (this.z = a.z);
  return this;
}, max:function(a) {
  this.x < a.x && (this.x = a.x);
  this.y < a.y && (this.y = a.y);
  this.z < a.z && (this.z = a.z);
  return this;
}, clamp:function(a, b) {
  this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
  this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
  this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
  return this;
}, clampScalar:function() {
  var a, b;
  return function(c, d) {
    void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3);
    a.set(c, c, c);
    b.set(d, d, d);
    return this.clamp(a, b);
  };
}(), floor:function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  this.z = Math.floor(this.z);
  return this;
}, ceil:function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  this.z = Math.ceil(this.z);
  return this;
}, round:function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  this.z = Math.round(this.z);
  return this;
}, roundToZero:function() {
  this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
  this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
  this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
  return this;
}, negate:function() {
  return this.multiplyScalar(-1);
}, dot:function(a) {
  return this.x * a.x + this.y * a.y + this.z * a.z;
}, lengthSq:function() {
  return this.x * this.x + this.y * this.y + this.z * this.z;
}, length:function() {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
}, lengthManhattan:function() {
  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
}, normalize:function() {
  return this.divideScalar(this.length());
}, setLength:function(a) {
  var b = this.length();
  0 !== b && (a !== b && this.multiplyScalar(a / b));
  return this;
}, lerp:function(a, b) {
  this.x += (a.x - this.x) * b;
  this.y += (a.y - this.y) * b;
  this.z += (a.z - this.z) * b;
  return this;
}, cross:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
  }
  var c = this.x, d = this.y, e = this.z;
  this.x = d * a.z - e * a.y;
  this.y = e * a.x - c * a.z;
  this.z = c * a.y - d * a.x;
  return this;
}, crossVectors:function(a, b) {
  var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
  this.x = d * h - e * g;
  this.y = e * f - c * h;
  this.z = c * g - d * f;
  return this;
}, projectOnVector:function() {
  var a, b;
  return function(c) {
    void 0 === a && (a = new THREE.Vector3);
    a.copy(c).normalize();
    b = this.dot(a);
    return this.copy(a).multiplyScalar(b);
  };
}(), projectOnPlane:function() {
  var a;
  return function(b) {
    void 0 === a && (a = new THREE.Vector3);
    a.copy(this).projectOnVector(b);
    return this.sub(a);
  };
}(), reflect:function() {
  var a;
  return function(b) {
    void 0 === a && (a = new THREE.Vector3);
    return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
  };
}(), angleTo:function(a) {
  a = this.dot(a) / (this.length() * a.length());
  return Math.acos(THREE.Math.clamp(a, -1, 1));
}, distanceTo:function(a) {
  return Math.sqrt(this.distanceToSquared(a));
}, distanceToSquared:function(a) {
  var b = this.x - a.x, c = this.y - a.y;
  a = this.z - a.z;
  return b * b + c * c + a * a;
}, setEulerFromRotationMatrix:function(a, b) {
  console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");
}, setEulerFromQuaternion:function(a, b) {
  console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");
}, getPositionFromMatrix:function(a) {
  console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.");
  return this.setFromMatrixPosition(a);
}, getScaleFromMatrix:function(a) {
  console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.");
  return this.setFromMatrixScale(a);
}, getColumnFromMatrix:function(a, b) {
  console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.");
  return this.setFromMatrixColumn(a, b);
}, setFromMatrixPosition:function(a) {
  this.x = a.elements[12];
  this.y = a.elements[13];
  this.z = a.elements[14];
  return this;
}, setFromMatrixScale:function(a) {
  var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
  a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
  this.x = b;
  this.y = c;
  this.z = a;
  return this;
}, setFromMatrixColumn:function(a, b) {
  var c = 4 * a, d = b.elements;
  this.x = d[c];
  this.y = d[c + 1];
  this.z = d[c + 2];
  return this;
}, equals:function(a) {
  return a.x === this.x && (a.y === this.y && a.z === this.z);
}, fromArray:function(a) {
  this.x = a[0];
  this.y = a[1];
  this.z = a[2];
  return this;
}, toArray:function() {
  return[this.x, this.y, this.z];
}, clone:function() {
  return new THREE.Vector3(this.x, this.y, this.z);
}};
THREE.Vector4 = function(a, b, c, d) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
  this.w = void 0 !== d ? d : 1;
};
THREE.Vector4.prototype = {constructor:THREE.Vector4, set:function(a, b, c, d) {
  this.x = a;
  this.y = b;
  this.z = c;
  this.w = d;
  return this;
}, setX:function(a) {
  this.x = a;
  return this;
}, setY:function(a) {
  this.y = a;
  return this;
}, setZ:function(a) {
  this.z = a;
  return this;
}, setW:function(a) {
  this.w = a;
  return this;
}, setComponent:function(a, b) {
  switch(a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    case 3:
      this.w = b;
      break;
    default:
      throw Error("index is out of range: " + a);;
  }
}, getComponent:function(a) {
  switch(a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw Error("index is out of range: " + a);;
  }
}, copy:function(a) {
  this.x = a.x;
  this.y = a.y;
  this.z = a.z;
  this.w = void 0 !== a.w ? a.w : 1;
  return this;
}, add:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
  }
  this.x += a.x;
  this.y += a.y;
  this.z += a.z;
  this.w += a.w;
  return this;
}, addScalar:function(a) {
  this.x += a;
  this.y += a;
  this.z += a;
  this.w += a;
  return this;
}, addVectors:function(a, b) {
  this.x = a.x + b.x;
  this.y = a.y + b.y;
  this.z = a.z + b.z;
  this.w = a.w + b.w;
  return this;
}, sub:function(a, b) {
  if (void 0 !== b) {
    return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
  }
  this.x -= a.x;
  this.y -= a.y;
  this.z -= a.z;
  this.w -= a.w;
  return this;
}, subVectors:function(a, b) {
  this.x = a.x - b.x;
  this.y = a.y - b.y;
  this.z = a.z - b.z;
  this.w = a.w - b.w;
  return this;
}, multiplyScalar:function(a) {
  this.x *= a;
  this.y *= a;
  this.z *= a;
  this.w *= a;
  return this;
}, applyMatrix4:function(a) {
  var b = this.x, c = this.y, d = this.z, e = this.w;
  a = a.elements;
  this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
  this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
  this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
  this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
  return this;
}, divideScalar:function(a) {
  0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
  return this;
}, setAxisAngleFromQuaternion:function(a) {
  this.w = 2 * Math.acos(a.w);
  var b = Math.sqrt(1 - a.w * a.w);
  1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
  return this;
}, setAxisAngleFromRotationMatrix:function(a) {
  var b, c, d;
  a = a.elements;
  var e = a[0];
  d = a[4];
  var f = a[8], g = a[1], h = a[5], k = a[9];
  c = a[2];
  b = a[6];
  var l = a[10];
  if (0.01 > Math.abs(d - g) && (0.01 > Math.abs(f - c) && 0.01 > Math.abs(k - b))) {
    if (0.1 > Math.abs(d + g) && (0.1 > Math.abs(f + c) && (0.1 > Math.abs(k + b) && 0.1 > Math.abs(e + h + l - 3)))) {
      return this.set(1, 0, 0, 0), this;
    }
    a = Math.PI;
    e = (e + 1) / 2;
    h = (h + 1) / 2;
    l = (l + 1) / 2;
    d = (d + g) / 4;
    f = (f + c) / 4;
    k = (k + b) / 4;
    e > h && e > l ? 0.01 > e ? (b = 0, d = c = 0.707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? 0.01 > h ? (b = 0.707106781, c = 0, d = 0.707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : 0.01 > l ? (c = b = 0.707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
    this.set(b, c, d, a);
    return this;
  }
  a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
  0.001 > Math.abs(a) && (a = 1);
  this.x = (b - k) / a;
  this.y = (f - c) / a;
  this.z = (g - d) / a;
  this.w = Math.acos((e + h + l - 1) / 2);
  return this;
}, min:function(a) {
  this.x > a.x && (this.x = a.x);
  this.y > a.y && (this.y = a.y);
  this.z > a.z && (this.z = a.z);
  this.w > a.w && (this.w = a.w);
  return this;
}, max:function(a) {
  this.x < a.x && (this.x = a.x);
  this.y < a.y && (this.y = a.y);
  this.z < a.z && (this.z = a.z);
  this.w < a.w && (this.w = a.w);
  return this;
}, clamp:function(a, b) {
  this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
  this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
  this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
  this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
  return this;
}, clampScalar:function() {
  var a, b;
  return function(c, d) {
    void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
    a.set(c, c, c, c);
    b.set(d, d, d, d);
    return this.clamp(a, b);
  };
}(), floor:function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  this.z = Math.floor(this.z);
  this.w = Math.floor(this.w);
  return this;
}, ceil:function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  this.z = Math.ceil(this.z);
  this.w = Math.ceil(this.w);
  return this;
}, round:function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  this.z = Math.round(this.z);
  this.w = Math.round(this.w);
  return this;
}, roundToZero:function() {
  this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
  this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
  this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
  this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
  return this;
}, negate:function() {
  return this.multiplyScalar(-1);
}, dot:function(a) {
  return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
}, lengthSq:function() {
  return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
}, length:function() {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
}, lengthManhattan:function() {
  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
}, normalize:function() {
  return this.divideScalar(this.length());
}, setLength:function(a) {
  var b = this.length();
  0 !== b && (a !== b && this.multiplyScalar(a / b));
  return this;
}, lerp:function(a, b) {
  this.x += (a.x - this.x) * b;
  this.y += (a.y - this.y) * b;
  this.z += (a.z - this.z) * b;
  this.w += (a.w - this.w) * b;
  return this;
}, equals:function(a) {
  return a.x === this.x && (a.y === this.y && (a.z === this.z && a.w === this.w));
}, fromArray:function(a) {
  this.x = a[0];
  this.y = a[1];
  this.z = a[2];
  this.w = a[3];
  return this;
}, toArray:function() {
  return[this.x, this.y, this.z, this.w];
}, clone:function() {
  return new THREE.Vector4(this.x, this.y, this.z, this.w);
}};
THREE.Euler = function(a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._order = d || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {constructor:THREE.Euler, _x:0, _y:0, _z:0, _order:THREE.Euler.DefaultOrder, _quaternion:void 0, _updateQuaternion:function() {
  void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1);
}, get x() {
  return this._x;
}, set x(a) {
  this._x = a;
  this._updateQuaternion();
}, get y() {
  return this._y;
}, set y(a) {
  this._y = a;
  this._updateQuaternion();
}, get z() {
  return this._z;
}, set z(a) {
  this._z = a;
  this._updateQuaternion();
}, get order() {
  return this._order;
}, set order(a) {
  this._order = a;
  this._updateQuaternion();
}, set:function(a, b, c, d) {
  this._x = a;
  this._y = b;
  this._z = c;
  this._order = d || this._order;
  this._updateQuaternion();
  return this;
}, copy:function(a) {
  this._x = a._x;
  this._y = a._y;
  this._z = a._z;
  this._order = a._order;
  this._updateQuaternion();
  return this;
}, setFromRotationMatrix:function(a, b) {
  function c(a) {
    return Math.min(Math.max(a, -1), 1);
  }
  var d = a.elements, e = d[0], f = d[4], g = d[8], h = d[1], k = d[5], l = d[9], m = d[2], q = d[6], d = d[10];
  b = b || this._order;
  "XYZ" === b ? (this._y = Math.asin(c(g)), 0.99999 > Math.abs(g) ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(q, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-c(l)), 0.99999 > Math.abs(l) ? (this._y = Math.atan2(g, d), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-m, e), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(q)), 0.99999 > Math.abs(q) ? (this._y = Math.atan2(-m, d), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, 
  e))) : "ZYX" === b ? (this._y = Math.asin(-c(m)), 0.99999 > Math.abs(m) ? (this._x = Math.atan2(q, d), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(c(h)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-m, e)) : (this._x = 0, this._y = Math.atan2(g, d))) : "XZY" === b ? (this._z = Math.asin(-c(f)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, e)) : (this._x = Math.atan2(-l, 
  d), this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + b);
  this._order = b;
  this._updateQuaternion();
  return this;
}, setFromQuaternion:function(a, b, c) {
  function d(a) {
    return Math.min(Math.max(a, -1), 1);
  }
  var e = a.x * a.x, f = a.y * a.y, g = a.z * a.z, h = a.w * a.w;
  b = b || this._order;
  "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : "YXZ" === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : "ZXY" === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * 
  a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : "ZYX" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w)))) : 
  "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + b);
  this._order = b;
  !1 !== c && this._updateQuaternion();
  return this;
}, reorder:function() {
  var a = new THREE.Quaternion;
  return function(b) {
    a.setFromEuler(this);
    this.setFromQuaternion(a, b);
  };
}(), fromArray:function(a) {
  this._x = a[0];
  this._y = a[1];
  this._z = a[2];
  void 0 !== a[3] && (this._order = a[3]);
  this._updateQuaternion();
  return this;
}, toArray:function() {
  return[this._x, this._y, this._z, this._order];
}, equals:function(a) {
  return a._x === this._x && (a._y === this._y && (a._z === this._z && a._order === this._order));
}, clone:function() {
  return new THREE.Euler(this._x, this._y, this._z, this._order);
}};
THREE.Line3 = function(a, b) {
  this.start = void 0 !== a ? a : new THREE.Vector3;
  this.end = void 0 !== b ? b : new THREE.Vector3;
};
THREE.Line3.prototype = {constructor:THREE.Line3, set:function(a, b) {
  this.start.copy(a);
  this.end.copy(b);
  return this;
}, copy:function(a) {
  this.start.copy(a.start);
  this.end.copy(a.end);
  return this;
}, center:function(a) {
  return(a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(0.5);
}, delta:function(a) {
  return(a || new THREE.Vector3).subVectors(this.end, this.start);
}, distanceSq:function() {
  return this.start.distanceToSquared(this.end);
}, distance:function() {
  return this.start.distanceTo(this.end);
}, at:function(a, b) {
  var c = b || new THREE.Vector3;
  return this.delta(c).multiplyScalar(a).add(this.start);
}, closestPointToPointParameter:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function(c, d) {
    a.subVectors(c, this.start);
    b.subVectors(this.end, this.start);
    var e = b.dot(b), e = b.dot(a) / e;
    d && (e = THREE.Math.clamp(e, 0, 1));
    return e;
  };
}(), closestPointToPoint:function(a, b, c) {
  a = this.closestPointToPointParameter(a, b);
  c = c || new THREE.Vector3;
  return this.delta(c).multiplyScalar(a).add(this.start);
}, applyMatrix4:function(a) {
  this.start.applyMatrix4(a);
  this.end.applyMatrix4(a);
  return this;
}, equals:function(a) {
  return a.start.equals(this.start) && a.end.equals(this.end);
}, clone:function() {
  return(new THREE.Line3).copy(this);
}};
THREE.Box2 = function(a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {constructor:THREE.Box2, set:function(a, b) {
  this.min.copy(a);
  this.max.copy(b);
  return this;
}, setFromPoints:function(a) {
  if (0 < a.length) {
    var b = a[0];
    this.min.copy(b);
    this.max.copy(b);
    for (var c = 1, d = a.length;c < d;c++) {
      b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y);
    }
  } else {
    this.makeEmpty();
  }
  return this;
}, setFromCenterAndSize:function() {
  var a = new THREE.Vector2;
  return function(b, c) {
    var d = a.copy(c).multiplyScalar(0.5);
    this.min.copy(b).sub(d);
    this.max.copy(b).add(d);
    return this;
  };
}(), copy:function(a) {
  this.min.copy(a.min);
  this.max.copy(a.max);
  return this;
}, makeEmpty:function() {
  this.min.x = this.min.y = Infinity;
  this.max.x = this.max.y = -Infinity;
  return this;
}, empty:function() {
  return this.max.x < this.min.x || this.max.y < this.min.y;
}, center:function(a) {
  return(a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(0.5);
}, size:function(a) {
  return(a || new THREE.Vector2).subVectors(this.max, this.min);
}, expandByPoint:function(a) {
  this.min.min(a);
  this.max.max(a);
  return this;
}, expandByVector:function(a) {
  this.min.sub(a);
  this.max.add(a);
  return this;
}, expandByScalar:function(a) {
  this.min.addScalar(-a);
  this.max.addScalar(a);
  return this;
}, containsPoint:function(a) {
  return a.x < this.min.x || (a.x > this.max.x || (a.y < this.min.y || a.y > this.max.y)) ? !1 : !0;
}, containsBox:function(a) {
  return this.min.x <= a.min.x && (a.max.x <= this.max.x && (this.min.y <= a.min.y && a.max.y <= this.max.y)) ? !0 : !1;
}, getParameter:function(a, b) {
  return(b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
}, isIntersectionBox:function(a) {
  return a.max.x < this.min.x || (a.min.x > this.max.x || (a.max.y < this.min.y || a.min.y > this.max.y)) ? !1 : !0;
}, clampPoint:function(a, b) {
  return(b || new THREE.Vector2).copy(a).clamp(this.min, this.max);
}, distanceToPoint:function() {
  var a = new THREE.Vector2;
  return function(b) {
    return a.copy(b).clamp(this.min, this.max).sub(b).length();
  };
}(), intersect:function(a) {
  this.min.max(a.min);
  this.max.min(a.max);
  return this;
}, union:function(a) {
  this.min.min(a.min);
  this.max.max(a.max);
  return this;
}, translate:function(a) {
  this.min.add(a);
  this.max.add(a);
  return this;
}, equals:function(a) {
  return a.min.equals(this.min) && a.max.equals(this.max);
}, clone:function() {
  return(new THREE.Box2).copy(this);
}};
THREE.Box3 = function(a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {constructor:THREE.Box3, set:function(a, b) {
  this.min.copy(a);
  this.max.copy(b);
  return this;
}, addPoint:function(a) {
  a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
  a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
  a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z);
}, setFromPoints:function(a) {
  if (0 < a.length) {
    var b = a[0];
    this.min.copy(b);
    this.max.copy(b);
    for (var b = 1, c = a.length;b < c;b++) {
      this.addPoint(a[b]);
    }
  } else {
    this.makeEmpty();
  }
  return this;
}, setFromCenterAndSize:function() {
  var a = new THREE.Vector3;
  return function(b, c) {
    var d = a.copy(c).multiplyScalar(0.5);
    this.min.copy(b).sub(d);
    this.max.copy(b).add(d);
    return this;
  };
}(), setFromObject:function() {
  var a = new THREE.Vector3;
  return function(b) {
    var c = this;
    b.updateMatrixWorld(!0);
    this.makeEmpty();
    b.traverse(function(b) {
      if (void 0 !== b.geometry && void 0 !== b.geometry.vertices) {
        for (var e = b.geometry.vertices, f = 0, g = e.length;f < g;f++) {
          a.copy(e[f]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
        }
      }
    });
    return this;
  };
}(), copy:function(a) {
  this.min.copy(a.min);
  this.max.copy(a.max);
  return this;
}, makeEmpty:function() {
  this.min.x = this.min.y = this.min.z = Infinity;
  this.max.x = this.max.y = this.max.z = -Infinity;
  return this;
}, empty:function() {
  return this.max.x < this.min.x || (this.max.y < this.min.y || this.max.z < this.min.z);
}, center:function(a) {
  return(a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(0.5);
}, size:function(a) {
  return(a || new THREE.Vector3).subVectors(this.max, this.min);
}, expandByPoint:function(a) {
  this.min.min(a);
  this.max.max(a);
  return this;
}, expandByVector:function(a) {
  this.min.sub(a);
  this.max.add(a);
  return this;
}, expandByScalar:function(a) {
  this.min.addScalar(-a);
  this.max.addScalar(a);
  return this;
}, containsPoint:function(a) {
  return a.x < this.min.x || (a.x > this.max.x || (a.y < this.min.y || (a.y > this.max.y || (a.z < this.min.z || a.z > this.max.z)))) ? !1 : !0;
}, containsBox:function(a) {
  return this.min.x <= a.min.x && (a.max.x <= this.max.x && (this.min.y <= a.min.y && (a.max.y <= this.max.y && (this.min.z <= a.min.z && a.max.z <= this.max.z)))) ? !0 : !1;
}, getParameter:function(a, b) {
  return(b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
}, isIntersectionBox:function(a) {
  return a.max.x < this.min.x || (a.min.x > this.max.x || (a.max.y < this.min.y || (a.min.y > this.max.y || (a.max.z < this.min.z || a.min.z > this.max.z)))) ? !1 : !0;
}, clampPoint:function(a, b) {
  return(b || new THREE.Vector3).copy(a).clamp(this.min, this.max);
}, distanceToPoint:function() {
  var a = new THREE.Vector3;
  return function(b) {
    return a.copy(b).clamp(this.min, this.max).sub(b).length();
  };
}(), getBoundingSphere:function() {
  var a = new THREE.Vector3;
  return function(b) {
    b = b || new THREE.Sphere;
    b.center = this.center();
    b.radius = 0.5 * this.size(a).length();
    return b;
  };
}(), intersect:function(a) {
  this.min.max(a.min);
  this.max.min(a.max);
  return this;
}, union:function(a) {
  this.min.min(a.min);
  this.max.max(a.max);
  return this;
}, applyMatrix4:function() {
  var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
  return function(b) {
    a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
    a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
    a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
    a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
    a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
    a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
    a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
    a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
    this.makeEmpty();
    this.setFromPoints(a);
    return this;
  };
}(), getTransformedBox:function(a, b) {
  function c(a, b, c) {
    var d = f[0] * a + f[4] * b + f[8] * c + f[12], e = f[1] * a + f[5] * b + f[9] * c + f[13];
    a = f[2] * a + f[6] * b + f[10] * c + f[14];
    d < g && (g = d);
    e < h && (h = e);
    a < k && (k = a);
    d > l && (l = d);
    e > m && (m = e);
    a > q && (q = a);
  }
  var d = this.min, e = this.max, f = a.elements, g = Infinity, h = Infinity, k = Infinity, l = -Infinity, m = -Infinity, q = -Infinity;
  c(d.x, d.y, d.z);
  c(d.x, d.y, e.z);
  c(d.x, e.y, d.z);
  c(d.x, e.y, e.z);
  c(e.x, d.y, d.z);
  c(e.x, d.y, e.z);
  c(e.x, e.y, d.z);
  c(e.x, e.y, e.z);
  b.min.set(g, h, k);
  b.max.set(l, m, q);
}, translate:function(a) {
  this.min.add(a);
  this.max.add(a);
  return this;
}, equals:function(a) {
  return a.min.equals(this.min) && a.max.equals(this.max);
}, clone:function() {
  return(new THREE.Box3).copy(this);
}};
THREE.Matrix3 = function(a, b, c, d, e, f, g, h, k) {
  this.elements = new Float32Array(9);
  this.set(void 0 !== a ? a : 1, b || 0, c || 0, d || 0, void 0 !== e ? e : 1, f || 0, g || 0, h || 0, void 0 !== k ? k : 1);
};
THREE.Matrix3.prototype = {constructor:THREE.Matrix3, set:function(a, b, c, d, e, f, g, h, k) {
  var l = this.elements;
  l[0] = a;
  l[3] = b;
  l[6] = c;
  l[1] = d;
  l[4] = e;
  l[7] = f;
  l[2] = g;
  l[5] = h;
  l[8] = k;
  return this;
}, identity:function() {
  this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
  return this;
}, copy:function(a) {
  a = a.elements;
  this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
  return this;
}, multiplyVector3:function(a) {
  console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return a.applyMatrix3(this);
}, multiplyVector3Array:function() {
  var a = new THREE.Vector3;
  return function(b) {
    for (var c = 0, d = b.length;c < d;c += 3) {
      a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
    }
    return b;
  };
}(), multiplyScalar:function(a) {
  var b = this.elements;
  b[0] *= a;
  b[3] *= a;
  b[6] *= a;
  b[1] *= a;
  b[4] *= a;
  b[7] *= a;
  b[2] *= a;
  b[5] *= a;
  b[8] *= a;
  return this;
}, determinant:function() {
  var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8];
  return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h;
}, getInverse:function(a, b) {
  var c = a.elements, d = this.elements;
  d[0] = c[10] * c[5] - c[6] * c[9];
  d[1] = -c[10] * c[1] + c[2] * c[9];
  d[2] = c[6] * c[1] - c[2] * c[5];
  d[3] = -c[10] * c[4] + c[6] * c[8];
  d[4] = c[10] * c[0] - c[2] * c[8];
  d[5] = -c[6] * c[0] + c[2] * c[4];
  d[6] = c[9] * c[4] - c[5] * c[8];
  d[7] = -c[9] * c[0] + c[1] * c[8];
  d[8] = c[5] * c[0] - c[1] * c[4];
  c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
  if (0 === c) {
    if (b) {
      throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
    }
    console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
    this.identity();
    return this;
  }
  this.multiplyScalar(1 / c);
  return this;
}, transpose:function() {
  var a, b = this.elements;
  a = b[1];
  b[1] = b[3];
  b[3] = a;
  a = b[2];
  b[2] = b[6];
  b[6] = a;
  a = b[5];
  b[5] = b[7];
  b[7] = a;
  return this;
}, getNormalMatrix:function(a) {
  this.getInverse(a).transpose();
  return this;
}, transposeIntoArray:function(a) {
  var b = this.elements;
  a[0] = b[0];
  a[1] = b[3];
  a[2] = b[6];
  a[3] = b[1];
  a[4] = b[4];
  a[5] = b[7];
  a[6] = b[2];
  a[7] = b[5];
  a[8] = b[8];
  return this;
}, fromArray:function(a) {
  this.elements.set(a);
  return this;
}, toArray:function() {
  var a = this.elements;
  return[a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
}, clone:function() {
  var a = this.elements;
  return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
}};
THREE.Matrix4 = function(a, b, c, d, e, f, g, h, k, l, m, q, p, r, s, n) {
  var t = this.elements = new Float32Array(16);
  t[0] = void 0 !== a ? a : 1;
  t[4] = b || 0;
  t[8] = c || 0;
  t[12] = d || 0;
  t[1] = e || 0;
  t[5] = void 0 !== f ? f : 1;
  t[9] = g || 0;
  t[13] = h || 0;
  t[2] = k || 0;
  t[6] = l || 0;
  t[10] = void 0 !== m ? m : 1;
  t[14] = q || 0;
  t[3] = p || 0;
  t[7] = r || 0;
  t[11] = s || 0;
  t[15] = void 0 !== n ? n : 1;
};
THREE.Matrix4.prototype = {constructor:THREE.Matrix4, set:function(a, b, c, d, e, f, g, h, k, l, m, q, p, r, s, n) {
  var t = this.elements;
  t[0] = a;
  t[4] = b;
  t[8] = c;
  t[12] = d;
  t[1] = e;
  t[5] = f;
  t[9] = g;
  t[13] = h;
  t[2] = k;
  t[6] = l;
  t[10] = m;
  t[14] = q;
  t[3] = p;
  t[7] = r;
  t[11] = s;
  t[15] = n;
  return this;
}, identity:function() {
  this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  return this;
}, copy:function(a) {
  this.elements.set(a.elements);
  return this;
}, extractPosition:function(a) {
  console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(a);
}, copyPosition:function(a) {
  var b = this.elements;
  a = a.elements;
  b[12] = a[12];
  b[13] = a[13];
  b[14] = a[14];
  return this;
}, extractRotation:function() {
  var a = new THREE.Vector3;
  return function(b) {
    var c = this.elements;
    b = b.elements;
    var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
    c[0] = b[0] * d;
    c[1] = b[1] * d;
    c[2] = b[2] * d;
    c[4] = b[4] * e;
    c[5] = b[5] * e;
    c[6] = b[6] * e;
    c[8] = b[8] * f;
    c[9] = b[9] * f;
    c[10] = b[10] * f;
    return this;
  };
}(), makeRotationFromEuler:function(a) {
  !1 === a instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
  var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
  if ("XYZ" === a.order) {
    a = f * h;
    var k = f * e, l = c * h, m = c * e;
    b[0] = g * h;
    b[4] = -g * e;
    b[8] = d;
    b[1] = k + l * d;
    b[5] = a - m * d;
    b[9] = -c * g;
    b[2] = m - a * d;
    b[6] = l + k * d;
    b[10] = f * g;
  } else {
    "YXZ" === a.order ? (a = g * h, k = g * e, l = d * h, m = d * e, b[0] = a + m * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = m + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, l = d * h, m = d * e, b[0] = a - m * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = m - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, l = c * h, m = c * e, b[0] = g * h, b[4] = 
    l * d - k, b[8] = a * d + m, b[1] = g * e, b[5] = m * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f * d, l = c * g, m = c * d, b[0] = g * h, b[4] = m - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - m * e) : "XZY" === a.order && (a = f * g, k = f * d, l = c * g, m = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + m, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - 
    k, b[6] = c * h, b[10] = m * e + a);
  }
  b[3] = 0;
  b[7] = 0;
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return this;
}, setRotationFromQuaternion:function(a) {
  console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");
  return this.makeRotationFromQuaternion(a);
}, makeRotationFromQuaternion:function(a) {
  var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, k = e + e;
  a = c * g;
  var l = c * h, c = c * k, m = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k;
  b[0] = 1 - (m + e);
  b[4] = l - f;
  b[8] = c + h;
  b[1] = l + f;
  b[5] = 1 - (a + e);
  b[9] = d - g;
  b[2] = c - h;
  b[6] = d + g;
  b[10] = 1 - (a + m);
  b[3] = 0;
  b[7] = 0;
  b[11] = 0;
  b[12] = 0;
  b[13] = 0;
  b[14] = 0;
  b[15] = 1;
  return this;
}, lookAt:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
  return function(d, e, f) {
    var g = this.elements;
    c.subVectors(d, e).normalize();
    0 === c.length() && (c.z = 1);
    a.crossVectors(f, c).normalize();
    0 === a.length() && (c.x += 1E-4, a.crossVectors(f, c).normalize());
    b.crossVectors(c, a);
    g[0] = a.x;
    g[4] = b.x;
    g[8] = c.x;
    g[1] = a.y;
    g[5] = b.y;
    g[9] = c.y;
    g[2] = a.z;
    g[6] = b.z;
    g[10] = c.z;
    return this;
  };
}(), multiply:function(a, b) {
  return void 0 !== b ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
}, multiplyMatrices:function(a, b) {
  var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], k = c[12], l = c[1], m = c[5], q = c[9], p = c[13], r = c[2], s = c[6], n = c[10], t = c[14], v = c[3], u = c[7], w = c[11], c = c[15], x = d[0], y = d[4], G = d[8], z = d[12], B = d[1], C = d[5], E = d[9], H = d[13], N = d[2], D = d[6], K = d[10], M = d[14], I = d[3], F = d[7], J = d[11], d = d[15];
  e[0] = f * x + g * B + h * N + k * I;
  e[4] = f * y + g * C + h * D + k * F;
  e[8] = f * G + g * E + h * K + k * J;
  e[12] = f * z + g * H + h * M + k * d;
  e[1] = l * x + m * B + q * N + p * I;
  e[5] = l * y + m * C + q * D + p * F;
  e[9] = l * G + m * E + q * K + p * J;
  e[13] = l * z + m * H + q * M + p * d;
  e[2] = r * x + s * B + n * N + t * I;
  e[6] = r * y + s * C + n * D + t * F;
  e[10] = r * G + s * E + n * K + t * J;
  e[14] = r * z + s * H + n * M + t * d;
  e[3] = v * x + u * B + w * N + c * I;
  e[7] = v * y + u * C + w * D + c * F;
  e[11] = v * G + u * E + w * K + c * J;
  e[15] = v * z + u * H + w * M + c * d;
  return this;
}, multiplyToArray:function(a, b, c) {
  var d = this.elements;
  this.multiplyMatrices(a, b);
  c[0] = d[0];
  c[1] = d[1];
  c[2] = d[2];
  c[3] = d[3];
  c[4] = d[4];
  c[5] = d[5];
  c[6] = d[6];
  c[7] = d[7];
  c[8] = d[8];
  c[9] = d[9];
  c[10] = d[10];
  c[11] = d[11];
  c[12] = d[12];
  c[13] = d[13];
  c[14] = d[14];
  c[15] = d[15];
  return this;
}, multiplyScalar:function(a) {
  var b = this.elements;
  b[0] *= a;
  b[4] *= a;
  b[8] *= a;
  b[12] *= a;
  b[1] *= a;
  b[5] *= a;
  b[9] *= a;
  b[13] *= a;
  b[2] *= a;
  b[6] *= a;
  b[10] *= a;
  b[14] *= a;
  b[3] *= a;
  b[7] *= a;
  b[11] *= a;
  b[15] *= a;
  return this;
}, multiplyVector3:function(a) {
  console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
  return a.applyProjection(this);
}, multiplyVector4:function(a) {
  console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return a.applyMatrix4(this);
}, multiplyVector3Array:function() {
  var a = new THREE.Vector3;
  return function(b) {
    for (var c = 0, d = b.length;c < d;c += 3) {
      a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
    }
    return b;
  };
}(), rotateAxis:function(a) {
  console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  a.transformDirection(this);
}, crossVector:function(a) {
  console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return a.applyMatrix4(this);
}, determinant:function() {
  var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], m = a[6], q = a[10], p = a[14];
  return a[3] * (+e * h * m - d * k * m - e * g * q + c * k * q + d * g * p - c * h * p) + a[7] * (+b * h * p - b * k * q + e * f * q - d * f * p + d * k * l - e * h * l) + a[11] * (+b * k * m - b * g * p - e * f * m + c * f * p + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * m + b * g * q + d * f * m - c * f * q + c * h * l);
}, transpose:function() {
  var a = this.elements, b;
  b = a[1];
  a[1] = a[4];
  a[4] = b;
  b = a[2];
  a[2] = a[8];
  a[8] = b;
  b = a[6];
  a[6] = a[9];
  a[9] = b;
  b = a[3];
  a[3] = a[12];
  a[12] = b;
  b = a[7];
  a[7] = a[13];
  a[13] = b;
  b = a[11];
  a[11] = a[14];
  a[14] = b;
  return this;
}, flattenToArray:function(a) {
  var b = this.elements;
  a[0] = b[0];
  a[1] = b[1];
  a[2] = b[2];
  a[3] = b[3];
  a[4] = b[4];
  a[5] = b[5];
  a[6] = b[6];
  a[7] = b[7];
  a[8] = b[8];
  a[9] = b[9];
  a[10] = b[10];
  a[11] = b[11];
  a[12] = b[12];
  a[13] = b[13];
  a[14] = b[14];
  a[15] = b[15];
  return a;
}, flattenToArrayOffset:function(a, b) {
  var c = this.elements;
  a[b] = c[0];
  a[b + 1] = c[1];
  a[b + 2] = c[2];
  a[b + 3] = c[3];
  a[b + 4] = c[4];
  a[b + 5] = c[5];
  a[b + 6] = c[6];
  a[b + 7] = c[7];
  a[b + 8] = c[8];
  a[b + 9] = c[9];
  a[b + 10] = c[10];
  a[b + 11] = c[11];
  a[b + 12] = c[12];
  a[b + 13] = c[13];
  a[b + 14] = c[14];
  a[b + 15] = c[15];
  return a;
}, getPosition:function() {
  var a = new THREE.Vector3;
  return function() {
    console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
    var b = this.elements;
    return a.set(b[12], b[13], b[14]);
  };
}(), setPosition:function(a) {
  var b = this.elements;
  b[12] = a.x;
  b[13] = a.y;
  b[14] = a.z;
  return this;
}, getInverse:function(a, b) {
  var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], k = d[1], l = d[5], m = d[9], q = d[13], p = d[2], r = d[6], s = d[10], n = d[14], t = d[3], v = d[7], u = d[11], d = d[15];
  c[0] = m * n * v - q * s * v + q * r * u - l * n * u - m * r * d + l * s * d;
  c[4] = h * s * v - g * n * v - h * r * u + f * n * u + g * r * d - f * s * d;
  c[8] = g * q * v - h * m * v + h * l * u - f * q * u - g * l * d + f * m * d;
  c[12] = h * m * r - g * q * r - h * l * s + f * q * s + g * l * n - f * m * n;
  c[1] = q * s * t - m * n * t - q * p * u + k * n * u + m * p * d - k * s * d;
  c[5] = g * n * t - h * s * t + h * p * u - e * n * u - g * p * d + e * s * d;
  c[9] = h * m * t - g * q * t - h * k * u + e * q * u + g * k * d - e * m * d;
  c[13] = g * q * p - h * m * p + h * k * s - e * q * s - g * k * n + e * m * n;
  c[2] = l * n * t - q * r * t + q * p * v - k * n * v - l * p * d + k * r * d;
  c[6] = h * r * t - f * n * t - h * p * v + e * n * v + f * p * d - e * r * d;
  c[10] = f * q * t - h * l * t + h * k * v - e * q * v - f * k * d + e * l * d;
  c[14] = h * l * p - f * q * p - h * k * r + e * q * r + f * k * n - e * l * n;
  c[3] = m * r * t - l * s * t - m * p * v + k * s * v + l * p * u - k * r * u;
  c[7] = f * s * t - g * r * t + g * p * v - e * s * v - f * p * u + e * r * u;
  c[11] = g * l * t - f * m * t - g * k * v + e * m * v + f * k * u - e * l * u;
  c[15] = f * m * p - g * l * p + g * k * r - e * m * r - f * k * s + e * l * s;
  c = e * c[0] + k * c[4] + p * c[8] + t * c[12];
  if (0 == c) {
    if (b) {
      throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
    }
    console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
    this.identity();
    return this;
  }
  this.multiplyScalar(1 / c);
  return this;
}, translate:function(a) {
  console.warn("DEPRECATED: Matrix4's .translate() has been removed.");
}, rotateX:function(a) {
  console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.");
}, rotateY:function(a) {
  console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.");
}, rotateZ:function(a) {
  console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.");
}, rotateByAxis:function(a, b) {
  console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.");
}, scale:function(a) {
  var b = this.elements, c = a.x, d = a.y;
  a = a.z;
  b[0] *= c;
  b[4] *= d;
  b[8] *= a;
  b[1] *= c;
  b[5] *= d;
  b[9] *= a;
  b[2] *= c;
  b[6] *= d;
  b[10] *= a;
  b[3] *= c;
  b[7] *= d;
  b[11] *= a;
  return this;
}, getMaxScaleOnAxis:function() {
  var a = this.elements;
  return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
}, makeTranslation:function(a, b, c) {
  this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
  return this;
}, makeRotationX:function(a) {
  var b = Math.cos(a);
  a = Math.sin(a);
  this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
  return this;
}, makeRotationY:function(a) {
  var b = Math.cos(a);
  a = Math.sin(a);
  this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
  return this;
}, makeRotationZ:function(a) {
  var b = Math.cos(a);
  a = Math.sin(a);
  this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  return this;
}, makeRotationAxis:function(a, b) {
  var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, k = e * f, l = e * g;
  this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
  return this;
}, makeScale:function(a, b, c) {
  this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
  return this;
}, compose:function(a, b, c) {
  this.makeRotationFromQuaternion(b);
  this.scale(c);
  this.setPosition(a);
  return this;
}, decompose:function() {
  var a = new THREE.Vector3, b = new THREE.Matrix4;
  return function(c, d, e) {
    var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length();
    0 > this.determinant() && (g = -g);
    c.x = f[12];
    c.y = f[13];
    c.z = f[14];
    b.elements.set(this.elements);
    c = 1 / g;
    var f = 1 / h, l = 1 / k;
    b.elements[0] *= c;
    b.elements[1] *= c;
    b.elements[2] *= c;
    b.elements[4] *= f;
    b.elements[5] *= f;
    b.elements[6] *= f;
    b.elements[8] *= l;
    b.elements[9] *= l;
    b.elements[10] *= l;
    d.setFromRotationMatrix(b);
    e.x = g;
    e.y = h;
    e.z = k;
    return this;
  };
}(), makeFrustum:function(a, b, c, d, e, f) {
  var g = this.elements;
  g[0] = 2 * e / (b - a);
  g[4] = 0;
  g[8] = (b + a) / (b - a);
  g[12] = 0;
  g[1] = 0;
  g[5] = 2 * e / (d - c);
  g[9] = (d + c) / (d - c);
  g[13] = 0;
  g[2] = 0;
  g[6] = 0;
  g[10] = -(f + e) / (f - e);
  g[14] = -2 * f * e / (f - e);
  g[3] = 0;
  g[7] = 0;
  g[11] = -1;
  g[15] = 0;
  return this;
}, makePerspective:function(a, b, c, d) {
  a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
  var e = -a;
  return this.makeFrustum(e * b, a * b, e, a, c, d);
}, makeOrthographic:function(a, b, c, d, e, f) {
  var g = this.elements, h = b - a, k = c - d, l = f - e;
  g[0] = 2 / h;
  g[4] = 0;
  g[8] = 0;
  g[12] = -((b + a) / h);
  g[1] = 0;
  g[5] = 2 / k;
  g[9] = 0;
  g[13] = -((c + d) / k);
  g[2] = 0;
  g[6] = 0;
  g[10] = -2 / l;
  g[14] = -((f + e) / l);
  g[3] = 0;
  g[7] = 0;
  g[11] = 0;
  g[15] = 1;
  return this;
}, fromArray:function(a) {
  this.elements.set(a);
  return this;
}, toArray:function() {
  var a = this.elements;
  return[a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]];
}, clone:function() {
  var a = this.elements;
  return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);
}};
THREE.Ray = function(a, b) {
  this.origin = void 0 !== a ? a : new THREE.Vector3;
  this.direction = void 0 !== b ? b : new THREE.Vector3;
};
THREE.Ray.prototype = {constructor:THREE.Ray, set:function(a, b) {
  this.origin.copy(a);
  this.direction.copy(b);
  return this;
}, copy:function(a) {
  this.origin.copy(a.origin);
  this.direction.copy(a.direction);
  return this;
}, at:function(a, b) {
  return(b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin);
}, recast:function() {
  var a = new THREE.Vector3;
  return function(b) {
    this.origin.copy(this.at(b, a));
    return this;
  };
}(), closestPointToPoint:function(a, b) {
  var c = b || new THREE.Vector3;
  c.subVectors(a, this.origin);
  var d = c.dot(this.direction);
  return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
}, distanceToPoint:function() {
  var a = new THREE.Vector3;
  return function(b) {
    var c = a.subVectors(b, this.origin).dot(this.direction);
    if (0 > c) {
      return this.origin.distanceTo(b);
    }
    a.copy(this.direction).multiplyScalar(c).add(this.origin);
    return a.distanceTo(b);
  };
}(), distanceSqToSegment:function(a, b, c, d) {
  var e = a.clone().add(b).multiplyScalar(0.5), f = b.clone().sub(a).normalize(), g = 0.5 * a.distanceTo(b), h = this.origin.clone().sub(e);
  a = -this.direction.dot(f);
  b = h.dot(this.direction);
  var k = -h.dot(f), l = h.lengthSq(), m = Math.abs(1 - a * a), q, p;
  0 <= m ? (h = a * k - b, q = a * b - k, p = g * m, 0 <= h ? q >= -p ? q <= p ? (g = 1 / m, h *= g, q *= g, a = h * (h + a * q + 2 * b) + q * (a * h + q + 2 * k) + l) : (q = g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l) : (q = -g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l) : q <= -p ? (h = Math.max(0, -(-a * g + b)), q = 0 < h ? -g : Math.min(Math.max(-g, -k), g), a = -h * h + q * (q + 2 * k) + l) : q <= p ? (h = 0, q = Math.min(Math.max(-g, -k), g), a = 
  q * (q + 2 * k) + l) : (h = Math.max(0, -(a * g + b)), q = 0 < h ? g : Math.min(Math.max(-g, -k), g), a = -h * h + q * (q + 2 * k) + l)) : (q = 0 < a ? -g : g, h = Math.max(0, -(a * q + b)), a = -h * h + q * (q + 2 * k) + l);
  c && c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));
  d && d.copy(f.clone().multiplyScalar(q).add(e));
  return a;
}, isIntersectionSphere:function(a) {
  return this.distanceToPoint(a.center) <= a.radius;
}, isIntersectionPlane:function(a) {
  var b = a.distanceToPoint(this.origin);
  return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
}, distanceToPlane:function(a) {
  var b = a.normal.dot(this.direction);
  if (0 == b) {
    return 0 == a.distanceToPoint(this.origin) ? 0 : null;
  }
  a = -(this.origin.dot(a.normal) + a.constant) / b;
  return 0 <= a ? a : null;
}, intersectPlane:function(a, b) {
  var c = this.distanceToPlane(a);
  return null === c ? null : this.at(c, b);
}, isIntersectionBox:function() {
  var a = new THREE.Vector3;
  return function(b) {
    return null !== this.intersectBox(b, a);
  };
}(), intersectBox:function(a, b) {
  var c, d, e, f, g;
  d = 1 / this.direction.x;
  f = 1 / this.direction.y;
  g = 1 / this.direction.z;
  var h = this.origin;
  0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
  0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
  if (c > f || e > d) {
    return null;
  }
  if (e > c || c !== c) {
    c = e;
  }
  if (f < d || d !== d) {
    d = f;
  }
  0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
  if (c > g || e > d) {
    return null;
  }
  if (e > c || c !== c) {
    c = e;
  }
  if (g < d || d !== d) {
    d = g;
  }
  return 0 > d ? null : this.at(0 <= c ? c : d, b);
}, intersectTriangle:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3, d = new THREE.Vector3;
  return function(e, f, g, h, k) {
    b.subVectors(f, e);
    c.subVectors(g, e);
    d.crossVectors(b, c);
    f = this.direction.dot(d);
    if (0 < f) {
      if (h) {
        return null;
      }
      h = 1;
    } else {
      if (0 > f) {
        h = -1, f = -f;
      } else {
        return null;
      }
    }
    a.subVectors(this.origin, e);
    e = h * this.direction.dot(c.crossVectors(a, c));
    if (0 > e) {
      return null;
    }
    g = h * this.direction.dot(b.cross(a));
    if (0 > g || e + g > f) {
      return null;
    }
    e = -h * a.dot(d);
    return 0 > e ? null : this.at(e / f, k);
  };
}(), applyMatrix4:function(a) {
  this.direction.add(this.origin).applyMatrix4(a);
  this.origin.applyMatrix4(a);
  this.direction.sub(this.origin);
  this.direction.normalize();
  return this;
}, equals:function(a) {
  return a.origin.equals(this.origin) && a.direction.equals(this.direction);
}, clone:function() {
  return(new THREE.Ray).copy(this);
}};
THREE.Sphere = function(a, b) {
  this.center = void 0 !== a ? a : new THREE.Vector3;
  this.radius = void 0 !== b ? b : 0;
};
THREE.Sphere.prototype = {constructor:THREE.Sphere, set:function(a, b) {
  this.center.copy(a);
  this.radius = b;
  return this;
}, setFromPoints:function() {
  var a = new THREE.Box3;
  return function(b, c) {
    var d = this.center;
    void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
    for (var e = 0, f = 0, g = b.length;f < g;f++) {
      e = Math.max(e, d.distanceToSquared(b[f]));
    }
    this.radius = Math.sqrt(e);
    return this;
  };
}(), copy:function(a) {
  this.center.copy(a.center);
  this.radius = a.radius;
  return this;
}, empty:function() {
  return 0 >= this.radius;
}, containsPoint:function(a) {
  return a.distanceToSquared(this.center) <= this.radius * this.radius;
}, distanceToPoint:function(a) {
  return a.distanceTo(this.center) - this.radius;
}, intersectsSphere:function(a) {
  var b = this.radius + a.radius;
  return a.center.distanceToSquared(this.center) <= b * b;
}, clampPoint:function(a, b) {
  var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3;
  d.copy(a);
  c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
  return d;
}, getBoundingBox:function(a) {
  a = a || new THREE.Box3;
  a.set(this.center, this.center);
  a.expandByScalar(this.radius);
  return a;
}, applyMatrix4:function(a) {
  this.center.applyMatrix4(a);
  this.radius *= a.getMaxScaleOnAxis();
  return this;
}, translate:function(a) {
  this.center.add(a);
  return this;
}, equals:function(a) {
  return a.center.equals(this.center) && a.radius === this.radius;
}, clone:function() {
  return(new THREE.Sphere).copy(this);
}};
THREE.Frustum = function(a, b, c, d, e, f) {
  this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane];
};
THREE.Frustum.prototype = {constructor:THREE.Frustum, set:function(a, b, c, d, e, f) {
  var g = this.planes;
  g[0].copy(a);
  g[1].copy(b);
  g[2].copy(c);
  g[3].copy(d);
  g[4].copy(e);
  g[5].copy(f);
  return this;
}, copy:function(a) {
  for (var b = this.planes, c = 0;6 > c;c++) {
    b[c].copy(a.planes[c]);
  }
  return this;
}, setFromMatrix:function(a) {
  var b = this.planes, c = a.elements;
  a = c[0];
  var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], m = c[8], q = c[9], p = c[10], r = c[11], s = c[12], n = c[13], t = c[14], c = c[15];
  b[0].setComponents(f - a, l - g, r - m, c - s).normalize();
  b[1].setComponents(f + a, l + g, r + m, c + s).normalize();
  b[2].setComponents(f + d, l + h, r + q, c + n).normalize();
  b[3].setComponents(f - d, l - h, r - q, c - n).normalize();
  b[4].setComponents(f - e, l - k, r - p, c - t).normalize();
  b[5].setComponents(f + e, l + k, r + p, c + t).normalize();
  return this;
}, intersectsObject:function() {
  var a = new THREE.Sphere;
  return function(b) {
    var c = b.geometry;
    null === c.boundingSphere && c.computeBoundingSphere();
    a.copy(c.boundingSphere);
    a.applyMatrix4(b.matrixWorld);
    return this.intersectsSphere(a);
  };
}(), intersectsSphere:function(a) {
  var b = this.planes, c = a.center;
  a = -a.radius;
  for (var d = 0;6 > d;d++) {
    if (b[d].distanceToPoint(c) < a) {
      return!1;
    }
  }
  return!0;
}, intersectsBox:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function(c) {
    for (var d = this.planes, e = 0;6 > e;e++) {
      var f = d[e];
      a.x = 0 < f.normal.x ? c.min.x : c.max.x;
      b.x = 0 < f.normal.x ? c.max.x : c.min.x;
      a.y = 0 < f.normal.y ? c.min.y : c.max.y;
      b.y = 0 < f.normal.y ? c.max.y : c.min.y;
      a.z = 0 < f.normal.z ? c.min.z : c.max.z;
      b.z = 0 < f.normal.z ? c.max.z : c.min.z;
      var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
      if (0 > g && 0 > f) {
        return!1;
      }
    }
    return!0;
  };
}(), containsPoint:function(a) {
  for (var b = this.planes, c = 0;6 > c;c++) {
    if (0 > b[c].distanceToPoint(a)) {
      return!1;
    }
  }
  return!0;
}, clone:function() {
  return(new THREE.Frustum).copy(this);
}};
THREE.Plane = function(a, b) {
  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
  this.constant = void 0 !== b ? b : 0;
};
THREE.Plane.prototype = {constructor:THREE.Plane, set:function(a, b) {
  this.normal.copy(a);
  this.constant = b;
  return this;
}, setComponents:function(a, b, c, d) {
  this.normal.set(a, b, c);
  this.constant = d;
  return this;
}, setFromNormalAndCoplanarPoint:function(a, b) {
  this.normal.copy(a);
  this.constant = -b.dot(this.normal);
  return this;
}, setFromCoplanarPoints:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function(c, d, e) {
    d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
    this.setFromNormalAndCoplanarPoint(d, c);
    return this;
  };
}(), copy:function(a) {
  this.normal.copy(a.normal);
  this.constant = a.constant;
  return this;
}, normalize:function() {
  var a = 1 / this.normal.length();
  this.normal.multiplyScalar(a);
  this.constant *= a;
  return this;
}, negate:function() {
  this.constant *= -1;
  this.normal.negate();
  return this;
}, distanceToPoint:function(a) {
  return this.normal.dot(a) + this.constant;
}, distanceToSphere:function(a) {
  return this.distanceToPoint(a.center) - a.radius;
}, projectPoint:function(a, b) {
  return this.orthoPoint(a, b).sub(a).negate();
}, orthoPoint:function(a, b) {
  var c = this.distanceToPoint(a);
  return(b || new THREE.Vector3).copy(this.normal).multiplyScalar(c);
}, isIntersectionLine:function(a) {
  var b = this.distanceToPoint(a.start);
  a = this.distanceToPoint(a.end);
  return 0 > b && 0 < a || 0 > a && 0 < b;
}, intersectLine:function() {
  var a = new THREE.Vector3;
  return function(b, c) {
    var d = c || new THREE.Vector3, e = b.delta(a), f = this.normal.dot(e);
    if (0 == f) {
      if (0 == this.distanceToPoint(b.start)) {
        return d.copy(b.start);
      }
    } else {
      return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);
    }
  };
}(), coplanarPoint:function(a) {
  return(a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant);
}, applyMatrix4:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Matrix3;
  return function(d, e) {
    var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
    g.applyMatrix4(d);
    this.setFromNormalAndCoplanarPoint(f, g);
    return this;
  };
}(), translate:function(a) {
  this.constant -= a.dot(this.normal);
  return this;
}, equals:function(a) {
  return a.normal.equals(this.normal) && a.constant == this.constant;
}, clone:function() {
  return(new THREE.Plane).copy(this);
}};
THREE.Math = {PI2:2 * Math.PI, generateUUID:function() {
  var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), b = Array(36), c = 0, d;
  return function() {
    for (var e = 0;36 > e;e++) {
      8 == e || (13 == e || (18 == e || 23 == e)) ? b[e] = "-" : 14 == e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
    }
    return b.join("");
  };
}(), clamp:function(a, b, c) {
  return a < b ? b : a > c ? c : a;
}, clampBottom:function(a, b) {
  return a < b ? b : a;
}, mapLinear:function(a, b, c, d, e) {
  return d + (a - b) * (e - d) / (c - b);
}, smoothstep:function(a, b, c) {
  if (a <= b) {
    return 0;
  }
  if (a >= c) {
    return 1;
  }
  a = (a - b) / (c - b);
  return a * a * (3 - 2 * a);
}, smootherstep:function(a, b, c) {
  if (a <= b) {
    return 0;
  }
  if (a >= c) {
    return 1;
  }
  a = (a - b) / (c - b);
  return a * a * a * (a * (6 * a - 15) + 10);
}, random16:function() {
  return(65280 * Math.random() + 255 * Math.random()) / 65535;
}, randInt:function(a, b) {
  return a + Math.floor(Math.random() * (b - a + 1));
}, randFloat:function(a, b) {
  return a + Math.random() * (b - a);
}, randFloatSpread:function(a) {
  return a * (0.5 - Math.random());
}, sign:function(a) {
  return 0 > a ? -1 : 0 < a ? 1 : 0;
}, degToRad:function() {
  var a = Math.PI / 180;
  return function(b) {
    return b * a;
  };
}(), radToDeg:function() {
  var a = 180 / Math.PI;
  return function(b) {
    return b * a;
  };
}(), isPowerOfTwo:function(a) {
  return 0 === (a & a - 1) && 0 !== a;
}};
THREE.Spline = function(a) {
  function b(a, b, c, d, e, f, g) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    return(2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
  }
  this.points = a;
  var c = [], d = {x:0, y:0, z:0}, e, f, g, h, k, l, m, q, p;
  this.initFromArray = function(a) {
    this.points = [];
    for (var b = 0;b < a.length;b++) {
      this.points[b] = {x:a[b][0], y:a[b][1], z:a[b][2]};
    }
  };
  this.getPoint = function(a) {
    e = (this.points.length - 1) * a;
    f = Math.floor(e);
    g = e - f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
    l = this.points[c[0]];
    m = this.points[c[1]];
    q = this.points[c[2]];
    p = this.points[c[3]];
    h = g * g;
    k = g * h;
    d.x = b(l.x, m.x, q.x, p.x, g, h, k);
    d.y = b(l.y, m.y, q.y, p.y, g, h, k);
    d.z = b(l.z, m.z, q.z, p.z, g, h, k);
    return d;
  };
  this.getControlPointsArray = function() {
    var a, b, c = this.points.length, d = [];
    for (a = 0;a < c;a++) {
      b = this.points[a], d[a] = [b.x, b.y, b.z];
    }
    return d;
  };
  this.getLength = function(a) {
    var b, c, d, e = b = b = 0, f = new THREE.Vector3, g = new THREE.Vector3, h = [], k = 0;
    h[0] = 0;
    a || (a = 100);
    c = this.points.length * a;
    f.copy(this.points[0]);
    for (a = 1;a < c;a++) {
      b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
    }
    h[h.length] = k;
    return{chunks:h, total:k};
  };
  this.reparametrizeByArcLength = function(a) {
    var b, c, d, e, f, g, h = [], k = new THREE.Vector3, l = this.getLength();
    h.push(k.copy(this.points[0]).clone());
    for (b = 1;b < this.points.length;b++) {
      c = l.chunks[b] - l.chunks[b - 1];
      g = Math.ceil(a * c / l.total);
      e = (b - 1) / (this.points.length - 1);
      f = b / (this.points.length - 1);
      for (c = 1;c < g - 1;c++) {
        d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
      }
      h.push(k.copy(this.points[b]).clone());
    }
    this.points = h;
  };
};
THREE.Triangle = function(a, b, c) {
  this.a = void 0 !== a ? a : new THREE.Vector3;
  this.b = void 0 !== b ? b : new THREE.Vector3;
  this.c = void 0 !== c ? c : new THREE.Vector3;
};
THREE.Triangle.normal = function() {
  var a = new THREE.Vector3;
  return function(b, c, d, e) {
    e = e || new THREE.Vector3;
    e.subVectors(d, c);
    a.subVectors(b, c);
    e.cross(a);
    b = e.lengthSq();
    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function() {
  var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
  return function(d, e, f, g, h) {
    a.subVectors(g, e);
    b.subVectors(f, e);
    c.subVectors(d, e);
    d = a.dot(a);
    e = a.dot(b);
    f = a.dot(c);
    var k = b.dot(b);
    g = b.dot(c);
    var l = d * k - e * e;
    h = h || new THREE.Vector3;
    if (0 == l) {
      return h.set(-2, -1, -1);
    }
    l = 1 / l;
    k = (k * f - e * g) * l;
    d = (d * g - e * f) * l;
    return h.set(1 - k - d, d, k);
  };
}();
THREE.Triangle.containsPoint = function() {
  var a = new THREE.Vector3;
  return function(b, c, d, e) {
    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
    return 0 <= b.x && (0 <= b.y && 1 >= b.x + b.y);
  };
}();
THREE.Triangle.prototype = {constructor:THREE.Triangle, set:function(a, b, c) {
  this.a.copy(a);
  this.b.copy(b);
  this.c.copy(c);
  return this;
}, setFromPointsAndIndices:function(a, b, c, d) {
  this.a.copy(a[b]);
  this.b.copy(a[c]);
  this.c.copy(a[d]);
  return this;
}, copy:function(a) {
  this.a.copy(a.a);
  this.b.copy(a.b);
  this.c.copy(a.c);
  return this;
}, area:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function() {
    a.subVectors(this.c, this.b);
    b.subVectors(this.a, this.b);
    return 0.5 * a.cross(b).length();
  };
}(), midpoint:function(a) {
  return(a || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
}, normal:function(a) {
  return THREE.Triangle.normal(this.a, this.b, this.c, a);
}, plane:function(a) {
  return(a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c);
}, barycoordFromPoint:function(a, b) {
  return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
}, containsPoint:function(a) {
  return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
}, equals:function(a) {
  return a.a.equals(this.a) && (a.b.equals(this.b) && a.c.equals(this.c));
}, clone:function() {
  return(new THREE.Triangle).copy(this);
}};
THREE.Vertex = function(a) {
  console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");
  return a;
};
THREE.UV = function(a, b) {
  console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");
  return new THREE.Vector2(a, b);
};
THREE.Clock = function(a) {
  this.autoStart = void 0 !== a ? a : !0;
  this.elapsedTime = this.oldTime = this.startTime = 0;
  this.running = !1;
};
THREE.Clock.prototype = {constructor:THREE.Clock, start:function() {
  this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
  this.running = !0;
}, stop:function() {
  this.getElapsedTime();
  this.running = !1;
}, getElapsedTime:function() {
  this.getDelta();
  return this.elapsedTime;
}, getDelta:function() {
  var a = 0;
  this.autoStart && (!this.running && this.start());
  if (this.running) {
    var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = 0.001 * (b - this.oldTime);
    this.oldTime = b;
    this.elapsedTime += a;
  }
  return a;
}};
THREE.EventDispatcher = function() {
};
THREE.EventDispatcher.prototype = {constructor:THREE.EventDispatcher, apply:function(a) {
  a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
  a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
  a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
  a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
}, addEventListener:function(a, b) {
  void 0 === this._listeners && (this._listeners = {});
  var c = this._listeners;
  void 0 === c[a] && (c[a] = []);
  -1 === c[a].indexOf(b) && c[a].push(b);
}, hasEventListener:function(a, b) {
  if (void 0 === this._listeners) {
    return!1;
  }
  var c = this._listeners;
  return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
}, removeEventListener:function(a, b) {
  if (void 0 !== this._listeners) {
    var c = this._listeners[a];
    if (void 0 !== c) {
      var d = c.indexOf(b);
      -1 !== d && c.splice(d, 1);
    }
  }
}, dispatchEvent:function() {
  var a = [];
  return function(b) {
    if (void 0 !== this._listeners) {
      var c = this._listeners[b.type];
      if (void 0 !== c) {
        b.target = this;
        for (var d = c.length, e = 0;e < d;e++) {
          a[e] = c[e];
        }
        for (e = 0;e < d;e++) {
          a[e].call(this, b);
        }
      }
    }
  };
}()};
(function(a) {
  a.Raycaster = function(b, c, d, e) {
    this.ray = new a.Ray(b, c);
    this.near = d || 0;
    this.far = e || Infinity;
  };
  var b = new a.Sphere, c = new a.Ray;
  new a.Plane;
  new a.Vector3;
  var d = new a.Vector3, e = new a.Matrix4, f = function(a, b) {
    return a.distance - b.distance;
  }, g = new a.Vector3, h = new a.Vector3, k = new a.Vector3, l = function(f, m, r) {
    if (f instanceof a.Sprite) {
      d.setFromMatrixPosition(f.matrixWorld);
      var s = m.ray.distanceToPoint(d);
      if (s > f.scale.x) {
        return r;
      }
      r.push({distance:s, point:f.position, face:null, object:f});
    } else {
      if (f instanceof a.LOD) {
        d.setFromMatrixPosition(f.matrixWorld), s = m.ray.origin.distanceTo(d), l(f.getObjectForDistance(s), m, r);
      } else {
        if (f instanceof a.Mesh) {
          var n = f.geometry;
          null === n.boundingSphere && n.computeBoundingSphere();
          b.copy(n.boundingSphere);
          b.applyMatrix4(f.matrixWorld);
          if (!1 === m.ray.isIntersectionSphere(b)) {
            return r;
          }
          e.getInverse(f.matrixWorld);
          c.copy(m.ray).applyMatrix4(e);
          if (null !== n.boundingBox && !1 === c.isIntersectionBox(n.boundingBox)) {
            return r;
          }
          if (n instanceof a.BufferGeometry) {
            var t = f.material;
            if (void 0 === t) {
              return r;
            }
            var v = n.attributes, u, w, x = m.precision;
            if (void 0 !== v.index) {
              for (var y = v.index.array, G = n.offsets || [{start:0, index:0, count:y.length}], z = n.vb ? n.vb : v.position.array, B = n.vb ? n.vbstride : 3, C = 0, E = G.length;C < E;++C) {
                for (var v = G[C].start, H = G[C].index, n = v, N = v + G[C].count;n < N;n += 3) {
                  v = H + y[n];
                  u = H + y[n + 1];
                  w = H + y[n + 2];
                  g.set(z[v * B], z[v * B + 1], z[v * B + 2]);
                  h.set(z[u * B], z[u * B + 1], z[u * B + 2]);
                  k.set(z[w * B], z[w * B + 1], z[w * B + 2]);
                  var D = t.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, t.side !== a.DoubleSide);
                  null !== D && (D.applyMatrix4(f.matrixWorld), s = m.ray.origin.distanceTo(D), s < x || (s < m.near || (s > m.far || r.push({distance:s, point:D, indices:[v, u, w], face:null, faceIndex:null, object:f}))));
                }
              }
            } else {
              for (z = n.vb ? n.vb : v.position.array, B = n.vb ? n.vbstride : 3, n = 0, N = v.position.array.length;n < N;n += 3) {
                v = n, u = n + 1, w = n + 2, g.set(z[v * B], z[v * B + 1], z[v * B + 2]), h.set(z[u * B], z[u * B + 1], z[u * B + 2]), k.set(z[w * B], z[w * B + 1], z[w * B + 2]), D = t.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, t.side !== a.DoubleSide), null !== D && (D.applyMatrix4(f.matrixWorld), s = m.ray.origin.distanceTo(D), s < x || (s < m.near || (s > m.far || r.push({distance:s, point:D, indices:[v, u, w], face:null, faceIndex:null, object:f}))))
                ;
              }
            }
          } else {
            if (n instanceof a.Geometry) {
              for (G = f.material instanceof a.MeshFaceMaterial, z = !0 === G ? f.material.materials : null, x = m.precision, y = n.vertices, B = 0, C = n.faces.length;B < C;B++) {
                if (E = n.faces[B], t = !0 === G ? z[E.materialIndex] : f.material, void 0 !== t) {
                  v = y[E.a];
                  u = y[E.b];
                  w = y[E.c];
                  if (!0 === t.morphTargets) {
                    s = n.morphTargets;
                    D = f.morphTargetInfluences;
                    g.set(0, 0, 0);
                    h.set(0, 0, 0);
                    k.set(0, 0, 0);
                    H = 0;
                    for (N = s.length;H < N;H++) {
                      var K = D[H];
                      if (0 !== K) {
                        var M = s[H].vertices;
                        g.x += (M[E.a].x - v.x) * K;
                        g.y += (M[E.a].y - v.y) * K;
                        g.z += (M[E.a].z - v.z) * K;
                        h.x += (M[E.b].x - u.x) * K;
                        h.y += (M[E.b].y - u.y) * K;
                        h.z += (M[E.b].z - u.z) * K;
                        k.x += (M[E.c].x - w.x) * K;
                        k.y += (M[E.c].y - w.y) * K;
                        k.z += (M[E.c].z - w.z) * K;
                      }
                    }
                    g.add(v);
                    h.add(u);
                    k.add(w);
                    v = g;
                    u = h;
                    w = k;
                  }
                  D = t.side === a.BackSide ? c.intersectTriangle(w, u, v, !0) : c.intersectTriangle(v, u, w, t.side !== a.DoubleSide);
                  null !== D && (D.applyMatrix4(f.matrixWorld), s = m.ray.origin.distanceTo(D), s < x || (s < m.near || (s > m.far || r.push({distance:s, point:D, face:E, faceIndex:B, object:f}))));
                }
              }
            }
          }
        } else {
          if (f instanceof a.Line) {
            x = m.linePrecision;
            t = x * x;
            n = f.geometry;
            null === n.boundingSphere && n.computeBoundingSphere();
            b.copy(n.boundingSphere);
            b.applyMatrix4(f.matrixWorld);
            if (!1 === m.ray.isIntersectionSphere(b)) {
              return r;
            }
            e.getInverse(f.matrixWorld);
            c.copy(m.ray).applyMatrix4(e);
            if (n instanceof a.Geometry) {
              for (y = n.vertices, x = y.length, v = new a.Vector3, u = new a.Vector3, w = f.type === a.LineStrip ? 1 : 2, n = 0;n < x - 1;n += w) {
                c.distanceSqToSegment(y[n], y[n + 1], u, v) > t || (s = c.origin.distanceTo(u), s < m.near || (s > m.far || r.push({distance:s, point:v.clone().applyMatrix4(f.matrixWorld), face:null, faceIndex:null, object:f})));
              }
            }
          }
        }
      }
    }
  }, m = function(a, b, c) {
    a = a.getDescendants();
    for (var d = 0, e = a.length;d < e;d++) {
      l(a[d], b, c);
    }
  };
  a.Raycaster.prototype.precision = 1E-4;
  a.Raycaster.prototype.linePrecision = 1;
  a.Raycaster.prototype.set = function(a, b) {
    this.ray.set(a, b);
  };
  a.Raycaster.prototype.intersectObject = function(a, b) {
    var c = [];
    !0 === b && m(a, this, c);
    l(a, this, c);
    c.sort(f);
    return c;
  };
  a.Raycaster.prototype.intersectObjects = function(a, b) {
    for (var c = [], d = 0, e = a.length;d < e;d++) {
      l(a[d], this, c), !0 === b && m(a[d], this, c);
    }
    c.sort(f);
    return c;
  };
})(THREE);
THREE.Object3D = function(a) {
  this.id = THREE.Object3DIdCount++;
  this.parent = void 0;
  a ? (this.matrixAutoUpdate = !1, this.skipModTerms = !0) : (this.up = new THREE.Vector3(0, 1, 0), this.position = new THREE.Vector3, this._rotation = new THREE.Euler, this._quaternion = new THREE.Quaternion, this.scale = new THREE.Vector3(1, 1, 1), this._rotation._quaternion = this.quaternion, this._quaternion._euler = this.rotation, this.matrixAutoUpdate = !0, this.matrix = new THREE.Matrix4, this.skipModTerms = !1, this.rotationAutoUpdate = !0);
  this.renderDepth = null;
  this.matrixWorld = new THREE.Matrix4;
  this.visible = this.matrixWorldNeedsUpdate = !0;
  this.receiveShadow = this.castShadow = !1;
  this.frustumCulled = !0;
};
THREE.Object3D.prototype = {constructor:THREE.Object3D, get rotation() {
  return this._rotation;
}, set rotation(a) {
  this._rotation = a;
  this._rotation._quaternion = this._quaternion;
  this._quaternion._euler = this._rotation;
  this._rotation._updateQuaternion();
}, get quaternion() {
  return this._quaternion;
}, set quaternion(a) {
  this._quaternion = a;
  this._quaternion._euler = this._rotation;
  this._rotation._quaternion = this._quaternion;
  this._quaternion._updateEuler();
}, get eulerOrder() {
  console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
  return this.rotation.order;
}, set eulerOrder(a) {
  console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
  this.rotation.order = a;
}, get useQuaternion() {
  console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
}, set useQuaternion(a) {
  console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.");
}, applyMatrix:function(a) {
  this.matrix.multiplyMatrices(a, this.matrix);
  this.matrix.decompose(this.position, this.quaternion, this.scale);
}, setRotationFromAxisAngle:function(a, b) {
  this.quaternion.setFromAxisAngle(a, b);
}, setRotationFromEuler:function(a) {
  this.quaternion.setFromEuler(a, !0);
}, setRotationFromMatrix:function(a) {
  this.quaternion.setFromRotationMatrix(a);
}, setRotationFromQuaternion:function(a) {
  this.quaternion.copy(a);
}, rotateOnAxis:function() {
  var a = new THREE.Quaternion;
  return function(b, c) {
    a.setFromAxisAngle(b, c);
    this.quaternion.multiply(a);
    return this;
  };
}(), rotateX:function() {
  var a = new THREE.Vector3(1, 0, 0);
  return function(b) {
    return this.rotateOnAxis(a, b);
  };
}(), rotateY:function() {
  var a = new THREE.Vector3(0, 1, 0);
  return function(b) {
    return this.rotateOnAxis(a, b);
  };
}(), rotateZ:function() {
  var a = new THREE.Vector3(0, 0, 1);
  return function(b) {
    return this.rotateOnAxis(a, b);
  };
}(), translateOnAxis:function() {
  var a = new THREE.Vector3;
  return function(b, c) {
    a.copy(b);
    a.applyQuaternion(this.quaternion);
    this.position.add(a.multiplyScalar(c));
    return this;
  };
}(), translate:function(a, b) {
  console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");
  return this.translateOnAxis(b, a);
}, translateX:function() {
  var a = new THREE.Vector3(1, 0, 0);
  return function(b) {
    return this.translateOnAxis(a, b);
  };
}(), translateY:function() {
  var a = new THREE.Vector3(0, 1, 0);
  return function(b) {
    return this.translateOnAxis(a, b);
  };
}(), translateZ:function() {
  var a = new THREE.Vector3(0, 0, 1);
  return function(b) {
    return this.translateOnAxis(a, b);
  };
}(), localToWorld:function(a) {
  return a.applyMatrix4(this.matrixWorld);
}, worldToLocal:function() {
  var a = new THREE.Matrix4;
  return function(b) {
    return b.applyMatrix4(a.getInverse(this.matrixWorld));
  };
}(), lookAt:function() {
  var a = new THREE.Matrix4;
  return function(b) {
    a.lookAt(b, this.position, this.up);
    this.quaternion.setFromRotationMatrix(a);
  };
}(), add:function(a) {
  if (a === this) {
    console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
  } else {
    if (a instanceof THREE.Object3D) {
      void 0 !== a.parent && a.parent.remove(a);
      a.parent = this;
      a.dispatchEvent({type:"added"});
      this.children || (this.children = []);
      this.children.push(a);
      for (var b = this;void 0 !== b.parent;) {
        b = b.parent;
      }
      void 0 !== b && (b instanceof THREE.Scene && b.__addObject(a));
    }
  }
}, remove:function(a) {
  if (this.children) {
    var b = this.children.indexOf(a);
    if (-1 !== b) {
      a.parent = void 0;
      a.dispatchEvent({type:"removed"});
      this.children.splice(b, 1);
      for (b = this;void 0 !== b.parent;) {
        b = b.parent;
      }
      void 0 !== b && (b instanceof THREE.Scene && b.__removeObject(a));
    }
  }
}, traverse:function(a) {
  a(this);
  var b = this.children;
  if (b) {
    for (var c = 0, d = b.length;c < d;c++) {
      b[c].traverse(a);
    }
  }
}, getObjectById:function(a, b) {
  for (var c = 0, d = this.children.length;c < d;c++) {
    var e = this.children[c];
    if (e.id === a || !0 === b && (e = e.getObjectById(a, b), void 0 !== e)) {
      return e;
    }
  }
}, getObjectByName:function(a, b) {
  for (var c = 0, d = this.children.length;c < d;c++) {
    var e = this.children[c];
    if (e.name === a || !0 === b && (e = e.getObjectByName(a, b), void 0 !== e)) {
      return e;
    }
  }
}, getChildByName:function(a, b) {
  console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(a, b);
}, getDescendants:function(a) {
  if (!this.children) {
    return null;
  }
  void 0 === a && (a = []);
  Array.prototype.push.apply(a, this.children);
  for (var b = 0, c = this.children.length;b < c;b++) {
    this.children[b].getDescendants(a);
  }
  return a;
}, updateMatrix:function() {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
}, updateMatrixWorld:function(a) {
  !0 === this.matrixAutoUpdate && this.updateMatrix();
  if (!0 === this.matrixWorldNeedsUpdate || !0 === a) {
    void 0 === this.parent && this.matrix ? this.matrixWorld.copy(this.matrix) : this.matrix && this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
  }
  if (this.children) {
    for (var b = 0, c = this.children.length;b < c;b++) {
      this.children[b].updateMatrixWorld(a);
    }
  }
}, clone:function(a, b) {
  void 0 === a && (a = new THREE.Object3D(this.skipModTerms));
  void 0 === b && (b = !0);
  this.name && (a.name = this.name);
  this.skipModTerms || (a.up.copy(this.up), a.position.copy(this.position), a.quaternion.copy(this.quaternion), a.scale.copy(this.scale));
  a.renderDepth = this.renderDepth;
  a.rotationAutoUpdate = this.rotationAutoUpdate;
  this.matrix ? a.matrix.copy(this.matrix) : a.matrix = null;
  a.matrixWorld.copy(this.matrixWorld);
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
  a.visible = this.visible;
  a.castShadow = this.castShadow;
  a.receiveShadow = this.receiveShadow;
  a.frustumCulled = this.frustumCulled;
  this.userData && (a.userData = JSON.parse(JSON.stringify(this.userData)));
  if (!0 === b && this.children) {
    for (var c = 0;c < this.children.length;c++) {
      a.add(this.children[c].clone());
    }
  }
  return a;
}};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function() {
  function a() {
    if (m === p) {
      var a = new THREE.RenderableVertex;
      q.push(a);
      p++;
      m++;
      return a;
    }
    return q[m++];
  }
  function b() {
    if (s === t) {
      var a = new THREE.RenderableFace;
      n.push(a);
      t++;
      s++;
      return a;
    }
    return n[s++];
  }
  function c() {
    if (u === x) {
      var a = new THREE.RenderableLine;
      w.push(a);
      x++;
      u++;
      return a;
    }
    return w[u++];
  }
  function d(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0;
  }
  function e(a, b) {
    var c = 0, d = 1, e = a.z + a.w, f = b.z + b.w, g = -a.z + a.w, h = -b.z + b.w;
    if (0 <= e && (0 <= f && (0 <= g && 0 <= h))) {
      return!0;
    }
    if (0 > e && 0 > f || 0 > g && 0 > h) {
      return!1;
    }
    0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));
    0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h)));
    if (d < c) {
      return!1;
    }
    a.lerp(b, c);
    b.lerp(a, 1 - d);
    return!0;
  }
  var f, g, h = [], k = 0, l, m, q = [], p = 0, r, s, n = [], t = 0, v, u, w = [], x = 0, y, G, z = [], B = 0, C = {objects:[], lights:[], elements:[]}, E = new THREE.Vector3, H = new THREE.Vector3, N = new THREE.Vector3, D = new THREE.Vector3, K = new THREE.Vector4, M = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), I = new THREE.Box3, F = Array(3), J = new THREE.Matrix4, Q = new THREE.Matrix4, L, T = new THREE.Matrix4, P = new THREE.Matrix3, U = new THREE.Frustum, A = 
  new THREE.Vector4, S = new THREE.Vector4;
  this.projectVector = function(a, b) {
    b.matrixWorldInverse.getInverse(b.matrixWorld);
    Q.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
    return a.applyProjection(Q);
  };
  this.unprojectVector = function() {
    var a = new THREE.Matrix4;
    return function(b, c) {
      a.getInverse(c.projectionMatrix);
      Q.multiplyMatrices(c.matrixWorld, a);
      return b.applyProjection(Q);
    };
  }();
  this.pickingRay = function(a, b) {
    a.z = -1;
    var c = new THREE.Vector3(a.x, a.y, 1);
    this.unprojectVector(a, b);
    this.unprojectVector(c, b);
    c.sub(a).normalize();
    return new THREE.Raycaster(a, c);
  };
  var V = function(a) {
    if (!1 !== a.visible) {
      if (a instanceof THREE.Light) {
        C.lights.push(a);
      } else {
        if (a instanceof THREE.Mesh || (a instanceof THREE.Line || a instanceof THREE.Sprite)) {
          if (!1 === a.frustumCulled || !0 === U.intersectsObject(a)) {
            if (g === k) {
              var b = new THREE.RenderableObject;
              h.push(b);
              k++;
              g++;
              f = b;
            } else {
              f = h[g++];
            }
            f.id = a.id;
            f.object = a;
            null !== a.renderDepth ? f.z = a.renderDepth : (D.setFromMatrixPosition(a.matrixWorld), D.applyProjection(Q), f.z = D.z);
            C.objects.push(f);
          }
        }
      }
      for (var b = 0, c = a.children.length;b < c;b++) {
        V(a.children[b]);
      }
    }
  }, R = new function() {
    var d = [], e = null, f = new THREE.Matrix3, g = function(a) {
      var b = a.positionWorld, c = a.positionScreen;
      b.copy(a.position).applyMatrix4(L);
      c.copy(b).applyMatrix4(Q);
      b = 1 / c.w;
      c.x *= b;
      c.y *= b;
      c.z *= b;
      a.visible = -1 <= c.x && (1 >= c.x && (-1 <= c.y && (1 >= c.y && (-1 <= c.z && 1 >= c.z))));
    }, h = function(a, b, c) {
      F[0] = a.positionScreen;
      F[1] = b.positionScreen;
      F[2] = c.positionScreen;
      return!0 === a.visible || (!0 === b.visible || (!0 === c.visible || M.isIntersectionBox(I.setFromPoints(F)))) ? 0 > (c.positionScreen.x - a.positionScreen.x) * (b.positionScreen.y - a.positionScreen.y) - (c.positionScreen.y - a.positionScreen.y) * (b.positionScreen.x - a.positionScreen.x) : !1;
    };
    return{setObject:function(a) {
      e = a;
      f.getNormalMatrix(e.matrixWorld);
      d.length = 0;
    }, projectVertex:g, checkTriangleVisibility:h, pushVertex:function(b, c, d) {
      l = a();
      l.position.set(b, c, d);
      g(l);
    }, pushNormal:function(a, b, c) {
      d.push(a, b, c);
    }, pushLine:function(a, b) {
      var d = q[a], f = q[b];
      v = c();
      v.id = e.id;
      v.v1.copy(d);
      v.v2.copy(f);
      v.z = (d.positionScreen.z + f.positionScreen.z) / 2;
      v.material = e.material;
      C.elements.push(v);
    }, pushTriangle:function(a, c, g) {
      var k = q[a], l = q[c], m = q[g];
      if (!0 === h(k, l, m)) {
        r = b();
        r.id = e.id;
        r.v1.copy(k);
        r.v2.copy(l);
        r.v3.copy(m);
        r.z = (k.positionScreen.z + l.positionScreen.z + m.positionScreen.z) / 3;
        for (k = 0;3 > k;k++) {
          l = 3 * arguments[k], m = r.vertexNormalsModel[k], m.set(d[l + 0], d[l + 1], d[l + 2]), m.applyMatrix3(f).normalize();
        }
        r.vertexNormalsLength = 3;
        r.material = e.material;
        C.elements.push(r);
      }
    }};
  };
  this.projectScene = function(f, h, k, l) {
    var n, p, t, w, x, O, D, F, M;
    G = u = s = 0;
    C.elements.length = 0;
    !0 === f.autoUpdate && f.updateMatrixWorld();
    void 0 === h.parent && h.updateMatrixWorld();
    J.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
    Q.multiplyMatrices(h.projectionMatrix, J);
    U.setFromMatrix(Q);
    g = 0;
    C.objects.length = 0;
    C.lights.length = 0;
    V(f);
    !0 === k && C.objects.sort(d);
    f = 0;
    for (k = C.objects.length;f < k;f++) {
      if (n = C.objects[f].object, p = n.geometry, R.setObject(n), L = n.matrixWorld, m = 0, n instanceof THREE.Mesh) {
        if (p instanceof THREE.BufferGeometry) {
          if (O = p.attributes, n = p.offsets, void 0 !== O.position) {
            F = O.position.array;
            p = 0;
            for (w = F.length;p < w;p += 3) {
              R.pushVertex(F[p], F[p + 1], F[p + 2]);
            }
            M = O.normal.array;
            p = 0;
            for (w = M.length;p < w;p += 3) {
              R.pushNormal(M[p], M[p + 1], M[p + 2]);
            }
            if (void 0 !== O.index) {
              if (O = O.index.array, 0 < n.length) {
                for (f = 0;f < n.length;f++) {
                  for (w = n[f], F = w.index, p = w.start, w = w.start + w.count;p < w;p += 3) {
                    R.pushTriangle(O[p] + F, O[p + 1] + F, O[p + 2] + F);
                  }
                }
              } else {
                for (p = 0, w = O.length;p < w;p += 3) {
                  R.pushTriangle(O[p], O[p + 1], O[p + 2]);
                }
              }
            } else {
              for (p = 0, w = F.length / 3;p < w;p += 3) {
                R.pushTriangle(p, p + 1, p + 2);
              }
            }
          }
        } else {
          if (p instanceof THREE.Geometry) {
            t = p.vertices;
            w = p.faces;
            O = p.faceVertexUvs;
            P.getNormalMatrix(L);
            F = n.material instanceof THREE.MeshFaceMaterial;
            M = !0 === F ? n.material : null;
            for (var I = 0, ia = t.length;I < ia;I++) {
              var W = t[I];
              R.pushVertex(W.x, W.y, W.z);
            }
            I = 0;
            for (ia = w.length;I < ia;I++) {
              t = w[I];
              var ka = !0 === F ? M.materials[t.materialIndex] : n.material;
              if (void 0 !== ka) {
                D = ka.side;
                var W = q[t.a], aa = q[t.b], ga = q[t.c];
                if (!0 === ka.morphTargets) {
                  x = p.morphTargets;
                  var ba = n.morphTargetInfluences, X = W.position, da = aa.position, ea = ga.position;
                  E.set(0, 0, 0);
                  H.set(0, 0, 0);
                  N.set(0, 0, 0);
                  for (var la = 0, qa = x.length;la < qa;la++) {
                    var Y = ba[la];
                    if (0 !== Y) {
                      var Z = x[la].vertices;
                      E.x += (Z[t.a].x - X.x) * Y;
                      E.y += (Z[t.a].y - X.y) * Y;
                      E.z += (Z[t.a].z - X.z) * Y;
                      H.x += (Z[t.b].x - da.x) * Y;
                      H.y += (Z[t.b].y - da.y) * Y;
                      H.z += (Z[t.b].z - da.z) * Y;
                      N.x += (Z[t.c].x - ea.x) * Y;
                      N.y += (Z[t.c].y - ea.y) * Y;
                      N.z += (Z[t.c].z - ea.z) * Y;
                    }
                  }
                  W.position.add(E);
                  aa.position.add(H);
                  ga.position.add(N);
                  R.projectVertex(W);
                  R.projectVertex(aa);
                  R.projectVertex(ga);
                }
                ba = R.checkTriangleVisibility(W, aa, ga);
                if (!(!1 === ba && D === THREE.FrontSide || !0 === ba && D === THREE.BackSide)) {
                  r = b();
                  r.id = n.id;
                  r.v1.copy(W);
                  r.v2.copy(aa);
                  r.v3.copy(ga);
                  r.normalModel.copy(t.normal);
                  !1 !== ba || (D !== THREE.BackSide && D !== THREE.DoubleSide || r.normalModel.negate());
                  r.normalModel.applyMatrix3(P).normalize();
                  r.centroidModel.copy(t.centroid).applyMatrix4(L);
                  x = t.vertexNormals;
                  X = 0;
                  for (da = Math.min(x.length, 3);X < da;X++) {
                    ea = r.vertexNormalsModel[X], ea.copy(x[X]), !1 !== ba || (D !== THREE.BackSide && D !== THREE.DoubleSide || ea.negate()), ea.applyMatrix3(P).normalize();
                  }
                  r.vertexNormalsLength = x.length;
                  x = 0;
                  for (ba = Math.min(O.length, 3);x < ba;x++) {
                    if (D = O[x][I], void 0 !== D) {
                      for (X = 0, da = D.length;X < da;X++) {
                        r.uvs[x][X] = D[X];
                      }
                    }
                  }
                  r.color = t.color;
                  r.material = ka;
                  r.z = (W.positionScreen.z + aa.positionScreen.z + ga.positionScreen.z) / 3;
                  C.elements.push(r);
                }
              }
            }
          }
        }
      } else {
        if (n instanceof THREE.Line) {
          if (p instanceof THREE.BufferGeometry) {
            if (O = p.attributes, void 0 !== O.position) {
              F = O.position.array;
              p = 0;
              for (w = F.length;p < w;p += 3) {
                R.pushVertex(F[p], F[p + 1], F[p + 2]);
              }
              if (void 0 !== O.index) {
                for (O = O.index.array, p = 0, w = O.length;p < w;p += 2) {
                  R.pushLine(O[p], O[p + 1]);
                }
              } else {
                for (p = 0, w = F.length / 3 - 1;p < w;p++) {
                  R.pushLine(p, p + 1);
                }
              }
            }
          } else {
            if (p instanceof THREE.Geometry && (T.multiplyMatrices(Q, L), t = n.geometry.vertices, 0 !== t.length)) {
              for (W = a(), W.positionScreen.copy(t[0]).applyMatrix4(T), p = n.type === THREE.LinePieces ? 2 : 1, I = 1, ia = t.length;I < ia;I++) {
                W = a(), W.positionScreen.copy(t[I]).applyMatrix4(T), 0 < (I + 1) % p || (aa = q[m - 2], A.copy(W.positionScreen), S.copy(aa.positionScreen), !0 === e(A, S) && (A.multiplyScalar(1 / A.w), S.multiplyScalar(1 / S.w), v = c(), v.id = n.id, v.v1.positionScreen.copy(A), v.v2.positionScreen.copy(S), v.z = Math.max(A.z, S.z), v.material = n.material, n.material.vertexColors === THREE.VertexColors && (v.vertexColors[0].copy(n.geometry.colors[I]), v.vertexColors[1].copy(n.geometry.colors[I - 
                1])), C.elements.push(v)));
              }
            }
          }
        } else {
          n instanceof THREE.Sprite && (K.set(L.elements[12], L.elements[13], L.elements[14], 1), K.applyMatrix4(Q), p = 1 / K.w, K.z *= p, -1 <= K.z && (1 >= K.z && (G === B ? (w = new THREE.RenderableSprite, z.push(w), B++, G++, y = w) : y = z[G++], y.id = n.id, y.x = K.x * p, y.y = K.y * p, y.z = K.z, y.object = n, y.rotation = n.rotation, y.scale.x = n.scale.x * Math.abs(y.x - (K.x + h.projectionMatrix.elements[0]) / (K.w + h.projectionMatrix.elements[12])), y.scale.y = n.scale.y * Math.abs(y.y - 
          (K.y + h.projectionMatrix.elements[5]) / (K.w + h.projectionMatrix.elements[13])), y.material = n.material, C.elements.push(y))));
        }
      }
    }
    !0 === l && C.elements.sort(d);
    return C;
  };
};
THREE.Face3 = function(a, b, c, d, e, f) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3;
  this.vertexNormals = d instanceof Array ? d : [];
  this.color = e instanceof THREE.Color ? e : new THREE.Color;
  this.vertexColors = e instanceof Array ? e : [];
  this.vertexTangents = [];
  this.materialIndex = void 0 !== f ? f : 0;
  this.centroid = new THREE.Vector3;
};
THREE.Face3.prototype = {constructor:THREE.Face3, clone:function() {
  var a = new THREE.Face3(this.a, this.b, this.c);
  a.normal.copy(this.normal);
  a.color.copy(this.color);
  a.centroid.copy(this.centroid);
  a.materialIndex = this.materialIndex;
  var b, c;
  b = 0;
  for (c = this.vertexNormals.length;b < c;b++) {
    a.vertexNormals[b] = this.vertexNormals[b].clone();
  }
  b = 0;
  for (c = this.vertexColors.length;b < c;b++) {
    a.vertexColors[b] = this.vertexColors[b].clone();
  }
  b = 0;
  for (c = this.vertexTangents.length;b < c;b++) {
    a.vertexTangents[b] = this.vertexTangents[b].clone();
  }
  return a;
}};
THREE.Face4 = function(a, b, c, d, e, f, g) {
  console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
  return new THREE.Face3(a, b, c, e, f, g);
};
THREE.BufferGeometry = function() {
  this.id = THREE.GeometryIdCount++;
  this.attributes = {};
  this.boundingSphere = this.boundingBox = null;
};
THREE.BufferGeometry.prototype = {constructor:THREE.BufferGeometry, addAttribute:function(a, b, c, d) {
  this.attributes[a] = {array:new b(c * d), itemSize:d};
  return this.attributes[a];
}, applyMatrix:function(a) {
  var b = this.attributes.position;
  void 0 !== b && (a.multiplyVector3Array(b.array), b.needsUpdate = !0);
  b = this.attributes.normal;
  void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(b.array), b.needsUpdate = !0);
}, computeBoundingBox:function() {
  null === this.boundingBox && (this.boundingBox = new THREE.Box3);
  var a = this.attributes.position.array;
  if (a) {
    var b = this.boundingBox;
    3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
    for (var c = 3, d = a.length;c < d;c += 3) {
      var e = a[c], f = a[c + 1], g = a[c + 2];
      e < b.min.x ? b.min.x = e : e > b.max.x && (b.max.x = e);
      f < b.min.y ? b.min.y = f : f > b.max.y && (b.max.y = f);
      g < b.min.z ? b.min.z = g : g > b.max.z && (b.max.z = g);
    }
  }
  if (void 0 === a || 0 === a.length) {
    this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
  }
}, computeBoundingSphere:function() {
  var a = new THREE.Box3, b = new THREE.Vector3;
  return function() {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
    var c = this.attributes.position.array;
    if (c) {
      a.makeEmpty();
      for (var d = this.boundingSphere.center, e = 0, f = c.length;e < f;e += 3) {
        b.set(c[e], c[e + 1], c[e + 2]), a.addPoint(b);
      }
      a.center(d);
      for (var g = 0, e = 0, f = c.length;e < f;e += 3) {
        b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
      }
      this.boundingSphere.radius = Math.sqrt(g);
    }
  };
}(), computeVertexNormals:function() {
  if (this.attributes.position) {
    var a, b, c, d;
    a = this.attributes.position.array.length;
    if (void 0 === this.attributes.normal) {
      this.attributes.normal = {itemSize:3, array:new Float32Array(a)};
    } else {
      for (a = 0, b = this.attributes.normal.array.length;a < b;a++) {
        this.attributes.normal.array[a] = 0;
      }
    }
    var e = this.attributes.position.array, f = this.attributes.normal.array, g, h, k, l, m, q, p = new THREE.Vector3, r = new THREE.Vector3, s = new THREE.Vector3, n = new THREE.Vector3, t = new THREE.Vector3;
    if (this.attributes.index) {
      var v = this.attributes.index.array, u = this.offsets;
      c = 0;
      for (d = u.length;c < d;++c) {
        b = u[c].start;
        g = u[c].count;
        var w = u[c].index;
        a = b;
        for (b += g;a < b;a += 3) {
          g = w + v[a], h = w + v[a + 1], k = w + v[a + 2], l = e[3 * g], m = e[3 * g + 1], q = e[3 * g + 2], p.set(l, m, q), l = e[3 * h], m = e[3 * h + 1], q = e[3 * h + 2], r.set(l, m, q), l = e[3 * k], m = e[3 * k + 1], q = e[3 * k + 2], s.set(l, m, q), n.subVectors(s, r), t.subVectors(p, r), n.cross(t), f[3 * g] += n.x, f[3 * g + 1] += n.y, f[3 * g + 2] += n.z, f[3 * h] += n.x, f[3 * h + 1] += n.y, f[3 * h + 2] += n.z, f[3 * k] += n.x, f[3 * k + 1] += n.y, f[3 * k + 2] += n.z;
        }
      }
    } else {
      for (a = 0, b = e.length;a < b;a += 9) {
        l = e[a], m = e[a + 1], q = e[a + 2], p.set(l, m, q), l = e[a + 3], m = e[a + 4], q = e[a + 5], r.set(l, m, q), l = e[a + 6], m = e[a + 7], q = e[a + 8], s.set(l, m, q), n.subVectors(s, r), t.subVectors(p, r), n.cross(t), f[a] = n.x, f[a + 1] = n.y, f[a + 2] = n.z, f[a + 3] = n.x, f[a + 4] = n.y, f[a + 5] = n.z, f[a + 6] = n.x, f[a + 7] = n.y, f[a + 8] = n.z;
      }
    }
    this.normalizeNormals();
    this.normalsNeedUpdate = !0;
  }
}, normalizeNormals:function() {
  for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length;e < f;e += 3) {
    b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;
  }
}, computeTangents:function() {
  function a(a, b, c) {
    q = d[3 * a];
    p = d[3 * a + 1];
    r = d[3 * a + 2];
    s = d[3 * b];
    n = d[3 * b + 1];
    t = d[3 * b + 2];
    v = d[3 * c];
    u = d[3 * c + 1];
    w = d[3 * c + 2];
    x = f[2 * a];
    y = f[2 * a + 1];
    G = f[2 * b];
    z = f[2 * b + 1];
    B = f[2 * c];
    C = f[2 * c + 1];
    E = s - q;
    H = v - q;
    N = n - p;
    D = u - p;
    K = t - r;
    M = w - r;
    I = G - x;
    F = B - x;
    J = z - y;
    Q = C - y;
    L = 1 / (I * Q - F * J);
    T.set((Q * E - J * H) * L, (Q * N - J * D) * L, (Q * K - J * M) * L);
    P.set((I * H - F * E) * L, (I * D - F * N) * L, (I * M - F * K) * L);
    k[a].add(T);
    k[b].add(T);
    k[c].add(T);
    l[a].add(P);
    l[b].add(P);
    l[c].add(P);
  }
  function b(a) {
    fa.x = e[3 * a];
    fa.y = e[3 * a + 1];
    fa.z = e[3 * a + 2];
    na.copy(fa);
    ja = k[a];
    ha.copy(ja);
    ha.sub(fa.multiplyScalar(fa.dot(ja))).normalize();
    ma.crossVectors(na, ja);
    pa = ma.dot(l[a]);
    oa = 0 > pa ? -1 : 1;
    h[4 * a] = ha.x;
    h[4 * a + 1] = ha.y;
    h[4 * a + 2] = ha.z;
    h[4 * a + 3] = oa;
  }
  if (void 0 === this.attributes.index || (void 0 === this.attributes.position || (void 0 === this.attributes.normal || void 0 === this.attributes.uv))) {
    console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
  } else {
    var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
    void 0 === this.attributes.tangent && (this.attributes.tangent = {itemSize:4, array:new Float32Array(4 * g)});
    for (var h = this.attributes.tangent.array, k = [], l = [], m = 0;m < g;m++) {
      k[m] = new THREE.Vector3, l[m] = new THREE.Vector3;
    }
    var q, p, r, s, n, t, v, u, w, x, y, G, z, B, C, E, H, N, D, K, M, I, F, J, Q, L, T = new THREE.Vector3, P = new THREE.Vector3, U, A, S, V, R, $ = this.offsets, m = 0;
    for (A = $.length;m < A;++m) {
      U = $[m].start;
      S = $[m].count;
      var ca = $[m].index, g = U;
      for (U += S;g < U;g += 3) {
        S = ca + c[g], V = ca + c[g + 1], R = ca + c[g + 2], a(S, V, R);
      }
    }
    var ha = new THREE.Vector3, ma = new THREE.Vector3, fa = new THREE.Vector3, na = new THREE.Vector3, oa, ja, pa, m = 0;
    for (A = $.length;m < A;++m) {
      for (U = $[m].start, S = $[m].count, ca = $[m].index, g = U, U += S;g < U;g += 3) {
        S = ca + c[g], V = ca + c[g + 1], R = ca + c[g + 2], b(S), b(V), b(R);
      }
    }
  }
}, computeOffsets:function(a) {
  var b = a;
  void 0 === a && (b = 65535);
  Date.now();
  a = this.attributes.index.array;
  for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [{start:0, count:0, index:0}], k = h[0], l = 0, m = 0, q = new Int32Array(6), p = new Int32Array(c.length), r = new Int32Array(c.length), s = 0;s < c.length;s++) {
    p[s] = -1, r[s] = -1;
  }
  for (c = 0;c < d;c++) {
    for (var n = m = 0;3 > n;n++) {
      s = a[3 * c + n], -1 == p[s] ? (q[2 * n] = s, q[2 * n + 1] = -1, m++) : p[s] < k.index ? (q[2 * n] = s, q[2 * n + 1] = -1, l++) : (q[2 * n] = s, q[2 * n + 1] = p[s]);
    }
    if (g + m > k.index + b) {
      for (k = {start:f, count:0, index:g}, h.push(k), m = 0;6 > m;m += 2) {
        n = q[m + 1], -1 < n && (n < k.index && (q[m + 1] = -1));
      }
    }
    for (m = 0;6 > m;m += 2) {
      s = q[m], n = q[m + 1], -1 === n && (n = g++), p[s] = n, r[n] = s, e[f++] = n - k.index, k.count++;
    }
  }
  this.reorderBuffers(e, r, g);
  return this.offsets = h;
}, reorderBuffers:function(a, b, c) {
  var d = {}, e = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], f;
  for (f in this.attributes) {
    if ("index" != f) {
      for (var g = this.attributes[f].array, h = 0, k = e.length;h < k;h++) {
        var l = e[h];
        if (g instanceof l) {
          d[f] = new l(this.attributes[f].itemSize * c);
          break;
        }
      }
    }
  }
  for (e = 0;e < c;e++) {
    for (f in g = b[e], this.attributes) {
      if ("index" != f) {
        for (var h = this.attributes[f].array, k = this.attributes[f].itemSize, l = d[f], m = 0;m < k;m++) {
          l[e * k + m] = h[g * k + m];
        }
      }
    }
  }
  this.attributes.index.array = a;
  for (f in this.attributes) {
    "index" != f && (this.attributes[f].array = d[f], this.attributes[f].numItems = this.attributes[f].itemSize * c);
  }
}, clone:function() {
  var a = new THREE.BufferGeometry, b = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], c;
  for (c in this.attributes) {
    for (var d = this.attributes[c], e = d.array, f = {itemSize:d.itemSize, array:null}, d = 0, g = b.length;d < g;d++) {
      var h = b[d];
      if (e instanceof h) {
        f.array = new h(e);
        break;
      }
    }
    a.attributes[c] = f;
  }
  d = 0;
  for (g = this.offsets.length;d < g;d++) {
    b = this.offsets[d], a.offsets.push({start:b.start, index:b.index, count:b.count});
  }
  return a;
}, dispose:function() {
  this.dispatchEvent({type:"dispose"});
}};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function() {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingSphere = this.boundingBox = null;
  this.hasTangents = !1;
  this.dynamic = !0;
  this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
};
THREE.Geometry.prototype = {constructor:THREE.Geometry, applyMatrix:function(a) {
  for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length;c < d;c++) {
    this.vertices[c].applyMatrix4(a);
  }
  c = 0;
  for (d = this.faces.length;c < d;c++) {
    var e = this.faces[c];
    e.normal.applyMatrix3(b).normalize();
    for (var f = 0, g = e.vertexNormals.length;f < g;f++) {
      e.vertexNormals[f].applyMatrix3(b).normalize();
    }
    e.centroid.applyMatrix4(a);
  }
  this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
  this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
}, computeCentroids:function() {
  var a, b, c;
  a = 0;
  for (b = this.faces.length;a < b;a++) {
    c = this.faces[a], c.centroid.set(0, 0, 0), c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3);
  }
}, computeFaceNormals:function() {
  for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length;c < d;c++) {
    var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
    a.subVectors(this.vertices[e.c], g);
    b.subVectors(f, g);
    a.cross(b);
    a.normalize();
    e.normal.copy(a);
  }
}, computeVertexNormals:function(a) {
  var b, c, d;
  d = Array(this.vertices.length);
  b = 0;
  for (c = this.vertices.length;b < c;b++) {
    d[b] = new THREE.Vector3;
  }
  if (a) {
    var e, f, g, h = new THREE.Vector3, k = new THREE.Vector3;
    new THREE.Vector3;
    new THREE.Vector3;
    new THREE.Vector3;
    a = 0;
    for (b = this.faces.length;a < b;a++) {
      c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
    }
  } else {
    for (a = 0, b = this.faces.length;a < b;a++) {
      c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
    }
  }
  b = 0;
  for (c = this.vertices.length;b < c;b++) {
    d[b].normalize();
  }
  a = 0;
  for (b = this.faces.length;a < b;a++) {
    c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
  }
}, computeMorphNormals:function() {
  var a, b, c, d, e;
  c = 0;
  for (d = this.faces.length;c < d;c++) {
    for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length;a < b;a++) {
      e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
    }
  }
  var f = new THREE.Geometry;
  f.faces = this.faces;
  a = 0;
  for (b = this.morphTargets.length;a < b;a++) {
    if (!this.morphNormals[a]) {
      this.morphNormals[a] = {};
      this.morphNormals[a].faceNormals = [];
      this.morphNormals[a].vertexNormals = [];
      e = this.morphNormals[a].faceNormals;
      var g = this.morphNormals[a].vertexNormals, h, k;
      c = 0;
      for (d = this.faces.length;c < d;c++) {
        h = new THREE.Vector3, k = {a:new THREE.Vector3, b:new THREE.Vector3, c:new THREE.Vector3}, e.push(h), g.push(k);
      }
    }
    g = this.morphNormals[a];
    f.vertices = this.morphTargets[a].vertices;
    f.computeFaceNormals();
    f.computeVertexNormals();
    c = 0;
    for (d = this.faces.length;c < d;c++) {
      e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]);
    }
  }
  c = 0;
  for (d = this.faces.length;c < d;c++) {
    e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
  }
}, computeTangents:function() {
  var a, b, c, d, e, f, g, h, k, l, m, q, p, r, s, n, t, v = [], u = [];
  c = new THREE.Vector3;
  var w = new THREE.Vector3, x = new THREE.Vector3, y = new THREE.Vector3, G = new THREE.Vector3;
  a = 0;
  for (b = this.vertices.length;a < b;a++) {
    v[a] = new THREE.Vector3, u[a] = new THREE.Vector3;
  }
  a = 0;
  for (b = this.faces.length;a < b;a++) {
    e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, t = e.b, e = e.c, g = this.vertices[d], h = this.vertices[t], k = this.vertices[e], l = f[0], m = f[1], q = f[2], f = h.x - g.x, p = k.x - g.x, r = h.y - g.y, s = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = m.x - l.x, n = q.x - l.x, m = m.y - l.y, l = q.y - l.y, q = 1 / (k * l - n * m), c.set((l * f - m * p) * q, (l * r - m * s) * q, (l * h - m * g) * q), w.set((k * p - n * f) * q, (k * s - n * r) * q, (k * g - n * h) * q), v[d].add(c), 
    v[t].add(c), v[e].add(c), u[d].add(w), u[t].add(w), u[e].add(w);
  }
  w = ["a", "b", "c", "d"];
  a = 0;
  for (b = this.faces.length;a < b;a++) {
    for (e = this.faces[a], c = 0;c < Math.min(e.vertexNormals.length, 3);c++) {
      G.copy(e.vertexNormals[c]), d = e[w[c]], t = v[d], x.copy(t), x.sub(G.multiplyScalar(G.dot(t))).normalize(), y.crossVectors(e.vertexNormals[c], t), d = y.dot(u[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(x.x, x.y, x.z, d);
    }
  }
  this.hasTangents = !0;
}, computeLineDistances:function() {
  for (var a = 0, b = this.vertices, c = 0, d = b.length;c < d;c++) {
    0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;
  }
}, computeBoundingBox:function() {
  null === this.boundingBox && (this.boundingBox = new THREE.Box3);
  this.boundingBox.setFromPoints(this.vertices);
}, computeBoundingSphere:function() {
  null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
  this.boundingSphere.setFromPoints(this.vertices);
}, mergeVertices:function() {
  var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
  f = 0;
  for (g = this.vertices.length;f < g;f++) {
    d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
  }
  a = [];
  f = 0;
  for (g = this.faces.length;f < g;f++) {
    for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0;3 > d;d++) {
      if (e[d] == e[(d + 1) % 3]) {
        a.push(f);
        break;
      }
    }
  }
  for (f = a.length - 1;0 <= f;f--) {
    for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length;c < g;c++) {
      this.faceVertexUvs[c].splice(e, 1);
    }
  }
  f = this.vertices.length - b.length;
  this.vertices = b;
  return f;
}, makeGroups:function() {
  var a = 0;
  return function(b) {
    var c, d, e, f, g = {}, h = this.morphTargets.length, k = this.morphNormals.length;
    this.geometryGroups = {};
    c = 0;
    for (d = this.faces.length;c < d;c++) {
      e = this.faces[c], e = b ? e.materialIndex : 0, e in g || (g[e] = {hash:e, counter:0}), f = g[e].hash + "_" + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {faces3:[], materialIndex:e, vertices:0, numMorphTargets:h, numMorphNormals:k}), 65535 < this.geometryGroups[f].vertices + 3 && (g[e].counter += 1, f = g[e].hash + "_" + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {faces3:[], materialIndex:e, vertices:0, numMorphTargets:h, numMorphNormals:k})), 
      this.geometryGroups[f].faces3.push(c), this.geometryGroups[f].vertices += 3;
    }
    this.geometryGroupsList = [];
    for (var l in this.geometryGroups) {
      this.geometryGroups[l].id = a++, this.geometryGroupsList.push(this.geometryGroups[l]);
    }
  };
}(), clone:function() {
  for (var a = new THREE.Geometry, b = this.vertices, c = 0, d = b.length;c < d;c++) {
    a.vertices.push(b[c].clone());
  }
  b = this.faces;
  c = 0;
  for (d = b.length;c < d;c++) {
    a.faces.push(b[c].clone());
  }
  b = this.faceVertexUvs[0];
  c = 0;
  for (d = b.length;c < d;c++) {
    for (var e = b[c], f = [], g = 0, h = e.length;g < h;g++) {
      f.push(new THREE.Vector2(e[g].x, e[g].y));
    }
    a.faceVertexUvs[0].push(f);
  }
  return a;
}, dispose:function() {
  this.dispatchEvent({type:"dispose"});
}};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Geometry2 = function(a) {
  THREE.BufferGeometry.call(this);
  this.vertices = this.addAttribute("position", Float32Array, a, 3).array;
  this.normals = this.addAttribute("normal", Float32Array, a, 3).array;
  this.uvs = this.addAttribute("uv", Float32Array, a, 2).array;
  this.boundingSphere = this.boundingBox = null;
};
THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.Camera = function() {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4;
  this.projectionMatrix = new THREE.Matrix4;
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function() {
  var a = new THREE.Matrix4;
  return function(b) {
    a.lookAt(this.position, b, this.up);
    this.quaternion.setFromRotationMatrix(a);
  };
}();
THREE.Camera.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Camera);
  THREE.Object3D.prototype.clone.call(this, a);
  a.matrixWorldInverse.copy(this.matrixWorldInverse);
  a.projectionMatrix.copy(this.projectionMatrix);
  return a;
};
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
  THREE.Camera.call(this);
  this.left = a;
  this.right = b;
  this.top = c;
  this.bottom = d;
  this.near = void 0 !== e ? e : 0.1;
  this.far = void 0 !== f ? f : 2E3;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function() {
  var a = new THREE.OrthographicCamera;
  THREE.Camera.prototype.clone.call(this, a);
  a.left = this.left;
  a.right = this.right;
  a.top = this.top;
  a.bottom = this.bottom;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.PerspectiveCamera = function(a, b, c, d) {
  THREE.Camera.call(this);
  this.fov = void 0 !== a ? a : 50;
  this.aspect = void 0 !== b ? b : 1;
  this.near = void 0 !== c ? c : 0.1;
  this.far = void 0 !== d ? d : 2E3;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
  void 0 === b && (b = 24);
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
  this.fullWidth = a;
  this.fullHeight = b;
  this.x = c;
  this.y = d;
  this.width = e;
  this.height = f;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
  if (this.fullWidth) {
    var a = this.fullWidth / this.fullHeight, b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near, c = -b, d = a * c, a = Math.abs(a * b - d), c = Math.abs(b - c);
    this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far);
  } else {
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
  }
};
THREE.PerspectiveCamera.prototype.clone = function() {
  var a = new THREE.PerspectiveCamera;
  THREE.Camera.prototype.clone.call(this, a);
  a.fov = this.fov;
  a.aspect = this.aspect;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.Light = function(a) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(a);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Light);
  THREE.Object3D.prototype.clone.call(this, a);
  a.color.copy(this.color);
  return a;
};
THREE.AmbientLight = function(a) {
  THREE.Light.call(this, a);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function() {
  var a = new THREE.AmbientLight;
  THREE.Light.prototype.clone.call(this, a);
  return a;
};
THREE.AreaLight = function(a, b) {
  THREE.Light.call(this, a);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = void 0 !== b ? b : 1;
  this.height = this.width = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function(a, b) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D;
  this.intensity = void 0 !== b ? b : 1;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5E3;
  this.shadowCameraLeft = -500;
  this.shadowCameraTop = this.shadowCameraRight = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowCascade = !1;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [0, 0, 0];
  this.shadowCascadeWidth = [512, 512, 512];
  this.shadowCascadeHeight = [512, 512, 512];
  this.shadowCascadeNearZ = [-1, 0.99, 0.998];
  this.shadowCascadeFarZ = [0.99, 0.998, 1];
  this.shadowCascadeArray = [];
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function() {
  var a = new THREE.DirectionalLight;
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.HemisphereLight = function(a, b, c) {
  THREE.Light.call(this, a);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(b);
  this.intensity = void 0 !== c ? c : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function() {
  var a = new THREE.HemisphereLight;
  THREE.Light.prototype.clone.call(this, a);
  a.groundColor.copy(this.groundColor);
  a.intensity = this.intensity;
  return a;
};
THREE.PointLight = function(a, b, c) {
  THREE.Light.call(this, a);
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function() {
  var a = new THREE.PointLight;
  THREE.Light.prototype.clone.call(this, a);
  a.intensity = this.intensity;
  a.distance = this.distance;
  return a;
};
THREE.SpotLight = function(a, b, c, d, e) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D;
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
  this.angle = void 0 !== d ? d : Math.PI / 3;
  this.exponent = void 0 !== e ? e : 10;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5E3;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function() {
  var a = new THREE.SpotLight;
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.distance = this.distance;
  a.angle = this.angle;
  a.exponent = this.exponent;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.Loader = function(a) {
  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
  this.onLoadStart = function() {
  };
  this.onLoadProgress = function() {
  };
  this.onLoadComplete = function() {
  };
};
THREE.Loader.prototype = {constructor:THREE.Loader, crossOrigin:void 0, addStatusElement:function() {
  var a = document.createElement("div");
  a.style.position = "absolute";
  a.style.right = "0px";
  a.style.top = "0px";
  a.style.fontSize = "0.8em";
  a.style.textAlign = "left";
  a.style.background = "rgba(0,0,0,0.25)";
  a.style.color = "#fff";
  a.style.width = "120px";
  a.style.padding = "0.5em 0.5em 0.5em 0.5em";
  a.style.zIndex = 1E3;
  a.innerHTML = "Loading ...";
  return a;
}, updateProgress:function(a) {
  var b = "Loaded ", b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + "%") : b + ((a.loaded / 1E3).toFixed(2) + " KB");
  this.statusDomElement.innerHTML = b;
}, extractUrlBase:function(a) {
  a = a.split("/");
  if (1 === a.length) {
    return "./";
  }
  a.pop();
  return a.join("/") + "/";
}, initMaterials:function(a, b) {
  for (var c = [], d = 0;d < a.length;++d) {
    c[d] = THREE.Loader.prototype.createMaterial(a[d], b);
  }
  return c;
}, needsTangents:function(a) {
  for (var b = 0, c = a.length;b < c;b++) {
    if (a[b] instanceof THREE.ShaderMaterial) {
      return!0;
    }
  }
  return!1;
}, createMaterial:function(a, b) {
  function c(a) {
    a = Math.log(a) / Math.LN2;
    return Math.floor(a) == a;
  }
  function d(a) {
    a = Math.log(a) / Math.LN2;
    return Math.pow(2, Math.round(a));
  }
  function e(a, b) {
    var e = new Image;
    e.onload = function() {
      if (c(this.width) && c(this.height)) {
        a.image = this;
      } else {
        var b = d(this.width), e = d(this.height);
        a.image.width = b;
        a.image.height = e;
        a.image.getContext("2d").drawImage(this, 0, 0, b, e);
      }
      a.needsUpdate = !0;
    };
    void 0 !== h.crossOrigin && (e.crossOrigin = h.crossOrigin);
    e.src = b;
  }
  function f(a, c, d, f, g, h, k) {
    var l = /\.dds$/i.test(d), m = b + d;
    if (l) {
      var x = THREE.ImageUtils.loadCompressedTexture(m);
      a[c] = x;
    } else {
      x = document.createElement("canvas"), a[c] = new THREE.Texture(x);
    }
    a[c].sourceFile = d;
    f && (a[c].repeat.set(f[0], f[1]), 1 !== f[0] && (a[c].wrapS = THREE.RepeatWrapping), 1 !== f[1] && (a[c].wrapT = THREE.RepeatWrapping));
    g && a[c].offset.set(g[0], g[1]);
    h && (d = {repeat:THREE.RepeatWrapping, mirror:THREE.MirroredRepeatWrapping}, void 0 !== d[h[0]] && (a[c].wrapS = d[h[0]]), void 0 !== d[h[1]] && (a[c].wrapT = d[h[1]]));
    k && (a[c].anisotropy = k);
    l || e(a[c], m);
  }
  function g(a) {
    return(255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
  }
  var h = this, k = "MeshLambertMaterial", l = {color:15658734, opacity:1, map:null, lightMap:null, normalMap:null, bumpMap:null, wireframe:!1};
  if (a.shading) {
    var m = a.shading.toLowerCase();
    "phong" === m ? k = "MeshPhongMaterial" : "basic" === m && (k = "MeshBasicMaterial");
  }
  void 0 !== a.blending && (void 0 !== THREE[a.blending] && (l.blending = THREE[a.blending]));
  if (void 0 !== a.transparent || 1 > a.opacity) {
    l.transparent = a.transparent;
  }
  void 0 !== a.depthTest && (l.depthTest = a.depthTest);
  void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
  void 0 !== a.visible && (l.visible = a.visible);
  void 0 !== a.flipSided && (l.side = THREE.BackSide);
  void 0 !== a.doubleSided && (l.side = THREE.DoubleSide);
  void 0 !== a.wireframe && (l.wireframe = a.wireframe);
  void 0 !== a.vertexColors && ("face" === a.vertexColors ? l.vertexColors = THREE.FaceColors : a.vertexColors && (l.vertexColors = THREE.VertexColors));
  a.colorDiffuse ? l.color = g(a.colorDiffuse) : a.DbgColor && (l.color = a.DbgColor);
  a.colorSpecular && (l.specular = g(a.colorSpecular));
  a.colorAmbient && (l.ambient = g(a.colorAmbient));
  a.transparency && (l.opacity = a.transparency);
  a.specularCoef && (l.shininess = a.specularCoef);
  a.mapDiffuse && (b && f(l, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy));
  a.mapLight && (b && f(l, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy));
  a.mapBump && (b && f(l, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy));
  a.mapNormal && (b && f(l, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy));
  a.mapSpecular && (b && f(l, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy));
  a.mapBumpScale && (l.bumpScale = a.mapBumpScale);
  a.mapNormal ? (k = THREE.ShaderLib.normalmap, m = THREE.UniformsUtils.clone(k.uniforms), m.tNormal.value = l.normalMap, a.mapNormalFactor && m.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), l.map && (m.tDiffuse.value = l.map, m.enableDiffuse.value = !0), l.specularMap && (m.tSpecular.value = l.specularMap, m.enableSpecular.value = !0), l.lightMap && (m.tAO.value = l.lightMap, m.enableAO.value = !0), m.diffuse.value.setHex(l.color), m.specular.value.setHex(l.specular), m.ambient.value.setHex(l.ambient), 
  m.shininess.value = l.shininess, void 0 !== l.opacity && (m.opacity.value = l.opacity), k = new THREE.ShaderMaterial({fragmentShader:k.fragmentShader, vertexShader:k.vertexShader, uniforms:m, lights:!0, fog:!0}), l.transparent && (k.transparent = !0)) : k = new THREE[k](l);
  void 0 !== a.DbgName && (k.name = a.DbgName);
  return k;
}};
THREE.XHRLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {constructor:THREE.XHRLoader, load:function(a, b, c, d) {
  var e = this, f = new XMLHttpRequest;
  void 0 !== b && f.addEventListener("load", function(c) {
    b(c.target.responseText);
    e.manager.itemEnd(a);
  }, !1);
  void 0 !== c && f.addEventListener("progress", function(a) {
    c(a);
  }, !1);
  void 0 !== d && f.addEventListener("error", function(a) {
    d(a);
  }, !1);
  void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
  f.open("GET", a, !0);
  f.send(null);
  e.manager.itemStart(a);
}, setCrossOrigin:function(a) {
  this.crossOrigin = a;
}};
THREE.ImageLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {constructor:THREE.ImageLoader, load:function(a, b, c, d) {
  var e = this, f = document.createElement("img");
  void 0 !== b && f.addEventListener("load", function(c) {
    e.manager.itemEnd(a);
    b(this);
  }, !1);
  void 0 !== c && f.addEventListener("progress", function(a) {
    c(a);
  }, !1);
  void 0 !== d && f.addEventListener("error", function(a) {
    d(a);
  }, !1);
  void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
  f.src = a;
  e.manager.itemStart(a);
  return f;
}, setCrossOrigin:function(a) {
  this.crossOrigin = a;
}};
THREE.LoadingManager = function(a, b, c) {
  var d = this, e = 0, f = 0;
  this.onLoad = a;
  this.onProgress = b;
  this.onError = c;
  this.itemStart = function(a) {
    f++;
  };
  this.itemEnd = function(a) {
    e++;
    if (void 0 !== d.onProgress) {
      d.onProgress(a, e, f);
    }
    if (e === f && void 0 !== d.onLoad) {
      d.onLoad();
    }
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.TextureLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {constructor:THREE.TextureLoader, load:function(a, b, c, d) {
  c = new THREE.ImageLoader(this.manager);
  c.setCrossOrigin(this.crossOrigin);
  c.load(a, function(a) {
    a = new THREE.Texture(a);
    a.needsUpdate = !0;
    void 0 !== b && b(a);
  });
}, setCrossOrigin:function(a) {
  this.crossOrigin = a;
}};
THREE.Material = function() {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = !1;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthWrite = this.depthTest = !0;
  this.polygonOffset = !1;
  this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
  this.needsUpdate = this.visible = !0;
};
THREE.Material.prototype = {constructor:THREE.Material, setValues:function(a) {
  if (void 0 !== a) {
    for (var b in a) {
      var c = a[b];
      if (void 0 === c) {
        console.warn("THREE.Material: '" + b + "' parameter is undefined.");
      } else {
        if (b in this) {
          var d = this[b];
          d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c;
        }
      }
    }
  }
}, clone:function(a) {
  void 0 === a && (a = new THREE.Material);
  a.name = this.name;
  a.side = this.side;
  a.opacity = this.opacity;
  a.transparent = this.transparent;
  a.blending = this.blending;
  a.blendSrc = this.blendSrc;
  a.blendDst = this.blendDst;
  a.blendEquation = this.blendEquation;
  a.depthTest = this.depthTest;
  a.depthWrite = this.depthWrite;
  a.polygonOffset = this.polygonOffset;
  a.polygonOffsetFactor = this.polygonOffsetFactor;
  a.polygonOffsetUnits = this.polygonOffsetUnits;
  a.alphaTest = this.alphaTest;
  a.overdraw = this.overdraw;
  a.visible = this.visible;
  return a;
}, dispose:function() {
  this.dispatchEvent({type:"dispose"});
}};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function(a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linejoin = this.linecap = "round";
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function() {
  var a = new THREE.LineBasicMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.linecap = this.linecap;
  a.linejoin = this.linejoin;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.LineDashedMaterial = function(a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.scale = this.linewidth = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function() {
  var a = new THREE.LineDashedMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.scale = this.scale;
  a.dashSize = this.dashSize;
  a.gapSize = this.gapSize;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.MeshBasicMaterial = function(a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function() {
  var a = new THREE.MeshBasicMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  return a;
};
THREE.MeshLambertMaterial = function(a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function() {
  var a = new THREE.MeshLambertMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshPhongMaterial = function(a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.wrapAround = this.metal = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.bumpMap = this.lightMap = this.map = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.envMap = this.specularMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function() {
  var a = new THREE.MeshPhongMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.specular.copy(this.specular);
  a.shininess = this.shininess;
  a.metal = this.metal;
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.bumpMap = this.bumpMap;
  a.bumpScale = this.bumpScale;
  a.normalMap = this.normalMap;
  a.normalScale.copy(this.normalScale);
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshDepthMaterial = function(a) {
  THREE.Material.call(this);
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.setValues(a);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function() {
  var a = new THREE.MeshDepthMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshNormalMaterial = function(a) {
  THREE.Material.call(this, a);
  this.shading = THREE.FlatShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.morphTargets = !1;
  this.setValues(a);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function() {
  var a = new THREE.MeshNormalMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshFaceMaterial = function(a) {
  this.materials = a instanceof Array ? a : [];
};
THREE.MeshFaceMaterial.prototype.clone = function() {
  for (var a = new THREE.MeshFaceMaterial, b = 0;b < this.materials.length;b++) {
    a.materials.push(this.materials[b].clone());
  }
  return a;
};
THREE.ShaderMaterial = function(a) {
  THREE.Material.call(this);
  this.vertexShader = this.fragmentShader = "void main() {}";
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.lights = this.fog = !1;
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.defaultAttributeValues = {color:[1, 1, 1], uv:[0, 0], uv2:[0, 0]};
  this.index0AttributeName = "position";
  this.setValues(a);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function() {
  var a = new THREE.ShaderMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.fragmentShader = this.fragmentShader;
  a.vertexShader = this.vertexShader;
  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  a.attributes = this.attributes;
  a.defines = this.defines;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.fog = this.fog;
  a.lights = this.lights;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.Texture = function(a, b, c, d, e, f, g, h, k) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.image = a;
  this.mipmaps = [];
  this.mapping = void 0 !== b ? b : new THREE.UVMapping;
  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== k ? k : 1;
  this.format = void 0 !== g ? g : THREE.RGBAFormat;
  this.type = void 0 !== h ? h : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = !0;
  this.premultiplyAlpha = !1;
  this.flipY = !0;
  this.unpackAlignment = 4;
  this._needsUpdate = !1;
  this.onUpdate = null;
};
THREE.Texture.prototype = {constructor:THREE.Texture, get needsUpdate() {
  return this._needsUpdate;
}, set needsUpdate(a) {
  !0 === a && this.update();
  this._needsUpdate = a;
}, clone:function(a) {
  void 0 === a && (a = new THREE.Texture);
  a.image = this.image;
  a.mipmaps = this.mipmaps.slice(0);
  a.mapping = this.mapping;
  a.wrapS = this.wrapS;
  a.wrapT = this.wrapT;
  a.magFilter = this.magFilter;
  a.minFilter = this.minFilter;
  a.anisotropy = this.anisotropy;
  a.format = this.format;
  a.type = this.type;
  a.offset.copy(this.offset);
  a.repeat.copy(this.repeat);
  a.generateMipmaps = this.generateMipmaps;
  a.premultiplyAlpha = this.premultiplyAlpha;
  a.flipY = this.flipY;
  a.unpackAlignment = this.unpackAlignment;
  return a;
}, update:function() {
  this.dispatchEvent({type:"update"});
}, dispose:function() {
  this.dispatchEvent({type:"dispose"});
}};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, k, l, m) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, m);
  this.image = {width:b, height:c};
  this.mipmaps = a;
  this.generateMipmaps = !1;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function() {
  var a = new THREE.CompressedTexture;
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.DataTexture = function(a, b, c, d, e, f, g, h, k, l, m) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, m);
  this.image = {data:a, width:b, height:c};
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function() {
  var a = new THREE.DataTexture;
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.Line = function(a, b, c) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry;
  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({color:16777215 * Math.random()});
  this.type = void 0 !== c ? c : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Mesh = function(a, b, c) {
  THREE.Object3D.call(this, c);
  this.geometry = void 0 !== a ? a : new THREE.Geometry;
  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({color:16777215 * Math.random()});
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function() {
  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var a = 0, b = this.geometry.morphTargets.length;a < b;a++) {
      this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
    }
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
  if (void 0 !== this.morphTargetDictionary[a]) {
    return this.morphTargetDictionary[a];
  }
  console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
  return 0;
};
THREE.Mesh.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Bone = function(a) {
  THREE.Object3D.call(this);
  this.skin = a;
  this.skinMatrix = new THREE.Matrix4;
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function(a, b) {
  this.matrixAutoUpdate && (b |= this.updateMatrix());
  if (b || this.matrixWorldNeedsUpdate) {
    a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;
  }
  var c, d = this.children.length;
  for (c = 0;c < d;c++) {
    this.children[c].update(this.skinMatrix, b);
  }
};
THREE.LOD = function() {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function(a, b) {
  void 0 === b && (b = 0);
  b = Math.abs(b);
  for (var c = 0;c < this.objects.length && !(b < this.objects[c].distance);c++) {
  }
  this.objects.splice(c, 0, {distance:b, object:a});
  this.add(a);
};
THREE.LOD.prototype.getObjectForDistance = function(a) {
  for (var b = 1, c = this.objects.length;b < c && !(a < this.objects[b].distance);b++) {
  }
  return this.objects[b - 1].object;
};
THREE.LOD.prototype.update = function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function(c) {
    if (1 < this.objects.length) {
      a.setFromMatrixPosition(c.matrixWorld);
      b.setFromMatrixPosition(this.matrixWorld);
      c = a.distanceTo(b);
      this.objects[0].object.visible = !0;
      for (var d = 1, e = this.objects.length;d < e;d++) {
        if (c >= this.objects[d].distance) {
          this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
        } else {
          break;
        }
      }
      for (;d < e;d++) {
        this.objects[d].object.visible = !1;
      }
    }
  };
}();
THREE.LOD.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.LOD);
  THREE.Object3D.prototype.clone.call(this, a);
  for (var b = 0, c = this.objects.length;b < c;b++) {
    var d = this.objects[b].object.clone();
    d.visible = 0 === b;
    a.addLevel(d, this.objects[b].distance);
  }
  return a;
};
THREE.Sprite = function() {
  var a = new THREE.Geometry2(3);
  a.vertices.set([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]);
  return function(b) {
    THREE.Object3D.call(this);
    this.geometry = a;
    this.material = void 0 !== b ? b : new THREE.SpriteMaterial;
  };
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function() {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
THREE.Sprite.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Sprite(this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function(a) {
  THREE.Object3D.call(this, a);
  this.children = [];
  this.overrideMaterial = this.fog = null;
  this.autoUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function(a) {
  if (a instanceof THREE.Light) {
    -1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && (void 0 === a.target.parent && this.add(a.target));
  } else {
    if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
      this.__objectsAdded.push(a);
      var b = this.__objectsRemoved.indexOf(a);
      -1 !== b && this.__objectsRemoved.splice(b, 1);
    }
  }
  this.dispatchEvent({type:"objectAdded", object:a});
  a.dispatchEvent({type:"addedToScene", scene:this});
  if (a.children) {
    for (b = 0;b < a.children.length;b++) {
      this.__addObject(a.children[b]);
    }
  }
};
THREE.Scene.prototype.__removeObject = function(a) {
  if (a instanceof THREE.Light) {
    var b = this.__lights.indexOf(a);
    -1 !== b && this.__lights.splice(b, 1);
    if (a.shadowCascadeArray) {
      for (b = 0;b < a.shadowCascadeArray.length;b++) {
        this.__removeObject(a.shadowCascadeArray[b]);
      }
    }
  } else {
    a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
  }
  this.dispatchEvent({type:"objectRemoved", object:a});
  a.dispatchEvent({type:"removedFromScene", scene:this});
  if (a.children) {
    for (b = 0;b < a.children.length;b++) {
      this.__removeObject(a.children[b]);
    }
  }
};
THREE.Scene.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Scene);
  THREE.Object3D.prototype.clone.call(this, a);
  null !== this.fog && (a.fog = this.fog.clone());
  null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
  a.autoUpdate = this.autoUpdate;
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  return a;
};
THREE.Fog = function(a, b, c) {
  this.name = "";
  this.color = new THREE.Color(a);
  this.near = void 0 !== b ? b : 1;
  this.far = void 0 !== c ? c : 1E3;
};
THREE.Fog.prototype.clone = function() {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function(a, b) {
  this.name = "";
  this.color = new THREE.Color(a);
  this.density = void 0 !== b ? b : 2.5E-4;
};
THREE.FogExp2.prototype.clone = function() {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.ShaderChunk = {fog_pars_fragment:"#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif", fog_fragment:"#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif", 
envmap_pars_fragment:"#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#endif\n#endif", normal_fragment:"vec3 normal = normalize( vNormal );\nvec3 geomNormal = normal;\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", 
envmap_fragment:"#if defined(USE_ENVMAP)\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( -vViewPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nvec3 cameraToVertex = normalize( -vViewPosition );\nreflectVec = reflect( cameraToVertex, vNormal );\n#endif\nreflectVec = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * reflectVec;\nfloat logShiny = log(max(1.0+1e-10, shininess));\n#ifdef ENV_LOGLUV\nfloat MipmapIndex = max(0.0, -1.66096404744368 * logShiny + 5.5);\nvec4 envTexColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), MipmapIndex );\nvec3 cubeColor = LogLuvDecode(envTexColor);\n#else\nvec4 envTexColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\nvec3 cubeColor = envTexColor.xyz;\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\n#endif\nfloat facing = dot( viewPosition, normal );\nif (facing < 0.0) {\nfacing = 1.0;\n}\nvec4 speca = vec4(specular, gl_FragColor.a);\n#ifdef METAL\nvec4 schlickRefl = speca; /* + ( 1.0 - speca ) * pow( max(1.0 - facing, 0.0), 5.0 );*/\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;\ngl_FragColor.a = speca.a;\n#else\n#ifdef CLEARCOAT\nvec3 cubeColorClearcoat;\nvec3 reflectVecClearcoat = reflect( -vViewPosition, vNormal );\nreflectVecClearcoat = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * reflectVecClearcoat;\n#ifdef ENV_LOGLUV\nvec4 envTexColorClearcoat = textureCube( envMap, vec3( flipEnvMap * reflectVecClearcoat.x, reflectVecClearcoat.yz ));\ncubeColorClearcoat = LogLuvDecode(envTexColorClearcoat);\n#else\nvec4 envTexColorClearcoat = textureCube( envMap, vec3( flipEnvMap * reflectVecClearcoat.x, reflectVecClearcoat.yz ) );\ncubeColorClearcoat = envTexColorClearcoat.xyz;\n#ifdef GAMMA_INPUT\ncubeColorClearcoat.xyz *= cubeColorClearcoat.xyz;\n#endif\n#endif\ncubeColor = mix(cubeColor, cubeColorClearcoat, reflectivity);\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * speca.xyz;\nfloat schlickRefl = reflectivity + ( 1.0 - reflectivity ) * pow( max(1.0 - facing, 0.0), 5.0 );\ngl_FragColor.xyz = mix(gl_FragColor.xyz, cubeColorClearcoat * schlickRefl, 0.5);\n#else\nvec4 schlickRefl = speca + ( 1.0 - speca ) * pow( max(1.0 - facing, 0.0), 5.0 );\nschlickRefl.rgb *= max(0.0, 1.0 - 1.0 / logShiny);\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * schlickRefl.xyz );\ngl_FragColor.a = schlickRefl.a;\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;\ngl_FragColor.a = schlickRefl.a;\n} else {\ngl_FragColor = mix( gl_FragColor, vec4(gl_FragColor.xyz * cubeColor.xyz, gl_FragColor.a), specularStrength * schlickRefl );\n}\n#endif\n#endif\n#endif", 
envmap_pars_vertex:"#if defined( USE_ENVMAP )\n#if ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif\n#endif", worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif", envmap_vertex:"#if defined( USE_ENVMAP ) \nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n#endif", 
map_pars_vertex:"#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\nuniform vec4 offsetRepeatBump;\n#endif", map_pars_fragment:"#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec2 vUvBump;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif", map_vertex:"#if defined( USE_MAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvUvBump = uv * offsetRepeatBump.zw + offsetRepeatBump.xy;\n#endif", 
map_fragment:"#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif", lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif", lightmap_pars_vertex:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif", lightmap_fragment:"#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif", lightmap_vertex:"#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif", 
logluv_pars_fragment:"const mat3 InverseM = mat3(\n6.0014, -2.7008, -1.7996,\n-1.3320,  3.1029, -5.7721,\n0.3008, -1.0882,  5.6268);\nvec3 LogLuvDecode(in vec4 vLogLuv) {\nfloat Le = vLogLuv.b * 255.0 + vLogLuv.a;\nvec3 Xp_Y_XYZp;\nXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\nXp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.g;\nXp_Y_XYZp.x = vLogLuv.r * Xp_Y_XYZp.z;\nvec3 vRGB = InverseM * Xp_Y_XYZp;\nreturn max(vRGB, vec3(0.0));\n}", bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUvBump );\nvec2 dSTdy = dFdy( vUvBump );\nfloat Hll = bumpScale * texture2D( bumpMap, vUvBump ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUvBump + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUvBump + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif", 
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUvBump.st );\nvec2 st1 = dFdy( vUvBump.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUvBump ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif", 
specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif", specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif", lights_phong_pars_vertex:"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif", lights_phong_vertex:"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvWorldPosition = worldPosition.xyz;\n#endif", 
lights_phong_pars_fragment:"uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef USE_IRRADIANCEMAP\nuniform samplerCube irradianceMap;\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", 
lights_phong_fragment:"#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, pointHalfVector ), 0.0), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, spotHalfVector ), 0.0), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( dirVector, dirHalfVector ), 0.0), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef USE_IRRADIANCEMAP\nvec3 worldNormal = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * normal;\nvec4 cubeColor4 = textureCube(irradianceMap, worldNormal);\n#ifdef IRR_LOGLUV\nvec3 indirectDiffuse = LogLuvDecode(cubeColor4);\n#else\nvec3 indirectDiffuse = cubeColor.xyz;\n#ifdef GAMMA_INPUT\nindirectDiffuse.xyz *= indirectDiffuse.xyz;\n#endif\n#endif\ntotalDiffuse += diffuse * indirectDiffuse;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif", 
color_pars_fragment:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif", color_fragment:"#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif", color_pars_vertex:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif", color_vertex:"#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif", default_vertex:"vec4 mvPosition;\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", defaultnormal_vertex:"vec3 objectNormal;\nobjectNormal = normal;\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;", 
shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif", shadowmap_fragment:"#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif", 
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif", shadowmap_vertex:"#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif", alphatest_fragment:"#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif", linear_to_gamma_fragment:"#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif", mrt_normals_pars_vertex:"#ifdef MRT_NORMALS\nvarying float depth;\n#endif", 
mrt_normals_vertex:"#ifdef MRT_NORMALS\ndepth = mvPosition.z;\n#endif", mrt_normals_pars_fragment:["#ifdef MRT_NORMALS", "undefined" !== typeof _isIE11 && _isIE11 ? "" : "#extension GL_EXT_draw_buffers : require", "varying float depth;\n#define gl_FragColor gl_FragData[0]\n#endif"].join("\n"), mrt_normals_fragment:"#ifdef MRT_NORMALS\ngeomNormal = geomNormal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\ngl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif"};
THREE.UniformsUtils = {merge:function(a) {
  var b, c, d, e = {};
  for (b = 0;b < a.length;b++) {
    for (c in d = this.clone(a[b]), d) {
      e[c] = d[c];
    }
  }
  return e;
}, clone:function(a) {
  var b, c, d, e = {};
  for (b in a) {
    for (c in e[b] = {}, a[b]) {
      d = a[b][c], e[b][c] = d instanceof THREE.Color || (d instanceof THREE.Vector2 || (d instanceof THREE.Vector3 || (d instanceof THREE.Vector4 || (d instanceof THREE.Matrix4 || d instanceof THREE.Texture)))) ? d.clone() : d instanceof Array ? d.slice() : d;
    }
  }
  return e;
}};
THREE.UniformsLib = {common:{diffuse:{type:"c", value:new THREE.Color(15658734)}, opacity:{type:"f", value:1}, map:{type:"t", value:null}, offsetRepeat:{type:"v4", value:new THREE.Vector4(0, 0, 1, 1)}, offsetRepeatBump:{type:"v4", value:new THREE.Vector4(0, 0, 1, 1)}, lightMap:{type:"t", value:null}, specularMap:{type:"t", value:null}, envMap:{type:"t", value:null}, flipEnvMap:{type:"f", value:-1}, useRefract:{type:"i", value:0}, reflectivity:{type:"f", value:1}, refractionRatio:{type:"f", value:0.98}, 
combine:{type:"i", value:0}}, bump:{bumpMap:{type:"t", value:null}, bumpScale:{type:"f", value:1}}, normalmap:{normalMap:{type:"t", value:null}, normalScale:{type:"v2", value:new THREE.Vector2(1, 1)}}, fog:{fogDensity:{type:"f", value:2.5E-4}, fogNear:{type:"f", value:1}, fogFar:{type:"f", value:2E3}, fogColor:{type:"c", value:new THREE.Color(16777215)}}, lights:{ambientLightColor:{type:"fv", value:[]}, directionalLightDirection:{type:"fv", value:[]}, directionalLightColor:{type:"fv", value:[]}, 
hemisphereLightDirection:{type:"fv", value:[]}, hemisphereLightSkyColor:{type:"fv", value:[]}, hemisphereLightGroundColor:{type:"fv", value:[]}, pointLightColor:{type:"fv", value:[]}, pointLightPosition:{type:"fv", value:[]}, pointLightDistance:{type:"fv1", value:[]}, spotLightColor:{type:"fv", value:[]}, spotLightPosition:{type:"fv", value:[]}, spotLightDirection:{type:"fv", value:[]}, spotLightDistance:{type:"fv1", value:[]}, spotLightAngleCos:{type:"fv1", value:[]}, spotLightExponent:{type:"fv1", 
value:[]}, irradianceMap:{type:"t", value:null}}, shadowmap:{shadowMap:{type:"tv", value:[]}, shadowMapSize:{type:"v2v", value:[]}, shadowBias:{type:"fv1", value:[]}, shadowDarkness:{type:"fv1", value:[]}, shadowMatrix:{type:"m4v", value:[]}}};
THREE.ShaderLib = {basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]), vertexShader:[THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.defaultnormal_vertex, 
"#endif", THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"), fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, 
"void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, 
THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {ambient:{type:"c", value:new THREE.Color(16777215)}, emissive:{type:"c", value:new THREE.Color(0)}, specular:{type:"c", value:new THREE.Color(1118481)}, shininess:{type:"f", value:30}, wrapRGB:{type:"v3", value:new THREE.Vector3(1, 1, 1)}}]), vertexShader:["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, 
THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.mrt_normals_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, 
THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, THREE.ShaderChunk.mrt_normals_vertex, "}"].join("\n"), fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.logluv_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, 
THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.mrt_normals_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.normal_fragment, THREE.ShaderChunk.lights_phong_fragment, 
THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, THREE.ShaderChunk.mrt_normals_fragment, "}"].join("\n")}, dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {scale:{type:"f", value:1}, dashSize:{type:"f", value:1}, totalSize:{type:"f", value:2}}]), vertexShader:["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", 
THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"), fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );", 
THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")}, depth:{uniforms:{mNear:{type:"f", value:1}, mFar:{type:"f", value:2E3}, opacity:{type:"f", value:1}}, vertexShader:"void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"}, 
normal:{uniforms:{opacity:{type:"f", value:1}}, vertexShader:["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"), fragmentShader:"uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"}, cube:{uniforms:{tCube:{type:"t", value:null}, tFlip:{type:"f", value:-1}}, 
vertexShader:"varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"}, depthRGBA:{uniforms:{}, vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex, 
THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"), fragmentShader:"vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"}};
THREE.WebGLRenderTarget = function(a, b, c) {
  this.width = a;
  this.height = b;
  c = c || {};
  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
  this.generateMipmaps = !0;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {constructor:THREE.WebGLRenderTarget, clone:function() {
  var a = new THREE.WebGLRenderTarget(this.width, this.height);
  a.wrapS = this.wrapS;
  a.wrapT = this.wrapT;
  a.magFilter = this.magFilter;
  a.minFilter = this.minFilter;
  a.anisotropy = this.anisotropy;
  a.offset.copy(this.offset);
  a.repeat.copy(this.repeat);
  a.format = this.format;
  a.type = this.type;
  a.depthBuffer = this.depthBuffer;
  a.stencilBuffer = this.stencilBuffer;
  a.generateMipmaps = this.generateMipmaps;
  a.shareDepthFrom = this.shareDepthFrom;
  return a;
}, dispose:function() {
  this.dispatchEvent({type:"dispose"});
}};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.GeometryUtils = {merge:function(a, b, c) {
  var d, e, f = a.vertices.length, g = b instanceof THREE.Mesh ? b.geometry : b, h = a.vertices, k = g.vertices, l = a.faces, m = g.faces;
  a = a.faceVertexUvs[0];
  g = g.faceVertexUvs[0];
  void 0 === c && (c = 0);
  b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, e = (new THREE.Matrix3).getNormalMatrix(d));
  b = 0;
  for (var q = k.length;b < q;b++) {
    var p = k[b].clone();
    d && p.applyMatrix4(d);
    h.push(p);
  }
  b = 0;
  for (q = m.length;b < q;b++) {
    var p = m[b], r, s, n = p.vertexNormals, t = p.vertexColors;
    r = new THREE.Face3(p.a + f, p.b + f, p.c + f);
    r.normal.copy(p.normal);
    e && r.normal.applyMatrix3(e).normalize();
    h = 0;
    for (k = n.length;h < k;h++) {
      s = n[h].clone(), e && s.applyMatrix3(e).normalize(), r.vertexNormals.push(s);
    }
    r.color.copy(p.color);
    h = 0;
    for (k = t.length;h < k;h++) {
      s = t[h], r.vertexColors.push(s.clone());
    }
    r.materialIndex = p.materialIndex + c;
    r.centroid.copy(p.centroid);
    d && r.centroid.applyMatrix4(d);
    l.push(r);
  }
  b = 0;
  for (q = g.length;b < q;b++) {
    c = g[b];
    d = [];
    h = 0;
    for (k = c.length;h < k;h++) {
      d.push(new THREE.Vector2(c[h].x, c[h].y));
    }
    a.push(d);
  }
}, randomPointInTriangle:function() {
  var a = new THREE.Vector3;
  return function(b, c, d) {
    var e = new THREE.Vector3, f = THREE.Math.random16(), g = THREE.Math.random16();
    1 < f + g && (f = 1 - f, g = 1 - g);
    var h = 1 - f - g;
    e.copy(b);
    e.multiplyScalar(f);
    a.copy(c);
    a.multiplyScalar(g);
    e.add(a);
    a.copy(d);
    a.multiplyScalar(h);
    e.add(a);
    return e;
  };
}(), randomPointInFace:function(a, b, c) {
  return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c]);
}, randomPointsInGeometry:function(a, b) {
  function c(a) {
    function b(c, d) {
      if (d < c) {
        return c;
      }
      var e = c + Math.floor((d - c) / 2);
      return l[e] > a ? b(c, e - 1) : l[e] < a ? b(e + 1, d) : e;
    }
    return b(0, l.length - 1);
  }
  var d, e, f = a.faces, g = a.vertices, h = f.length, k = 0, l = [], m, q, p;
  for (e = 0;e < h;e++) {
    d = f[e], m = g[d.a], q = g[d.b], p = g[d.c], d._area = THREE.GeometryUtils.triangleArea(m, q, p), k += d._area, l[e] = k;
  }
  d = [];
  for (e = 0;e < b;e++) {
    g = THREE.Math.random16() * k, g = c(g), d[e] = THREE.GeometryUtils.randomPointInFace(f[g], a, !0);
  }
  return d;
}, triangleArea:function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function(c, d, e) {
    a.subVectors(d, c);
    b.subVectors(e, c);
    a.cross(b);
    return 0.5 * a.length();
  };
}(), center:function(a) {
  a.computeBoundingBox();
  var b = a.boundingBox, c = new THREE.Vector3;
  c.addVectors(b.min, b.max);
  c.multiplyScalar(-0.5);
  a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x, c.y, c.z));
  a.computeBoundingBox();
  return c;
}, triangulateQuads:function(a) {
  var b, c, d, e, f = [], g = [];
  b = 0;
  for (c = a.faceVertexUvs.length;b < c;b++) {
    g[b] = [];
  }
  b = 0;
  for (c = a.faces.length;b < c;b++) {
    for (f.push(a.faces[b]), d = 0, e = a.faceVertexUvs.length;d < e;d++) {
      g[d].push(a.faceVertexUvs[d][b]);
    }
  }
  a.faces = f;
  a.faceVertexUvs = g;
  a.computeCentroids();
  a.computeFaceNormals();
  a.computeVertexNormals();
  a.hasTangents && a.computeTangents();
}};
THREE.ImageUtils = {crossOrigin:"", loadTexture:function(a, b, c, d) {
  d = new THREE.ImageLoader;
  d.crossOrigin = this.crossOrigin;
  var e = new THREE.Texture(void 0, b);
  b = d.load(a, function() {
    e.needsUpdate = !0;
    c && c(e);
  });
  e.image = b;
  e.sourceFile = a;
  return e;
}, loadCompressedTexture:function(a, b, c, d) {
  var e = new THREE.CompressedTexture;
  e.mapping = b;
  var f = new XMLHttpRequest;
  f.onload = function() {
    var a = THREE.ImageUtils.parseDDS(f.response, !0);
    e.format = a.format;
    e.type = a.type;
    e.mipmaps = a.mipmaps;
    e.image.width = a.width;
    e.image.height = a.height;
    e.generateMipmaps = !1;
    e.needsUpdate = !0;
    c && c(e);
  };
  f.onerror = d;
  f.open("GET", a, !0);
  f.responseType = "arraybuffer";
  f.send(null);
  return e;
}, loadTextureCube:function(a, b, c, d) {
  var e = [];
  e.loadCount = 0;
  var f = new THREE.Texture;
  f.image = e;
  void 0 !== b && (f.mapping = b);
  f.flipY = !1;
  b = 0;
  for (var g = a.length;b < g;++b) {
    var h = new Image;
    e[b] = h;
    h.onload = function() {
      e.loadCount += 1;
      6 === e.loadCount && (f.needsUpdate = !0, c && c(f));
    };
    h.onerror = d;
    h.crossOrigin = this.crossOrigin;
    h.src = a[b];
  }
  return f;
}, loadCompressedTextureCube:function(a, b, c, d) {
  var e = [];
  e.loadCount = 0;
  var f = new THREE.CompressedTexture;
  f.image = e;
  void 0 !== b && (f.mapping = b);
  f.flipY = !1;
  f.generateMipmaps = !1;
  b = function(a, b) {
    return function() {
      var d = THREE.ImageUtils.parseDDS(a.response, !0);
      b.format = d.format;
      b.type = d.type;
      b.mipmaps = d.mipmaps;
      b.width = d.width;
      b.height = d.height;
      e.loadCount += 1;
      6 === e.loadCount && (f.format = d.format, f.type = d.type, 1 == d.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, c && c(f));
    };
  };
  if (a instanceof Array) {
    for (var g = 0, h = a.length;g < h;++g) {
      var k = {};
      e[g] = k;
      var l = new XMLHttpRequest;
      l.onload = b(l, k);
      l.onerror = d;
      k = a[g];
      l.open("GET", k, !0);
      l.responseType = "arraybuffer";
      l.send(null);
    }
  } else {
    l = new XMLHttpRequest, l.onload = function() {
      var a = THREE.ImageUtils.parseDDS(l.response, !0);
      if (a.isCubemap) {
        for (var b = a.mipmaps.length / a.mipmapCount, d = 0;d < b;d++) {
          e[d] = {mipmaps:[]};
          for (var g = 0;g < a.mipmapCount;g++) {
            e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]), e[d].format = a.format, e[d].type = a.type, e[d].width = a.width, e[d].height = a.height;
          }
        }
        f.format = a.format;
        f.type = a.type;
        1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter);
        f.needsUpdate = !0;
        c && c(f);
      }
    }, l.onerror = d, l.open("GET", a, !0), l.responseType = "arraybuffer", l.send(null);
  }
  return f;
}, loadDDSTexture:function(a, b, c, d) {
  var e = [];
  e.loadCount = 0;
  var f = new THREE.CompressedTexture;
  f.image = e;
  void 0 !== b && (f.mapping = b);
  f.flipY = !1;
  f.generateMipmaps = !1;
  var g = new XMLHttpRequest;
  g.onload = function() {
    var a = THREE.ImageUtils.parseDDS(g.response, !0);
    if (a.isCubemap) {
      for (var b = a.mipmaps.length / a.mipmapCount, d = 0;d < b;d++) {
        e[d] = {mipmaps:[]};
        for (var m = 0;m < a.mipmapCount;m++) {
          e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + m]), e[d].format = a.format, e[d].type = a.type, e[d].width = a.width, e[d].height = a.height;
        }
      }
    } else {
      f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
    }
    f.format = a.format;
    f.type = a.type;
    1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter);
    f.needsUpdate = !0;
    c && c(f);
  };
  g.onerror = d;
  g.open("GET", a, !0);
  g.responseType = "arraybuffer";
  g.send(null);
  return f;
}, parseDDS:function(a, b) {
  function c(a) {
    return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24);
  }
  function d(a, b, c, d) {
    var e = c * d * 4;
    a = new Uint8Array(a, b, e);
    for (var e = new Uint8Array(e), f = b = 0, g = 0;g < d;g++) {
      for (var h = 0;h < c;h++) {
        var k = a[f];
        f++;
        var l = a[f];
        f++;
        var m = a[f];
        f++;
        var p = a[f];
        f++;
        e[b] = m;
        b++;
        e[b] = l;
        b++;
        e[b] = k;
        b++;
        e[b] = p;
        b++;
      }
    }
    return e;
  }
  var e = {mipmaps:[], width:0, height:0, format:null, type:THREE.UnsignedByteType, mipmapCount:1}, f = c("DXT1"), g = c("DXT3"), h = c("DXT5"), k = new Int32Array(a, 0, 31);
  if (542327876 !== k[0]) {
    return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"), e;
  }
  if (!k[20] & 4) {
    return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"), e;
  }
  var l = k[21], m = !1;
  switch(l) {
    case f:
      f = 8;
      e.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case g:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case h:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    case 116:
      f = 16;
      e.format = THREE.RGBAFormat;
      e.type = THREE.FloatType;
      m = !0;
      break;
    default:
      if (32 == k[22] && (k[23] & 16711680 && (k[24] & 65280 && (k[25] & 255 && k[26] & 4278190080)))) {
        m = !0, f = 64, e.format = THREE.RGBAFormat, e.type = THREE.UnsignedByteType;
      } else {
        return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)), e;
      }
    ;
  }
  e.mipmapCount = 1;
  k[2] & 131072 && (!1 !== b && (e.mipmapCount = Math.max(1, k[7])));
  e.isCubemap = k[28] & 512 ? !0 : !1;
  e.width = k[4];
  e.height = k[3];
  for (var k = k[1] + 4, g = e.width, h = e.height, l = e.isCubemap ? 6 : 1, q = 0;q < l;q++) {
    for (var p = 0;p < e.mipmapCount;p++) {
      if (m) {
        if (e.type == THREE.FloatType) {
          var r = g * h * 16, s = new Float32Array(a.slice(k, k + r))
        } else {
          s = d(a, k, g, h), r = s.length;
        }
      } else {
        r = Math.max(4, g) / 4 * Math.max(4, h) / 4 * f, s = new Uint8Array(a, k, r);
      }
      e.mipmaps.push({data:s, width:g, height:h});
      k += r;
      g = Math.max(0.5 * g, 1);
      h = Math.max(0.5 * h, 1);
    }
    g = e.width;
    h = e.height;
  }
  return e;
}, getNormalMap:function(a, b) {
  var c = function(a) {
    var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    return[a[0] / b, a[1] / b, a[2] / b];
  };
  b |= 1;
  var d = a.width, e = a.height, f = document.createElement("canvas");
  f.width = d;
  f.height = e;
  var g = f.getContext("2d");
  g.drawImage(a, 0, 0);
  for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, m = 0;m < d;m++) {
    for (var q = 0;q < e;q++) {
      var p = 0 > q - 1 ? 0 : q - 1, r = q + 1 > e - 1 ? e - 1 : q + 1, s = 0 > m - 1 ? 0 : m - 1, n = m + 1 > d - 1 ? d - 1 : m + 1, t = [], v = [0, 0, h[4 * (q * d + m)] / 255 * b];
      t.push([-1, 0, h[4 * (q * d + s)] / 255 * b]);
      t.push([-1, -1, h[4 * (p * d + s)] / 255 * b]);
      t.push([0, -1, h[4 * (p * d + m)] / 255 * b]);
      t.push([1, -1, h[4 * (p * d + n)] / 255 * b]);
      t.push([1, 0, h[4 * (q * d + n)] / 255 * b]);
      t.push([1, 1, h[4 * (r * d + n)] / 255 * b]);
      t.push([0, 1, h[4 * (r * d + m)] / 255 * b]);
      t.push([-1, 1, h[4 * (r * d + s)] / 255 * b]);
      p = [];
      s = t.length;
      for (r = 0;r < s;r++) {
        var n = t[r], u = t[(r + 1) % s], n = [n[0] - v[0], n[1] - v[1], n[2] - v[2]], u = [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
        p.push(c([n[1] * u[2] - n[2] * u[1], n[2] * u[0] - n[0] * u[2], n[0] * u[1] - n[1] * u[0]]));
      }
      t = [0, 0, 0];
      for (r = 0;r < p.length;r++) {
        t[0] += p[r][0], t[1] += p[r][1], t[2] += p[r][2];
      }
      t[0] /= p.length;
      t[1] /= p.length;
      t[2] /= p.length;
      v = 4 * (q * d + m);
      l[v] = (t[0] + 1) / 2 * 255 | 0;
      l[v + 1] = (t[1] + 1) / 2 * 255 | 0;
      l[v + 2] = 255 * t[2] | 0;
      l[v + 3] = 255;
    }
  }
  g.putImageData(k, 0, 0);
  return f;
}, generateDataTexture:function(a, b, c) {
  var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
  c = Math.floor(255 * c.b);
  for (var h = 0;h < d;h++) {
    e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
  }
  a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
  a.needsUpdate = !0;
  return a;
}};
THREE.SceneUtils = {createMultiMaterialObject:function(a, b) {
  for (var c = new THREE.Object3D, d = 0, e = b.length;d < e;d++) {
    c.add(new THREE.Mesh(a, b[d]));
  }
  return c;
}, detach:function(a, b, c) {
  a.applyMatrix(b.matrixWorld);
  b.remove(a);
  c.add(a);
}, attach:function(a, b, c) {
  var d = new THREE.Matrix4;
  d.getInverse(c.matrixWorld);
  a.applyMatrix(d);
  b.remove(a);
  c.add(a);
}};
THREE.FontUtils = {faces:{}, face:"helvetiker", weight:"normal", style:"normal", size:150, divisions:10, getFace:function() {
  return this.faces[this.face][this.weight][this.style];
}, loadFace:function(a) {
  var b = a.familyName.toLowerCase();
  this.faces[b] = this.faces[b] || {};
  this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
  this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
  return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
}, drawText:function(a) {
  var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(""), f = e.length, g = [];
  for (a = 0;a < f;a++) {
    var h = new THREE.Path, h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
    g.push(h.path);
  }
  return{paths:g, offset:d / 2};
}, extractGlyphPoints:function(a, b, c, d, e) {
  var f = [], g, h, k, l, m, q, p, r, s, n, t, v = b.glyphs[a] || b.glyphs["?"];
  if (v) {
    if (v.o) {
      for (b = v._cachedOutline || (v._cachedOutline = v.o.split(" ")), l = b.length, a = 0;a < l;) {
        switch(k = b[a++], k) {
          case "m":
            k = b[a++] * c + d;
            m = b[a++] * c;
            e.moveTo(k, m);
            break;
          case "l":
            k = b[a++] * c + d;
            m = b[a++] * c;
            e.lineTo(k, m);
            break;
          case "q":
            k = b[a++] * c + d;
            m = b[a++] * c;
            r = b[a++] * c + d;
            s = b[a++] * c;
            e.quadraticCurveTo(r, s, k, m);
            if (g = f[f.length - 1]) {
              for (q = g.x, p = g.y, g = 1, h = this.divisions;g <= h;g++) {
                var u = g / h;
                THREE.Shape.Utils.b2(u, q, r, k);
                THREE.Shape.Utils.b2(u, p, s, m);
              }
            }
            break;
          case "b":
            if (k = b[a++] * c + d, m = b[a++] * c, r = b[a++] * c + d, s = b[a++] * -c, n = b[a++] * c + d, t = b[a++] * -c, e.bezierCurveTo(k, m, r, s, n, t), g = f[f.length - 1]) {
              for (q = g.x, p = g.y, g = 1, h = this.divisions;g <= h;g++) {
                u = g / h, THREE.Shape.Utils.b3(u, q, r, n, k), THREE.Shape.Utils.b3(u, p, s, t, m);
              }
            }
          ;
        }
      }
    }
    return{offset:v.ha * c, path:e};
  }
}};
THREE.FontUtils.generateShapes = function(a, b) {
  b = b || {};
  var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : "helvetiker", e = void 0 !== b.weight ? b.weight : "normal", f = void 0 !== b.style ? b.style : "normal";
  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
  THREE.FontUtils.divisions = c;
  THREE.FontUtils.face = d;
  THREE.FontUtils.weight = e;
  THREE.FontUtils.style = f;
  c = THREE.FontUtils.drawText(a).paths;
  d = [];
  e = 0;
  for (f = c.length;e < f;e++) {
    Array.prototype.push.apply(d, c[e].toShapes());
  }
  return d;
};
(function(a) {
  var b = function(a) {
    for (var b = a.length, e = 0, f = b - 1, g = 0;g < b;f = g++) {
      e += a[f].x * a[g].y - a[g].x * a[f].y;
    }
    return 0.5 * e;
  };
  a.Triangulate = function(a, d) {
    var e = a.length;
    if (3 > e) {
      return null;
    }
    var f = [], g = [], h = [], k, l, m;
    if (0 < b(a)) {
      for (l = 0;l < e;l++) {
        g[l] = l;
      }
    } else {
      for (l = 0;l < e;l++) {
        g[l] = e - 1 - l;
      }
    }
    var q = 2 * e;
    for (l = e - 1;2 < e;) {
      if (0 >= q--) {
        console.log("Warning, unable to triangulate polygon!");
        break;
      }
      k = l;
      e <= k && (k = 0);
      l = k + 1;
      e <= l && (l = 0);
      m = l + 1;
      e <= m && (m = 0);
      var p;
      a: {
        var r = p = void 0, s = void 0, n = void 0, t = void 0, v = void 0, u = void 0, w = void 0, x = void 0, r = a[g[k]].x, s = a[g[k]].y, n = a[g[l]].x, t = a[g[l]].y, v = a[g[m]].x, u = a[g[m]].y;
        if (1E-10 > (n - r) * (u - s) - (t - s) * (v - r)) {
          p = !1;
        } else {
          var y = void 0, G = void 0, z = void 0, B = void 0, C = void 0, E = void 0, H = void 0, N = void 0, D = void 0, K = void 0, D = N = H = x = w = void 0, y = v - n, G = u - t, z = r - v, B = s - u, C = n - r, E = t - s;
          for (p = 0;p < e;p++) {
            if (w = a[g[p]].x, x = a[g[p]].y, !(w === r && x === s || (w === n && x === t || w === v && x === u)) && (H = w - r, N = x - s, D = w - n, K = x - t, w -= v, x -= u, D = y * K - G * D, H = C * N - E * H, N = z * x - B * w, -1E-10 <= D && (-1E-10 <= N && -1E-10 <= H))) {
              p = !1;
              break a;
            }
          }
          p = !0;
        }
      }
      if (p) {
        f.push([a[g[k]], a[g[l]], a[g[m]]]);
        h.push([g[k], g[l], g[m]]);
        k = l;
        for (m = l + 1;m < e;k++, m++) {
          g[k] = g[m];
        }
        e--;
        q = 2 * e;
      }
    }
    return d ? h : f;
  };
  a.Triangulate.area = b;
  return a;
})(THREE.FontUtils);
self._typeface_js = {faces:THREE.FontUtils.faces, loadFace:THREE.FontUtils.loadFace};
THREE.typeface_js = self._typeface_js;
THREE.Gyroscope = function() {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function(a) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || a) {
    this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
  }
  for (var b = 0, c = this.children.length;b < c;b++) {
    this.children[b].updateMatrixWorld(a);
  }
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3;
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion;
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion;
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3;
THREE.AnimationHandler = function() {
  var a = [], b = {}, c = {update:function(b) {
    for (var c = 0;c < a.length;c++) {
      a[c].update(b);
    }
  }, addToUpdate:function(b) {
    -1 === a.indexOf(b) && a.push(b);
  }, removeFromUpdate:function(b) {
    b = a.indexOf(b);
    -1 !== b && a.splice(b, 1);
  }, add:function(a) {
    void 0 !== b[a.name] && console.log("THREE.AnimationHandler.add: Warning! " + a.name + " already exists in library. Overwriting.");
    b[a.name] = a;
    if (!0 !== a.initialized) {
      for (var c = 0;c < a.hierarchy.length;c++) {
        for (var d = 0;d < a.hierarchy[c].keys.length;d++) {
          if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {
            var h = a.hierarchy[c].keys[d].rot;
            a.hierarchy[c].keys[d].rot = new THREE.Quaternion(h[0], h[1], h[2], h[3]);
          }
        }
        if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
          h = {};
          for (d = 0;d < a.hierarchy[c].keys.length;d++) {
            for (var k = 0;k < a.hierarchy[c].keys[d].morphTargets.length;k++) {
              var l = a.hierarchy[c].keys[d].morphTargets[k];
              h[l] = -1;
            }
          }
          a.hierarchy[c].usedMorphTargets = h;
          for (d = 0;d < a.hierarchy[c].keys.length;d++) {
            var m = {};
            for (l in h) {
              for (k = 0;k < a.hierarchy[c].keys[d].morphTargets.length;k++) {
                if (a.hierarchy[c].keys[d].morphTargets[k] === l) {
                  m[l] = a.hierarchy[c].keys[d].morphTargetsInfluences[k];
                  break;
                }
              }
              k === a.hierarchy[c].keys[d].morphTargets.length && (m[l] = 0);
            }
            a.hierarchy[c].keys[d].morphTargetsInfluences = m;
          }
        }
        for (d = 1;d < a.hierarchy[c].keys.length;d++) {
          a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);
        }
        for (d = 0;d < a.hierarchy[c].keys.length;d++) {
          a.hierarchy[c].keys[d].index = d;
        }
      }
      a.initialized = !0;
    }
  }, get:function(a) {
    if ("string" === typeof a) {
      if (b[a]) {
        return b[a];
      }
      console.log("THREE.AnimationHandler.get: Couldn't find animation " + a);
      return null;
    }
  }, parse:function(a) {
    var b = [];
    if (a instanceof THREE.SkinnedMesh) {
      for (var c = 0;c < a.bones.length;c++) {
        b.push(a.bones[c]);
      }
    } else {
      d(a, b);
    }
    return b;
  }}, d = function(a, b) {
    b.push(a);
    for (var c = 0;c < a.children.length;c++) {
      d(a.children[c], b);
    }
  };
  c.LINEAR = 0;
  c.CATMULLROM = 1;
  c.CATMULLROM_FORWARD = 2;
  return c;
}();
THREE.Animation = function(a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype.play = function(a) {
  this.currentTime = void 0 !== a ? a : 0;
  !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0));
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function() {
  !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function() {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.reset = function() {
  for (var a = 0, b = this.hierarchy.length;a < b;a++) {
    var c = this.hierarchy[a];
    c.matrixAutoUpdate = !0;
    void 0 === c.animationCache && (c.animationCache = {}, c.animationCache.prevKey = {pos:0, rot:0, scl:0}, c.animationCache.nextKey = {pos:0, rot:0, scl:0}, c.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
    var d = c.animationCache.prevKey, c = c.animationCache.nextKey;
    d.pos = this.data.hierarchy[a].keys[0];
    d.rot = this.data.hierarchy[a].keys[0];
    d.scl = this.data.hierarchy[a].keys[0];
    c.pos = this.getNextKeyWith("pos", a, 1);
    c.rot = this.getNextKeyWith("rot", a, 1);
    c.scl = this.getNextKeyWith("scl", a, 1);
  }
};
THREE.Animation.prototype.update = function() {
  var a = [], b = new THREE.Vector3, c = function(a, b) {
    var c = [], h = [], k, l, m, q, p, r;
    k = (a.length - 1) * b;
    l = Math.floor(k);
    k -= l;
    c[0] = 0 === l ? l : l - 1;
    c[1] = l;
    c[2] = l > a.length - 2 ? l : l + 1;
    c[3] = l > a.length - 3 ? l : l + 2;
    l = a[c[0]];
    q = a[c[1]];
    p = a[c[2]];
    r = a[c[3]];
    c = k * k;
    m = k * c;
    h[0] = d(l[0], q[0], p[0], r[0], k, c, m);
    h[1] = d(l[1], q[1], p[1], r[1], k, c, m);
    h[2] = d(l[2], q[2], p[2], r[2], k, c, m);
    return h;
  }, d = function(a, b, c, d, k, l, m) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    return(2 * (b - c) + a + d) * m + (-3 * (b - c) - 2 * a - d) * l + a * k + b;
  };
  return function(d) {
    if (!1 !== this.isPlaying) {
      this.currentTime += d * this.timeScale;
      var f;
      d = ["pos", "rot", "scl"];
      var g = this.data.length;
      if (!0 === this.loop && this.currentTime > g) {
        this.currentTime %= g, this.reset();
      } else {
        if (!1 === this.loop && this.currentTime > g) {
          this.stop();
          return;
        }
      }
      this.currentTime = Math.min(this.currentTime, g);
      for (var g = 0, h = this.hierarchy.length;g < h;g++) {
        for (var k = this.hierarchy[g], l = k.animationCache, m = 0;3 > m;m++) {
          f = d[m];
          var q = l.prevKey[f], p = l.nextKey[f];
          if (p.time <= this.currentTime) {
            q = this.data.hierarchy[g].keys[0];
            for (p = this.getNextKeyWith(f, g, 1);p.time < this.currentTime && p.index > q.index;) {
              q = p, p = this.getNextKeyWith(f, g, p.index + 1);
            }
            l.prevKey[f] = q;
            l.nextKey[f] = p;
          }
          k.matrixAutoUpdate = !0;
          k.matrixWorldNeedsUpdate = !0;
          var r = (this.currentTime - q.time) / (p.time - q.time), s = q[f], n = p[f];
          0 > r && (r = 0);
          1 < r && (r = 1);
          if ("pos" === f) {
            if (f = k.position, this.interpolationType === THREE.AnimationHandler.LINEAR) {
              f.x = s[0] + (n[0] - s[0]) * r, f.y = s[1] + (n[1] - s[1]) * r, f.z = s[2] + (n[2] - s[2]) * r;
            } else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                a[0] = this.getPrevKeyWith("pos", g, q.index - 1).pos, a[1] = s, a[2] = n, a[3] = this.getNextKeyWith("pos", g, p.index + 1).pos, r = 0.33 * r + 0.33, q = c(a, r), f.x = q[0], f.y = q[1], f.z = q[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (r = c(a, 1.01 * r), b.set(r[0], r[1], r[2]), b.sub(f), b.y = 0, b.normalize(), f = Math.atan2(b.x, b.z), k.rotation.set(0, f, 0));
              }
            }
          } else {
            "rot" === f ? THREE.Quaternion.slerp(s, n, k.quaternion, r) : "scl" === f && (f = k.scale, f.x = s[0] + (n[0] - s[0]) * r, f.y = s[1] + (n[1] - s[1]) * r, f.z = s[2] + (n[2] - s[2]) * r);
          }
        }
      }
    }
  };
}();
THREE.Animation.prototype.getNextKeyWith = function(a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length;c < d.length;c++) {
    if (void 0 !== d[c][a]) {
      return d[c];
    }
  }
  return this.data.hierarchy[b].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function(a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length;0 <= c;c--) {
    if (void 0 !== d[c][a]) {
      return d[c];
    }
  }
  return this.data.hierarchy[b].keys[d.length - 1];
};
THREE.KeyFrameAnimation = function(a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  for (var c = 0, d = this.hierarchy.length;c < d;c++) {
    var e = this.data.hierarchy[c].sids, f = this.hierarchy[c];
    if (this.data.hierarchy[c].keys.length && e) {
      for (var g = 0;g < e.length;g++) {
        var h = e[g], k = this.getNextKeyWith(h, c, 0);
        k && k.apply(h);
      }
      f.matrixAutoUpdate = !1;
      this.data.hierarchy[c].node.updateMatrix();
      f.matrixWorldNeedsUpdate = !0;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function(a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var b = this.hierarchy.length, c, d;
    for (a = 0;a < b;a++) {
      c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
    }
    this.update(0);
  }
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function() {
  this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function() {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var a = 0;a < this.data.hierarchy.length;a++) {
    var b = this.hierarchy[a], c = this.data.hierarchy[a];
    if (void 0 !== c.animationCache) {
      var d = c.animationCache.originalMatrix;
      b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);
      delete c.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function(a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && (this.currentTime > a && (this.currentTime %= a));
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var b = this.hierarchy.length;a < b;a++) {
      var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
      if (e.length) {
        var f = d.prevKey, g = d.nextKey;
        if (g.time <= this.currentTime) {
          for (;g.time < this.currentTime && g.index > f.index;) {
            f = g, g = e[f.index + 1];
          }
          d.prevKey = f;
          d.nextKey = g;
        }
        g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);
        this.data.hierarchy[a].node.updateMatrix();
        c.matrixWorldNeedsUpdate = !0;
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c %= b.length;c < b.length;c++) {
    if (b[c].hasTarget(a)) {
      return b[c];
    }
  }
  return b[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c = 0 <= c ? c : c + b.length;0 <= c;c--) {
    if (b[c].hasTarget(a)) {
      return b[c];
    }
  }
  return b[b.length - 1];
};
THREE.CubeCamera = function(a, b, c) {
  THREE.Object3D.call(this);
  var d = new THREE.PerspectiveCamera(90, 1, a, b);
  d.up.set(0, -1, 0);
  d.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(d);
  var e = new THREE.PerspectiveCamera(90, 1, a, b);
  e.up.set(0, -1, 0);
  e.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(e);
  var f = new THREE.PerspectiveCamera(90, 1, a, b);
  f.up.set(0, 0, 1);
  f.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(f);
  var g = new THREE.PerspectiveCamera(90, 1, a, b);
  g.up.set(0, 0, -1);
  g.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(g);
  var h = new THREE.PerspectiveCamera(90, 1, a, b);
  h.up.set(0, -1, 0);
  h.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(h);
  var k = new THREE.PerspectiveCamera(90, 1, a, b);
  k.up.set(0, -1, 0);
  k.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(k);
  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {format:THREE.RGBFormat, magFilter:THREE.LinearFilter, minFilter:THREE.LinearFilter});
  this.updateCubeMap = function(a, b) {
    var c = this.renderTarget, p = c.generateMipmaps;
    c.generateMipmaps = !1;
    c.activeCubeFace = 0;
    a.render(b, d, c);
    c.activeCubeFace = 1;
    a.render(b, e, c);
    c.activeCubeFace = 2;
    a.render(b, f, c);
    c.activeCubeFace = 3;
    a.render(b, g, c);
    c.activeCubeFace = 4;
    a.render(b, h, c);
    c.generateMipmaps = p;
    c.activeCubeFace = 5;
    a.render(b, k, c);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function(a, b, c, d, e, f, g) {
  THREE.Camera.call(this);
  this.fov = c;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
  this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, g);
  this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);
  this.zoom = 1;
  this.toPerspective();
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function() {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = !0;
  this.inOrthographicMode = !1;
};
THREE.CombinedCamera.prototype.toOrthographic = function() {
  var a = this.cameraP.aspect, b = (this.cameraP.near + this.cameraP.far) / 2, b = Math.tan(this.fov / 2) * b, a = 2 * b * a / 2, b = b / this.zoom, a = a / this.zoom;
  this.cameraO.left = -a;
  this.cameraO.right = a;
  this.cameraO.top = b;
  this.cameraO.bottom = -b;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = !1;
  this.inOrthographicMode = !0;
};
THREE.CombinedCamera.prototype.setSize = function(a, b) {
  this.cameraP.aspect = a / b;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
};
THREE.CombinedCamera.prototype.setFov = function(a) {
  this.fov = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {
  this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
};
THREE.CombinedCamera.prototype.setLens = function(a, b) {
  void 0 === b && (b = 24);
  var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.setFov(c);
  return c;
};
THREE.CombinedCamera.prototype.setZoom = function(a) {
  this.zoom = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.toFrontView = function() {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBackView = function() {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toLeftView = function() {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toRightView = function() {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toTopView = function() {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBottomView = function() {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.BoxGeometry = function(a, b, c, d, e, f) {
  function g(a, b, c, d, e, f, g, n) {
    var t, v = h.widthSegments, u = h.heightSegments, w = e / 2, x = f / 2, y = h.vertices.length;
    if ("x" === a && "y" === b || "y" === a && "x" === b) {
      t = "z";
    } else {
      if ("x" === a && "z" === b || "z" === a && "x" === b) {
        t = "y", u = h.depthSegments;
      } else {
        if ("z" === a && "y" === b || "y" === a && "z" === b) {
          t = "x", v = h.depthSegments;
        }
      }
    }
    var G = v + 1, z = u + 1, B = e / v, C = f / u, E = new THREE.Vector3;
    E[t] = 0 < g ? 1 : -1;
    for (e = 0;e < z;e++) {
      for (f = 0;f < G;f++) {
        var H = new THREE.Vector3;
        H[a] = (f * B - w) * c;
        H[b] = (e * C - x) * d;
        H[t] = g;
        h.vertices.push(H);
      }
    }
    for (e = 0;e < u;e++) {
      for (f = 0;f < v;f++) {
        x = f + G * e, a = f + G * (e + 1), b = f + 1 + G * (e + 1), c = f + 1 + G * e, d = new THREE.Vector2(f / v, 1 - e / u), g = new THREE.Vector2(f / v, 1 - (e + 1) / u), t = new THREE.Vector2((f + 1) / v, 1 - (e + 1) / u), w = new THREE.Vector2((f + 1) / v, 1 - e / u), x = new THREE.Face3(x + y, a + y, c + y), x.normal.copy(E), x.vertexNormals.push(E.clone(), E.clone(), E.clone()), x.materialIndex = n, h.faces.push(x), h.faceVertexUvs[0].push([d, g, w]), x = new THREE.Face3(a + y, b + y, c + 
        y), x.normal.copy(E), x.vertexNormals.push(E.clone(), E.clone(), E.clone()), x.materialIndex = n, h.faces.push(x), h.faceVertexUvs[0].push([g.clone(), t, w.clone()]);
      }
    }
  }
  THREE.Geometry.call(this);
  var h = this;
  this.width = a;
  this.height = b;
  this.depth = c;
  this.widthSegments = d || 1;
  this.heightSegments = e || 1;
  this.depthSegments = f || 1;
  a = this.width / 2;
  b = this.height / 2;
  c = this.depth / 2;
  g("z", "y", -1, -1, this.depth, this.height, a, 0);
  g("z", "y", 1, -1, this.depth, this.height, -a, 1);
  g("x", "z", 1, 1, this.width, this.depth, b, 2);
  g("x", "z", 1, -1, this.width, this.depth, -b, 3);
  g("x", "y", 1, -1, this.width, this.height, c, 4);
  g("x", "y", -1, -1, this.width, this.height, -c, 5);
  this.computeCentroids();
  this.mergeVertices();
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function(a, b, c, d) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
  this.thetaStart = c = void 0 !== c ? c : 0;
  this.thetaLength = d = void 0 !== d ? d : 2 * Math.PI;
  var e, f = [];
  e = new THREE.Vector3;
  var g = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(e);
  f.push(g);
  for (e = 0;e <= b;e++) {
    var h = new THREE.Vector3, k = c + e / b * d;
    h.x = a * Math.cos(k);
    h.y = a * Math.sin(k);
    this.vertices.push(h);
    f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
  }
  c = new THREE.Vector3(0, 0, 1);
  for (e = 1;e <= b;e++) {
    this.faces.push(new THREE.Face3(e, e + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([f[e].clone(), f[e + 1].clone(), g.clone()]);
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function(a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.radiusTop = a = void 0 !== a ? a : 20;
  this.radiusBottom = b = void 0 !== b ? b : 20;
  this.height = c = void 0 !== c ? c : 100;
  this.radialSegments = d = d || 8;
  this.heightSegments = e = e || 1;
  this.openEnded = f = void 0 !== f ? f : !1;
  var g = c / 2, h, k, l = [], m = [];
  for (k = 0;k <= e;k++) {
    var q = [], p = [], r = k / e, s = r * (b - a) + a;
    for (h = 0;h <= d;h++) {
      var n = h / d, t = new THREE.Vector3;
      t.x = s * Math.sin(n * Math.PI * 2);
      t.y = -r * c + g;
      t.z = s * Math.cos(n * Math.PI * 2);
      this.vertices.push(t);
      q.push(this.vertices.length - 1);
      p.push(new THREE.Vector2(n, 1 - r));
    }
    l.push(q);
    m.push(p);
  }
  c = (b - a) / c;
  for (h = 0;h < d;h++) {
    for (0 !== a ? (q = this.vertices[l[0][h]].clone(), p = this.vertices[l[0][h + 1]].clone()) : (q = this.vertices[l[1][h]].clone(), p = this.vertices[l[1][h + 1]].clone()), q.setY(Math.sqrt(q.x * q.x + q.z * q.z) * c).normalize(), p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * c).normalize(), k = 0;k < e;k++) {
      var r = l[k][h], s = l[k + 1][h], n = l[k + 1][h + 1], t = l[k][h + 1], v = q.clone(), u = q.clone(), w = p.clone(), x = p.clone(), y = m[k][h].clone(), G = m[k + 1][h].clone(), z = m[k + 1][h + 1].clone(), B = m[k][h + 1].clone();
      this.faces.push(new THREE.Face3(r, s, t, [v, u, x]));
      this.faceVertexUvs[0].push([y, G, B]);
      this.faces.push(new THREE.Face3(s, n, t, [u.clone(), w, x.clone()]));
      this.faceVertexUvs[0].push([G.clone(), z, B.clone()]);
    }
  }
  if (!1 === f && 0 < a) {
    for (this.vertices.push(new THREE.Vector3(0, g, 0)), h = 0;h < d;h++) {
      r = l[0][h], s = l[0][h + 1], n = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), u = new THREE.Vector3(0, 1, 0), w = new THREE.Vector3(0, 1, 0), y = m[0][h].clone(), G = m[0][h + 1].clone(), z = new THREE.Vector2(G.x, 0), this.faces.push(new THREE.Face3(r, s, n, [v, u, w])), this.faceVertexUvs[0].push([y, G, z]);
    }
  }
  if (!1 === f && 0 < b) {
    for (this.vertices.push(new THREE.Vector3(0, -g, 0)), h = 0;h < d;h++) {
      r = l[k][h + 1], s = l[k][h], n = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), u = new THREE.Vector3(0, -1, 0), w = new THREE.Vector3(0, -1, 0), y = m[k][h + 1].clone(), G = m[k][h].clone(), z = new THREE.Vector2(G.x, 1), this.faces.push(new THREE.Face3(r, s, n, [v, u, w])), this.faceVertexUvs[0].push([y, G, z]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function(a, b) {
  "undefined" !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals());
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
  for (var c = a.length, d = 0;d < c;d++) {
    this.addShape(a[d], b);
  }
};
THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
  function c(a, b, c) {
    b || console.log("die");
    return b.clone().multiplyScalar(c).add(a);
  }
  function d(a, b, c) {
    var d = THREE.Math.sign, e = 1, e = a.x - b.x, f = a.y - b.y, g = c.x - a.x, h = c.y - a.y, k = e * e + f * f;
    if (1E-10 < Math.abs(e * h - f * g)) {
      var l = Math.sqrt(k), d = Math.sqrt(g * g + h * h), k = b.x - f / l;
      b = b.y + e / l;
      g = ((c.x - h / d - k) * h - (c.y + g / d - b) * g) / (e * h - f * g);
      c = k + e * g - a.x;
      a = b + f * g - a.y;
      e = c * c + a * a;
      if (2 >= e) {
        return new THREE.Vector2(c, a);
      }
      e = Math.sqrt(e / 2);
    } else {
      a = !1, 1E-10 < e ? 1E-10 < g && (a = !0) : -1E-10 > e ? -1E-10 > g && (a = !0) : d(f) == d(h) && (a = !0), a ? (c = -f, a = e, e = Math.sqrt(k)) : (c = e, a = f, e = Math.sqrt(k / 2));
    }
    return new THREE.Vector2(c / e, a / e);
  }
  function e(c, d) {
    var e, f;
    for (A = c.length;0 <= --A;) {
      e = A;
      f = A - 1;
      0 > f && (f = c.length - 1);
      for (var g = 0, h = r + 2 * m, g = 0;g < h;g++) {
        var k = T * g, l = T * (g + 1), n = d + e + k, k = d + f + k, p = d + f + l, l = d + e + l, q = c, s = g, t = h, v = e, x = f, n = n + N, k = k + N, p = p + N, l = l + N;
        H.faces.push(new THREE.Face3(n, k, l, null, null, u));
        H.faces.push(new THREE.Face3(k, p, l, null, null, u));
        n = w.generateSideWallUV(H, a, q, b, n, k, p, l, s, t, v, x);
        H.faceVertexUvs[0].push([n[0], n[1], n[3]]);
        H.faceVertexUvs[0].push([n[1], n[2], n[3]]);
      }
    }
  }
  function f(a, b, c) {
    H.vertices.push(new THREE.Vector3(a, b, c));
  }
  function g(c, d, e, f) {
    c += N;
    d += N;
    e += N;
    H.faces.push(new THREE.Face3(c, d, e, null, null, v));
    c = f ? w.generateBottomUV(H, a, b, c, d, e) : w.generateTopUV(H, a, b, c, d, e);
    H.faceVertexUvs[0].push(c);
  }
  var h = void 0 !== b.amount ? b.amount : 100, k = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : k - 2, m = void 0 !== b.bevelSegments ? b.bevelSegments : 3, q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, p = void 0 !== b.curveSegments ? b.curveSegments : 12, r = void 0 !== b.steps ? b.steps : 1, s = b.extrudePath, n, t = !1, v = b.material, u = b.extrudeMaterial, w = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, 
  x, y, G, z;
  s && (n = s.getSpacedPoints(r), t = !0, q = !1, x = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(s, r, !1), y = new THREE.Vector3, G = new THREE.Vector3, z = new THREE.Vector3);
  q || (l = k = m = 0);
  var B, C, E, H = this, N = this.vertices.length, s = a.extractPoints(p), p = s.shape, D = s.holes;
  if (s = !THREE.Shape.Utils.isClockWise(p)) {
    p = p.reverse();
    C = 0;
    for (E = D.length;C < E;C++) {
      B = D[C], THREE.Shape.Utils.isClockWise(B) && (D[C] = B.reverse());
    }
    s = !1;
  }
  var K = THREE.Shape.Utils.triangulateShape(p, D), M = p;
  C = 0;
  for (E = D.length;C < E;C++) {
    B = D[C], p = p.concat(B);
  }
  var I, F, J, Q, L, T = p.length, P, U = K.length, s = [], A = 0;
  J = M.length;
  I = J - 1;
  for (F = A + 1;A < J;A++, I++, F++) {
    I === J && (I = 0), F === J && (F = 0), s[A] = d(M[A], M[I], M[F]);
  }
  var S = [], V, R = s.concat();
  C = 0;
  for (E = D.length;C < E;C++) {
    B = D[C];
    V = [];
    A = 0;
    J = B.length;
    I = J - 1;
    for (F = A + 1;A < J;A++, I++, F++) {
      I === J && (I = 0), F === J && (F = 0), V[A] = d(B[A], B[I], B[F]);
    }
    S.push(V);
    R = R.concat(V);
  }
  for (I = 0;I < m;I++) {
    J = I / m;
    Q = k * (1 - J);
    F = l * Math.sin(J * Math.PI / 2);
    A = 0;
    for (J = M.length;A < J;A++) {
      L = c(M[A], s[A], F), f(L.x, L.y, -Q);
    }
    C = 0;
    for (E = D.length;C < E;C++) {
      for (B = D[C], V = S[C], A = 0, J = B.length;A < J;A++) {
        L = c(B[A], V[A], F), f(L.x, L.y, -Q);
      }
    }
  }
  F = l;
  for (A = 0;A < T;A++) {
    L = q ? c(p[A], R[A], F) : p[A], t ? (G.copy(x.normals[0]).multiplyScalar(L.x), y.copy(x.binormals[0]).multiplyScalar(L.y), z.copy(n[0]).add(G).add(y), f(z.x, z.y, z.z)) : f(L.x, L.y, 0);
  }
  for (J = 1;J <= r;J++) {
    for (A = 0;A < T;A++) {
      L = q ? c(p[A], R[A], F) : p[A], t ? (G.copy(x.normals[J]).multiplyScalar(L.x), y.copy(x.binormals[J]).multiplyScalar(L.y), z.copy(n[J]).add(G).add(y), f(z.x, z.y, z.z)) : f(L.x, L.y, h / r * J);
    }
  }
  for (I = m - 1;0 <= I;I--) {
    J = I / m;
    Q = k * (1 - J);
    F = l * Math.sin(J * Math.PI / 2);
    A = 0;
    for (J = M.length;A < J;A++) {
      L = c(M[A], s[A], F), f(L.x, L.y, h + Q);
    }
    C = 0;
    for (E = D.length;C < E;C++) {
      for (B = D[C], V = S[C], A = 0, J = B.length;A < J;A++) {
        L = c(B[A], V[A], F), t ? f(L.x, L.y + n[r - 1].y, n[r - 1].x + Q) : f(L.x, L.y, h + Q);
      }
    }
  }
  (function() {
    if (q) {
      var a;
      a = 0 * T;
      for (A = 0;A < U;A++) {
        P = K[A], g(P[2] + a, P[1] + a, P[0] + a, !0);
      }
      a = r + 2 * m;
      a *= T;
      for (A = 0;A < U;A++) {
        P = K[A], g(P[0] + a, P[1] + a, P[2] + a, !1);
      }
    } else {
      for (A = 0;A < U;A++) {
        P = K[A], g(P[2], P[1], P[0], !0);
      }
      for (A = 0;A < U;A++) {
        P = K[A], g(P[0] + T * r, P[1] + T * r, P[2] + T * r, !1);
      }
    }
  })();
  (function() {
    var a = 0;
    e(M, a);
    a += M.length;
    C = 0;
    for (E = D.length;C < E;C++) {
      B = D[C], e(B, a), a += B.length;
    }
  })();
};
THREE.ExtrudeGeometry.WorldUVGenerator = {generateTopUV:function(a, b, c, d, e, f) {
  b = a.vertices[e].x;
  e = a.vertices[e].y;
  c = a.vertices[f].x;
  f = a.vertices[f].y;
  return[new THREE.Vector2(a.vertices[d].x, a.vertices[d].y), new THREE.Vector2(b, e), new THREE.Vector2(c, f)];
}, generateBottomUV:function(a, b, c, d, e, f) {
  return this.generateTopUV(a, b, c, d, e, f);
}, generateSideWallUV:function(a, b, c, d, e, f, g, h, k, l, m, q) {
  b = a.vertices[e].x;
  c = a.vertices[e].y;
  e = a.vertices[e].z;
  d = a.vertices[f].x;
  k = a.vertices[f].y;
  f = a.vertices[f].z;
  l = a.vertices[g].x;
  m = a.vertices[g].y;
  g = a.vertices[g].z;
  q = a.vertices[h].x;
  var p = a.vertices[h].y;
  a = a.vertices[h].z;
  return 0.01 > Math.abs(c - k) ? [new THREE.Vector2(b, 1 - e), new THREE.Vector2(d, 1 - f), new THREE.Vector2(l, 1 - g), new THREE.Vector2(q, 1 - a)] : [new THREE.Vector2(c, 1 - e), new THREE.Vector2(k, 1 - f), new THREE.Vector2(m, 1 - g), new THREE.Vector2(p, 1 - a)];
}};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2;
THREE.ShapeGeometry = function(a, b) {
  THREE.Geometry.call(this);
  !1 === a instanceof Array && (a = [a]);
  this.shapebb = a[a.length - 1].getBoundingBox();
  this.addShapeList(a, b);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
  for (var c = 0, d = a.length;c < d;c++) {
    this.addShape(a[c], b);
  }
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function(a, b) {
  void 0 === b && (b = {});
  var c = b.material, d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, e, f, g, h = this.vertices.length;
  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
  var k = e.shape, l = e.holes;
  if (!THREE.Shape.Utils.isClockWise(k)) {
    for (k = k.reverse(), e = 0, f = l.length;e < f;e++) {
      g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());
    }
  }
  var m = THREE.Shape.Utils.triangulateShape(k, l);
  e = 0;
  for (f = l.length;e < f;e++) {
    g = l[e], k = k.concat(g);
  }
  l = k.length;
  f = m.length;
  for (e = 0;e < l;e++) {
    g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
  }
  for (e = 0;e < f;e++) {
    l = m[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, k, g, l));
  }
};
THREE.LatheGeometry = function(a, b, c, d) {
  THREE.Geometry.call(this);
  b = b || 12;
  c = c || 0;
  d = d || 2 * Math.PI;
  for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b;g <= h;g++) {
    for (var k = c + g * f * d, l = Math.cos(k), m = Math.sin(k), k = 0, q = a.length;k < q;k++) {
      var p = a[k], r = new THREE.Vector3;
      r.x = l * p.x - m * p.y;
      r.y = m * p.x + l * p.y;
      r.z = p.z;
      this.vertices.push(r);
    }
  }
  c = a.length;
  g = 0;
  for (h = b;g < h;g++) {
    for (k = 0, q = a.length - 1;k < q;k++) {
      b = m = k + c * g;
      d = m + c;
      var l = m + 1 + c, m = m + 1, p = g * f, r = k * e, s = p + f, n = r + e;
      this.faces.push(new THREE.Face3(b, d, m));
      this.faceVertexUvs[0].push([new THREE.Vector2(p, r), new THREE.Vector2(s, r), new THREE.Vector2(p, n)]);
      this.faces.push(new THREE.Face3(d, l, m));
      this.faceVertexUvs[0].push([new THREE.Vector2(s, r), new THREE.Vector2(s, n), new THREE.Vector2(p, n)]);
    }
  }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function(a, b, c, d) {
  THREE.Geometry.call(this);
  this.width = a;
  this.height = b;
  this.widthSegments = c || 1;
  this.heightSegments = d || 1;
  var e = a / 2, f = b / 2;
  c = this.widthSegments;
  d = this.heightSegments;
  var g = c + 1, h = d + 1, k = this.width / c, l = this.height / d, m = new THREE.Vector3(0, 0, 1);
  for (a = 0;a < h;a++) {
    for (b = 0;b < g;b++) {
      this.vertices.push(new THREE.Vector3(b * k - e, -(a * l - f), 0));
    }
  }
  for (a = 0;a < d;a++) {
    for (b = 0;b < c;b++) {
      var q = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), p = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), r = new THREE.Vector2((b + 1) / c, 1 - a / d), q = new THREE.Face3(q, e, h);
      q.normal.copy(m);
      q.vertexNormals.push(m.clone(), m.clone(), m.clone());
      this.faces.push(q);
      this.faceVertexUvs[0].push([k, l, r]);
      q = new THREE.Face3(e, f, h);
      q.normal.copy(m);
      q.vertexNormals.push(m.clone(), m.clone(), m.clone());
      this.faces.push(q);
      this.faceVertexUvs[0].push([l.clone(), p, r.clone()]);
    }
  }
  this.computeCentroids();
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function(a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  a = a || 0;
  b = b || 50;
  e = void 0 !== e ? e : 0;
  f = void 0 !== f ? f : 2 * Math.PI;
  c = void 0 !== c ? Math.max(3, c) : 8;
  d = void 0 !== d ? Math.max(3, d) : 8;
  var g, h = [], k = a, l = (b - a) / d;
  for (a = 0;a <= d;a++) {
    for (g = 0;g <= c;g++) {
      var m = new THREE.Vector3, q = e + g / c * f;
      m.x = k * Math.cos(q);
      m.y = k * Math.sin(q);
      this.vertices.push(m);
      h.push(new THREE.Vector2((m.x / b + 1) / 2, (m.y / b + 1) / 2));
    }
    k += l;
  }
  b = new THREE.Vector3(0, 0, 1);
  for (a = 0;a < d;a++) {
    for (e = a * c, g = 0;g <= c;g++) {
      q = g + e, f = q + a, l = q + c + a, m = q + c + 1 + a, this.faces.push(new THREE.Face3(f, l, m, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[m].clone()]), f = q + a, l = q + c + 1 + a, m = q + 1 + a, this.faces.push(new THREE.Face3(f, l, m, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[m].clone()]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, k);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
  this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
  this.phiStart = d = void 0 !== d ? d : 0;
  this.phiLength = e = void 0 !== e ? e : 2 * Math.PI;
  this.thetaStart = f = void 0 !== f ? f : 0;
  this.thetaLength = g = void 0 !== g ? g : Math.PI;
  var h, k, l = [], m = [];
  for (k = 0;k <= c;k++) {
    var q = [], p = [];
    for (h = 0;h <= b;h++) {
      var r = h / b, s = k / c, n = new THREE.Vector3;
      n.x = -a * Math.cos(d + r * e) * Math.sin(f + s * g);
      n.y = a * Math.cos(f + s * g);
      n.z = a * Math.sin(d + r * e) * Math.sin(f + s * g);
      this.vertices.push(n);
      q.push(this.vertices.length - 1);
      p.push(new THREE.Vector2(r, 1 - s));
    }
    l.push(q);
    m.push(p);
  }
  for (k = 0;k < this.heightSegments;k++) {
    for (h = 0;h < this.widthSegments;h++) {
      b = l[k][h + 1];
      c = l[k][h];
      d = l[k + 1][h];
      e = l[k + 1][h + 1];
      f = this.vertices[b].clone().normalize();
      g = this.vertices[c].clone().normalize();
      var q = this.vertices[d].clone().normalize(), p = this.vertices[e].clone().normalize(), r = m[k][h + 1].clone(), s = m[k][h].clone(), n = m[k + 1][h].clone(), t = m[k + 1][h + 1].clone();
      Math.abs(this.vertices[b].y) === this.radius ? (r.x = (r.x + s.x) / 2, this.faces.push(new THREE.Face3(b, d, e, [f, q, p])), this.faceVertexUvs[0].push([r, n, t])) : Math.abs(this.vertices[d].y) === this.radius ? (n.x = (n.x + t.x) / 2, this.faces.push(new THREE.Face3(b, c, d, [f, g, q])), this.faceVertexUvs[0].push([r, s, n])) : (this.faces.push(new THREE.Face3(b, c, e, [f, g, p])), this.faceVertexUvs[0].push([r, s, t]), this.faces.push(new THREE.Face3(c, d, e, [g.clone(), q, p.clone()])), 
      this.faceVertexUvs[0].push([s.clone(), n, t.clone()]));
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function(a, b) {
  b = b || {};
  var c = THREE.FontUtils.generateShapes(a, b);
  b.amount = void 0 !== b.height ? b.height : 50;
  void 0 === b.bevelThickness && (b.bevelThickness = 10);
  void 0 === b.bevelSize && (b.bevelSize = 8);
  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
  THREE.ExtrudeGeometry.call(this, c, b);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function(a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.radius = a || 100;
  this.tube = b || 40;
  this.radialSegments = c || 8;
  this.tubularSegments = d || 6;
  this.arc = e || 2 * Math.PI;
  e = new THREE.Vector3;
  a = [];
  b = [];
  for (c = 0;c <= this.radialSegments;c++) {
    for (d = 0;d <= this.tubularSegments;d++) {
      var f = d / this.tubularSegments * this.arc, g = c / this.radialSegments * Math.PI * 2;
      e.x = this.radius * Math.cos(f);
      e.y = this.radius * Math.sin(f);
      var h = new THREE.Vector3;
      h.x = (this.radius + this.tube * Math.cos(g)) * Math.cos(f);
      h.y = (this.radius + this.tube * Math.cos(g)) * Math.sin(f);
      h.z = this.tube * Math.sin(g);
      this.vertices.push(h);
      a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
      b.push(h.clone().sub(e).normalize());
    }
  }
  for (c = 1;c <= this.radialSegments;c++) {
    for (d = 1;d <= this.tubularSegments;d++) {
      e = (this.tubularSegments + 1) * c + d - 1;
      var f = (this.tubularSegments + 1) * (c - 1) + d - 1, g = (this.tubularSegments + 1) * (c - 1) + d, h = (this.tubularSegments + 1) * c + d, k = new THREE.Face3(e, f, h, [b[e].clone(), b[f].clone(), b[h].clone()]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([a[e].clone(), a[f].clone(), a[h].clone()]);
      k = new THREE.Face3(f, g, h, [b[f].clone(), b[g].clone(), b[h].clone()]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([a[f].clone(), a[g].clone(), a[h].clone()]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function(a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.path = a;
  this.segments = b || 64;
  this.radius = c || 1;
  this.radialSegments = d || 8;
  this.closed = e || !1;
  this.grid = [];
  var f, g;
  d = this.segments + 1;
  var h, k, l;
  e = new THREE.Vector3;
  var m, q;
  b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);
  m = b.normals;
  q = b.binormals;
  this.tangents = b.tangents;
  this.normals = m;
  this.binormals = q;
  for (b = 0;b < d;b++) {
    for (this.grid[b] = [], c = b / (d - 1), l = a.getPointAt(c), f = m[b], g = q[b], c = 0;c < this.radialSegments;c++) {
      h = c / this.radialSegments * 2 * Math.PI, k = -this.radius * Math.cos(h), h = this.radius * Math.sin(h), e.copy(l), e.x += k * f.x + h * g.x, e.y += k * f.y + h * g.y, e.z += k * f.z + h * g.z, this.grid[b][c] = this.vertices.push(new THREE.Vector3(e.x, e.y, e.z)) - 1;
    }
  }
  for (b = 0;b < this.segments;b++) {
    for (c = 0;c < this.radialSegments;c++) {
      e = this.closed ? (b + 1) % this.segments : b + 1, m = (c + 1) % this.radialSegments, a = this.grid[b][c], d = this.grid[e][c], e = this.grid[e][m], m = this.grid[b][m], q = new THREE.Vector2(b / this.segments, c / this.radialSegments), f = new THREE.Vector2((b + 1) / this.segments, c / this.radialSegments), g = new THREE.Vector2((b + 1) / this.segments, (c + 1) / this.radialSegments), k = new THREE.Vector2(b / this.segments, (c + 1) / this.radialSegments), this.faces.push(new THREE.Face3(a, 
      d, m)), this.faceVertexUvs[0].push([q, f, k]), this.faces.push(new THREE.Face3(d, e, m)), this.faceVertexUvs[0].push([f.clone(), g, k.clone()]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
  new THREE.Vector3;
  var d = new THREE.Vector3;
  new THREE.Vector3;
  var e = [], f = [], g = [], h = new THREE.Vector3, k = new THREE.Matrix4;
  b += 1;
  var l, m, q;
  this.tangents = e;
  this.normals = f;
  this.binormals = g;
  for (l = 0;l < b;l++) {
    m = l / (b - 1), e[l] = a.getTangentAt(m), e[l].normalize();
  }
  f[0] = new THREE.Vector3;
  g[0] = new THREE.Vector3;
  a = Number.MAX_VALUE;
  l = Math.abs(e[0].x);
  m = Math.abs(e[0].y);
  q = Math.abs(e[0].z);
  l <= a && (a = l, d.set(1, 0, 0));
  m <= a && (a = m, d.set(0, 1, 0));
  q <= a && d.set(0, 0, 1);
  h.crossVectors(e[0], d).normalize();
  f[0].crossVectors(e[0], h);
  g[0].crossVectors(e[0], f[0]);
  for (l = 1;l < b;l++) {
    f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 1E-4 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
  }
  if (c) {
    for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1;l < b;l++) {
      f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l]);
    }
  }
};
THREE.ParametricGeometry = function(a, b, c) {
  THREE.Geometry.call(this);
  var d = this.vertices, e = this.faces, f = this.faceVertexUvs[0], g, h, k, l, m = b + 1;
  for (g = 0;g <= c;g++) {
    for (l = g / c, h = 0;h <= b;h++) {
      k = h / b, k = a(k, l), d.push(k);
    }
  }
  var q, p, r, s;
  for (g = 0;g < c;g++) {
    for (h = 0;h < b;h++) {
      a = g * m + h, d = g * m + h + 1, l = (g + 1) * m + h + 1, k = (g + 1) * m + h, q = new THREE.Vector2(h / b, g / c), p = new THREE.Vector2((h + 1) / b, g / c), r = new THREE.Vector2((h + 1) / b, (g + 1) / c), s = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([q, p, s]), e.push(new THREE.Face3(d, l, k)), f.push([p.clone(), r, s.clone()]);
    }
  }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function(a) {
  a = a || 1;
  var b = new THREE.Geometry;
  b.vertices.push(new THREE.Vector3, new THREE.Vector3(a, 0, 0), new THREE.Vector3, new THREE.Vector3(0, a, 0), new THREE.Vector3, new THREE.Vector3(0, 0, a));
  b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  a = new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});
  THREE.Line.call(this, b, a, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function(a, b, c, d, e, f) {
  THREE.Object3D.call(this);
  void 0 === d && (d = 16776960);
  void 0 === c && (c = 1);
  void 0 === e && (e = 0.2 * c);
  void 0 === f && (f = 0.2 * e);
  this.position = b;
  b = new THREE.Geometry;
  b.vertices.push(new THREE.Vector3(0, 0, 0));
  b.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(b, new THREE.LineBasicMaterial({color:d}));
  this.line.matrixAutoUpdate = !1;
  this.add(this.line);
  b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
  b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0));
  this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({color:d}));
  this.cone.matrixAutoUpdate = !1;
  this.add(this.cone);
  this.setDirection(a);
  this.setLength(c, e, f);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function() {
  var a = new THREE.Vector3, b;
  return function(c) {
    0.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b));
  };
}();
THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
  void 0 === b && (b = 0.2 * a);
  void 0 === c && (c = 0.2 * b);
  this.line.scale.set(1, a, 1);
  this.line.updateMatrix();
  this.cone.scale.set(c, b, c);
  this.cone.position.y = a;
  this.cone.updateMatrix();
};
THREE.ArrowHelper.prototype.setColor = function(a) {
  this.line.material.color.setHex(a);
  this.cone.material.color.setHex(a);
};
THREE.BoxHelper = function(a) {
  var b = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(-1, -1, 1), new THREE.Vector3(1, -1, 1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, -1, -1)];
  this.vertices = b;
  var c = new THREE.Geometry;
  c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({color:16776960}), THREE.LinePieces);
  void 0 !== a && this.update(a);
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function(a) {
  var b = a.geometry;
  null === b.boundingBox && b.computeBoundingBox();
  var c = b.boundingBox.min, b = b.boundingBox.max, d = this.vertices;
  d[0].set(b.x, b.y, b.z);
  d[1].set(c.x, b.y, b.z);
  d[2].set(c.x, c.y, b.z);
  d[3].set(b.x, c.y, b.z);
  d[4].set(b.x, b.y, c.z);
  d[5].set(c.x, b.y, c.z);
  d[6].set(c.x, c.y, c.z);
  d[7].set(b.x, c.y, c.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.BoundingBoxHelper = function(a, b) {
  var c = void 0 !== b ? b : 8947848;
  this.object = a;
  this.box = new THREE.Box3;
  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({color:c, wireframe:!0}));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function() {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function(a) {
  function b(a, b, d) {
    c(a, d);
    c(b, d);
  }
  function c(a, b) {
    d.vertices.push(new THREE.Vector3);
    d.colors.push(new THREE.Color(b));
    void 0 === f[a] && (f[a] = []);
    f[a].push(d.vertices.length - 1);
  }
  var d = new THREE.Geometry, e = new THREE.LineBasicMaterial({color:16777215, vertexColors:THREE.FaceColors}), f = {};
  b("n1", "n2", 16755200);
  b("n2", "n4", 16755200);
  b("n4", "n3", 16755200);
  b("n3", "n1", 16755200);
  b("f1", "f2", 16755200);
  b("f2", "f4", 16755200);
  b("f4", "f3", 16755200);
  b("f3", "f1", 16755200);
  b("n1", "f1", 16755200);
  b("n2", "f2", 16755200);
  b("n3", "f3", 16755200);
  b("n4", "f4", 16755200);
  b("p", "n1", 16711680);
  b("p", "n2", 16711680);
  b("p", "n3", 16711680);
  b("p", "n4", 16711680);
  b("u1", "u2", 43775);
  b("u2", "u3", 43775);
  b("u3", "u1", 43775);
  b("c", "t", 16777215);
  b("p", "c", 3355443);
  b("cn1", "cn2", 3355443);
  b("cn3", "cn4", 3355443);
  b("cf1", "cf2", 3355443);
  b("cf3", "cf4", 3355443);
  THREE.Line.call(this, d, e, THREE.LinePieces);
  this.camera = a;
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.pointMap = f;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function() {
  var a = new THREE.Vector3, b = new THREE.Camera, c = new THREE.Projector;
  return function() {
    function d(d, g, h, k) {
      a.set(g, h, k);
      c.unprojectVector(a, b);
      d = e.pointMap[d];
      if (void 0 !== d) {
        for (g = 0, h = d.length;g < h;g++) {
          e.geometry.vertices[d[g]].copy(a);
        }
      }
    }
    var e = this;
    b.projectionMatrix.copy(this.camera.projectionMatrix);
    d("c", 0, 0, -1);
    d("t", 0, 0, 1);
    d("n1", -1, -1, -1);
    d("n2", 1, -1, -1);
    d("n3", -1, 1, -1);
    d("n4", 1, 1, -1);
    d("f1", -1, -1, 1);
    d("f2", 1, -1, 1);
    d("f3", -1, 1, 1);
    d("f4", 1, 1, 1);
    d("u1", 0.7, 1.1, -1);
    d("u2", -0.7, 1.1, -1);
    d("u3", 0, 2, -1);
    d("cf1", -1, 0, 1);
    d("cf2", 1, 0, 1);
    d("cf3", 0, -1, 1);
    d("cf4", 0, 1, 1);
    d("cn1", -1, 0, -1);
    d("cn2", 1, 0, -1);
    d("cn3", 0, -1, -1);
    d("cn4", 0, 1, -1);
    this.geometry.verticesNeedUpdate = !0;
  };
}();
THREE.DirectionalLightHelper = function(a, b) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  b = b || 1;
  var c = new THREE.PlaneGeometry(b, b), d = new THREE.MeshBasicMaterial({wireframe:!0, fog:!1});
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Mesh(c, d);
  this.add(this.lightPlane);
  c = new THREE.Geometry;
  c.vertices.push(new THREE.Vector3);
  c.vertices.push(new THREE.Vector3);
  d = new THREE.LineBasicMaterial({fog:!1});
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(c, d);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function() {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function() {
  var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
  return function() {
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    c.subVectors(b, a);
    this.lightPlane.lookAt(c);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(c);
    this.targetLine.geometry.verticesNeedUpdate = !0;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.EdgesHelper = function(a, b) {
  var c = void 0 !== b ? b : 16777215, d = [0, 0], e = {}, f = function(a, b) {
    return a - b;
  }, g = ["a", "b", "c"], h = new THREE.BufferGeometry, k = a.geometry.clone();
  k.mergeVertices();
  k.computeFaceNormals();
  for (var l = k.vertices, k = k.faces, m = 0, q = 0, p = k.length;q < p;q++) {
    for (var r = k[q], s = 0;3 > s;s++) {
      d[0] = r[g[s]];
      d[1] = r[g[(s + 1) % 3]];
      d.sort(f);
      var n = d.toString();
      void 0 === e[n] ? (e[n] = {vert1:d[0], vert2:d[1], face1:q, face2:void 0}, m++) : e[n].face2 = q;
    }
  }
  h.addAttribute("position", Float32Array, 2 * m, 3);
  d = h.attributes.position.array;
  f = 0;
  for (n in e) {
    if (g = e[n], void 0 === g.face2 || 0.9999 > k[g.face1].normal.dot(k[g.face2].normal)) {
      m = l[g.vert1], d[f++] = m.x, d[f++] = m.y, d[f++] = m.z, m = l[g.vert2], d[f++] = m.x, d[f++] = m.y, d[f++] = m.z;
    }
  }
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({color:c}), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  a = void 0 !== c ? c : 16776960;
  d = void 0 !== d ? d : 1;
  b = new THREE.Geometry;
  c = 0;
  for (var e = this.object.geometry.faces.length;c < e;c++) {
    b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3);
  }
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({color:a, linewidth:d}), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3;
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function(a) {
  var b = new THREE.Vector3;
  return function(a) {
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    a = this.geometry.vertices;
    for (var d = this.object.geometry.faces, e = this.object.matrixWorld, f = 0, g = d.length;f < g;f++) {
      var h = d[f];
      b.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
      var k = 2 * f;
      a[k].copy(h.centroid).applyMatrix4(e);
      a[k + 1].addVectors(a[k], b);
    }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.GridHelper = function(a, b) {
  var c = new THREE.Geometry, d = new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var e = -a;e <= a;e += b) {
    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
    var f = 0 === e ? this.color1 : this.color2;
    c.colors.push(f, f, f, f);
  }
  THREE.Line.call(this, c, d, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function(a, b) {
  this.color1.set(a);
  this.color2.set(b);
  this.geometry.colorsNeedUpdate = !0;
};
THREE.HemisphereLightHelper = function(a, b, c, d) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.colors = [new THREE.Color, new THREE.Color];
  a = new THREE.SphereGeometry(b, 4, 2);
  a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
  for (b = 0;8 > b;b++) {
    a.faces[b].color = this.colors[4 > b ? 0 : 1];
  }
  b = new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors, wireframe:!0});
  this.lightSphere = new THREE.Mesh(a, b);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function() {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function() {
  var a = new THREE.Vector3;
  return function() {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = !0;
  };
}();
THREE.PointLightHelper = function(a, b) {
  this.light = a;
  this.light.updateMatrixWorld();
  var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({wireframe:!0, fog:!1});
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, c, d);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = !1;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function() {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SpotLightHelper = function(a) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
  a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -0.5, 0));
  a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
  var b = new THREE.MeshBasicMaterial({wireframe:!0, fog:!1});
  this.cone = new THREE.Mesh(a, b);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function() {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function() {
  var a = new THREE.Vector3, b = new THREE.Vector3;
  return function() {
    var c = this.light.distance ? this.light.distance : 1E4, d = c * Math.tan(this.light.angle);
    this.cone.scale.set(d, d, c);
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(b.sub(a));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 16711680;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry;
  a = a.geometry.faces;
  for (var e = 0, f = a.length;e < f;e++) {
    for (var g = 0, h = a[e].vertexNormals.length;g < h;g++) {
      c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    }
  }
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({color:b, linewidth:d}), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3;
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function(a) {
  var b = new THREE.Vector3;
  return function(a) {
    a = ["a", "b", "c", "d"];
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length;k < l;k++) {
      for (var m = f[k], q = 0, p = m.vertexNormals.length;q < p;q++) {
        var r = m.vertexNormals[q];
        d[h].copy(e[m[a[q]]]).applyMatrix4(g);
        b.copy(r).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.VertexTangentsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 255;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry;
  a = a.geometry.faces;
  for (var e = 0, f = a.length;e < f;e++) {
    for (var g = 0, h = a[e].vertexTangents.length;g < h;g++) {
      c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
    }
  }
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({color:b, linewidth:d}), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function(a) {
  var b = new THREE.Vector3;
  return function(a) {
    a = ["a", "b", "c", "d"];
    this.object.updateMatrixWorld(!0);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length;k < l;k++) {
      for (var m = f[k], q = 0, p = m.vertexTangents.length;q < p;q++) {
        var r = m.vertexTangents[q];
        d[h].copy(e[m[a[q]]]).applyMatrix4(g);
        b.copy(r).transformDirection(g).multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.WireframeHelper = function(a, b) {
  var c = void 0 !== b ? b : 16777215, d = [0, 0], e = {}, f = function(a, b) {
    return a - b;
  }, g = ["a", "b", "c"], h = new THREE.BufferGeometry;
  if (a.geometry instanceof THREE.Geometry) {
    for (var k = a.geometry.vertices, l = a.geometry.faces, m = 0, q = new Uint32Array(6 * l.length), p = 0, r = l.length;p < r;p++) {
      for (var s = l[p], n = 0;3 > n;n++) {
        d[0] = s[g[n]];
        d[1] = s[g[(n + 1) % 3]];
        d.sort(f);
        var t = d.toString();
        void 0 === e[t] && (q[2 * m] = d[0], q[2 * m + 1] = d[1], e[t] = !0, m++);
      }
    }
    h.addAttribute("position", Float32Array, 2 * m, 3);
    d = h.attributes.position.array;
    p = 0;
    for (r = m;p < r;p++) {
      for (n = 0;2 > n;n++) {
        m = k[q[2 * p + n]], g = 6 * p + 3 * n, d[g + 0] = m.x, d[g + 1] = m.y, d[g + 2] = m.z;
      }
    }
  } else {
    if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
      for (var k = a.geometry.attributes.position.array, r = a.geometry.attributes.index.array, l = a.geometry.offsets, m = 0, q = new Uint32Array(2 * r.length), s = 0, v = l.length;s < v;++s) {
        for (var n = l[s].start, t = l[s].count, g = l[s].index, p = n, u = n + t;p < u;p += 3) {
          for (n = 0;3 > n;n++) {
            d[0] = g + r[p + n], d[1] = g + r[p + (n + 1) % 3], d.sort(f), t = d.toString(), void 0 === e[t] && (q[2 * m] = d[0], q[2 * m + 1] = d[1], e[t] = !0, m++);
          }
        }
      }
      h.addAttribute("position", Float32Array, 2 * m, 3);
      d = h.attributes.position.array;
      p = 0;
      for (r = m;p < r;p++) {
        for (n = 0;2 > n;n++) {
          g = 6 * p + 3 * n, m = 3 * q[2 * p + n], d[g + 0] = k[m], d[g + 1] = k[m + 1], d[g + 2] = k[m + 2];
        }
      }
    } else {
      if (a.geometry instanceof THREE.BufferGeometry) {
        for (k = a.geometry.attributes.position.array, m = k.length / 3, q = m / 3, h.addAttribute("position", Float32Array, 2 * m, 3), d = h.attributes.position.array, p = 0, r = q;p < r;p++) {
          for (n = 0;3 > n;n++) {
            g = 18 * p + 6 * n, q = 9 * p + 3 * n, d[g + 0] = k[q], d[g + 1] = k[q + 1], d[g + 2] = k[q + 2], m = 9 * p + (n + 1) % 3 * 3, d[g + 3] = k[m], d[g + 4] = k[m + 1], d[g + 5] = k[m + 2];
          }
        }
      }
    }
  }
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({color:c}), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ShadowMapPlugin = function() {
  var a, b, c, d, e, f, g = new THREE.Frustum, h = new THREE.Matrix4, k = new THREE.Vector3, l = new THREE.Vector3, m = new THREE.Vector3;
  this.init = function(g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h});
    d = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, morphTargets:!0});
    e = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, skinning:!0});
    f = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, morphTargets:!0, skinning:!0});
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function(a, c) {
    b.shadowMapEnabled && (b.shadowMapAutoUpdate && this.update(a, c));
  };
  this.update = function(q, p) {
    var r, s, n, t, v, u, w, x, y, G = [];
    t = 0;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    a.enable(a.CULL_FACE);
    a.frontFace(a.CCW);
    b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);
    b.setDepthTest(!0);
    r = 0;
    for (s = q.__lights.length;r < s;r++) {
      if (n = q.__lights[r], n.castShadow) {
        if (n instanceof THREE.DirectionalLight && n.shadowCascade) {
          for (v = 0;v < n.shadowCascadeCount;v++) {
            var z;
            if (n.shadowCascadeArray[v]) {
              z = n.shadowCascadeArray[v];
            } else {
              y = n;
              w = v;
              z = new THREE.DirectionalLight;
              z.isVirtual = !0;
              z.onlyShadow = !0;
              z.castShadow = !0;
              z.shadowCameraNear = y.shadowCameraNear;
              z.shadowCameraFar = y.shadowCameraFar;
              z.shadowCameraLeft = y.shadowCameraLeft;
              z.shadowCameraRight = y.shadowCameraRight;
              z.shadowCameraBottom = y.shadowCameraBottom;
              z.shadowCameraTop = y.shadowCameraTop;
              z.shadowCameraVisible = y.shadowCameraVisible;
              z.shadowDarkness = y.shadowDarkness;
              z.shadowBias = y.shadowCascadeBias[w];
              z.shadowMapWidth = y.shadowCascadeWidth[w];
              z.shadowMapHeight = y.shadowCascadeHeight[w];
              z.pointsWorld = [];
              z.pointsFrustum = [];
              x = z.pointsWorld;
              u = z.pointsFrustum;
              for (var B = 0;8 > B;B++) {
                x[B] = new THREE.Vector3, u[B] = new THREE.Vector3;
              }
              x = y.shadowCascadeNearZ[w];
              y = y.shadowCascadeFarZ[w];
              u[0].set(-1, -1, x);
              u[1].set(1, -1, x);
              u[2].set(-1, 1, x);
              u[3].set(1, 1, x);
              u[4].set(-1, -1, y);
              u[5].set(1, -1, y);
              u[6].set(-1, 1, y);
              u[7].set(1, 1, y);
              z.originalCamera = p;
              u = new THREE.Gyroscope;
              u.position = n.shadowCascadeOffset;
              u.add(z);
              u.add(z.target);
              p.add(u);
              n.shadowCascadeArray[v] = z;
              console.log("Created virtualLight", z);
            }
            w = n;
            x = v;
            y = w.shadowCascadeArray[x];
            y.position.copy(w.position);
            y.target.position.copy(w.target.position);
            y.lookAt(y.target);
            y.shadowCameraVisible = w.shadowCameraVisible;
            y.shadowDarkness = w.shadowDarkness;
            y.shadowBias = w.shadowCascadeBias[x];
            u = w.shadowCascadeNearZ[x];
            w = w.shadowCascadeFarZ[x];
            y = y.pointsFrustum;
            y[0].z = u;
            y[1].z = u;
            y[2].z = u;
            y[3].z = u;
            y[4].z = w;
            y[5].z = w;
            y[6].z = w;
            y[7].z = w;
            G[t] = z;
            t++;
          }
        } else {
          G[t] = n, t++;
        }
      }
    }
    r = 0;
    for (s = G.length;r < s;r++) {
      n = G[r];
      n.shadowMap || (v = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (v = THREE.NearestFilter), n.shadowMap = new THREE.WebGLRenderTarget(n.shadowMapWidth, n.shadowMapHeight, {minFilter:v, magFilter:v, format:THREE.RGBAFormat}), n.shadowMapSize = new THREE.Vector2(n.shadowMapWidth, n.shadowMapHeight), n.shadowMatrix = new THREE.Matrix4);
      if (!n.shadowCamera) {
        if (n instanceof THREE.SpotLight) {
          n.shadowCamera = new THREE.PerspectiveCamera(n.shadowCameraFov, n.shadowMapWidth / n.shadowMapHeight, n.shadowCameraNear, n.shadowCameraFar);
        } else {
          if (n instanceof THREE.DirectionalLight) {
            n.shadowCamera = new THREE.OrthographicCamera(n.shadowCameraLeft, n.shadowCameraRight, n.shadowCameraTop, n.shadowCameraBottom, n.shadowCameraNear, n.shadowCameraFar);
          } else {
            console.error("Unsupported light type for shadow");
            continue;
          }
        }
        q.add(n.shadowCamera);
        !0 === q.autoUpdate && q.updateMatrixWorld();
      }
      n.shadowCameraVisible && (!n.cameraHelper && (n.cameraHelper = new THREE.CameraHelper(n.shadowCamera), n.shadowCamera.add(n.cameraHelper)));
      if (n.isVirtual && z.originalCamera == p) {
        v = p;
        t = n.shadowCamera;
        u = n.pointsFrustum;
        y = n.pointsWorld;
        k.set(Infinity, Infinity, Infinity);
        l.set(-Infinity, -Infinity, -Infinity);
        for (w = 0;8 > w;w++) {
          x = y[w], x.copy(u[w]), THREE.ShadowMapPlugin.__projector.unprojectVector(x, v), x.applyMatrix4(t.matrixWorldInverse), x.x < k.x && (k.x = x.x), x.x > l.x && (l.x = x.x), x.y < k.y && (k.y = x.y), x.y > l.y && (l.y = x.y), x.z < k.z && (k.z = x.z), x.z > l.z && (l.z = x.z);
        }
        t.left = k.x;
        t.right = l.x;
        t.top = l.y;
        t.bottom = k.y;
        t.updateProjectionMatrix();
      }
      t = n.shadowMap;
      u = n.shadowMatrix;
      v = n.shadowCamera;
      v.position.setFromMatrixPosition(n.matrixWorld);
      m.setFromMatrixPosition(n.target.matrixWorld);
      v.lookAt(m);
      v.updateMatrixWorld();
      v.matrixWorldInverse.getInverse(v.matrixWorld);
      n.cameraHelper && (n.cameraHelper.visible = n.shadowCameraVisible);
      n.shadowCameraVisible && n.cameraHelper.update();
      u.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      u.multiply(v.projectionMatrix);
      u.multiply(v.matrixWorldInverse);
      h.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse);
      g.setFromMatrix(h);
      b.setRenderTarget(t);
      b.clear();
      y = q.__webglObjects;
      n = 0;
      for (t = y.length;n < t;n++) {
        w = y[n], u = w.object, w.render = !1, !u.visible || (!u.castShadow || ((u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) && (u.frustumCulled && !g.intersectsObject(u)) || (u._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, u.matrixWorld), w.render = !0)));
      }
      n = 0;
      for (t = y.length;n < t;n++) {
        w = y[n], w.render && (u = w.object, w = w.buffer, B = u.material instanceof THREE.MeshFaceMaterial ? u.material.materials[0] : u.material, x = void 0 !== u.geometry.morphTargets && (0 < u.geometry.morphTargets.length && B.morphTargets), B = u instanceof THREE.SkinnedMesh && B.skinning, x = u.customDepthMaterial ? u.customDepthMaterial : B ? x ? f : e : x ? d : c, w instanceof THREE.BufferGeometry ? b.renderBufferDirect(v, q.__lights, null, x, w, u) : b.renderBuffer(v, q.__lights, null, x, 
        w, u));
      }
      y = q.__webglObjectsImmediate;
      n = 0;
      for (t = y.length;n < t;n++) {
        w = y[n], u = w.object, u.visible && (u.castShadow && (u._modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, u.matrixWorld), b.renderImmediateObject(v, q.__lights, null, c, u)));
      }
    }
    r = b.getClearColor();
    s = b.getClearAlpha();
    a.clearColor(r.r, r.g, r.b, s);
    a.enable(a.BLEND);
    b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK);
  };
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector;
THREE.DepthPassPlugin = function() {
  this.enabled = !1;
  this.renderTarget = null;
  var a, b, c, d, e, f, g = new THREE.Frustum, h = new THREE.Matrix4;
  this.init = function(g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h});
    d = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, morphTargets:!0});
    e = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, skinning:!0});
    f = new THREE.ShaderMaterial({fragmentShader:g.fragmentShader, vertexShader:g.vertexShader, uniforms:h, morphTargets:!0, skinning:!0});
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function(a, b) {
    this.enabled && this.update(a, b);
  };
  this.update = function(k, l) {
    var m, q, p, r, s, n;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    b.setDepthTest(!0);
    !0 === k.autoUpdate && k.updateMatrixWorld();
    l.matrixWorldInverse.getInverse(l.matrixWorld);
    h.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse);
    g.setFromMatrix(h);
    b.setRenderTarget(this.renderTarget);
    b.clear();
    n = k.__webglObjects;
    m = 0;
    for (q = n.length;m < q;m++) {
      p = n[m], s = p.object, p.render = !1, !s.visible || ((s instanceof THREE.Mesh || s instanceof THREE.ParticleSystem) && (s.frustumCulled && !g.intersectsObject(s)) || (s._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, s.matrixWorld), p.render = !0));
    }
    var t;
    m = 0;
    for (q = n.length;m < q;m++) {
      p = n[m], p.render && (s = p.object, p = p.buffer, s instanceof THREE.ParticleSystem && !s.customDepthMaterial || ((t = s.material instanceof THREE.MeshFaceMaterial ? s.material.materials[0] : s.material) && b.setMaterialFaces(s.material), r = 0 < s.geometry.morphTargets.length && t.morphTargets, t = s instanceof THREE.SkinnedMesh && t.skinning, r = s.customDepthMaterial ? s.customDepthMaterial : t ? r ? f : e : r ? d : c, p instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, k.__lights, 
      null, r, p, s) : b.renderBuffer(l, k.__lights, null, r, p, s)));
    }
    n = k.__webglObjectsImmediate;
    m = 0;
    for (q = n.length;m < q;m++) {
      p = n[m], s = p.object, s.visible && (s._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, s.matrixWorld), b.renderImmediateObject(l, k.__lights, null, c, s));
    }
    m = b.getClearColor();
    q = b.getClearAlpha();
    a.clearColor(m.r, m.g, m.b, q);
    a.enable(a.BLEND);
  };
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
  function m(a) {
    throw a;
  }
  var p = void 0, t, aa = this;
  function v(a, b) {
    var c = a.split("."), d = aa;
    !(c[0] in d) && (d.execScript && d.execScript("var " + c[0]));
    for (var g;c.length && (g = c.shift());) {
      !c.length && b !== p ? d[g] = b : d = d[g] ? d[g] : d[g] = {};
    }
  }
  var w = "undefined" !== typeof Uint8Array && ("undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array);
  new (w ? Uint8Array : Array)(256);
  var x;
  for (x = 0;256 > x;++x) {
    for (var y = x, ba = 7, y = y >>> 1;y;y >>>= 1) {
      --ba;
    }
  }
  var z = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 
  2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 
  2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 
  2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 
  3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 
  414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117], A = w ? new Uint32Array(z) : 
  z;
  function B(a) {
    var b = a.length, c = 0, d = Number.POSITIVE_INFINITY, g, f, h, e, k, l, q, s, r;
    for (s = 0;s < b;++s) {
      a[s] > c && (c = a[s]), a[s] < d && (d = a[s]);
    }
    g = 1 << c;
    f = new (w ? Uint32Array : Array)(g);
    h = 1;
    e = 0;
    for (k = 2;h <= c;) {
      for (s = 0;s < b;++s) {
        if (a[s] === h) {
          l = 0;
          q = e;
          for (r = 0;r < h;++r) {
            l = l << 1 | q & 1, q >>= 1;
          }
          for (r = l;r < g;r += k) {
            f[r] = h << 16 | s;
          }
          ++e;
        }
      }
      ++h;
      e <<= 1;
      k <<= 1;
    }
    return[f, c, d];
  }
  var C = [], D;
  for (D = 0;288 > D;D++) {
    switch(!0) {
      case 143 >= D:
        C.push([D + 48, 8]);
        break;
      case 255 >= D:
        C.push([D - 144 + 400, 9]);
        break;
      case 279 >= D:
        C.push([D - 256 + 0, 7]);
        break;
      case 287 >= D:
        C.push([D - 280 + 192, 8]);
        break;
      default:
        m("invalid literal: " + D);
    }
  }
  var ca = function() {
    function a(a) {
      switch(!0) {
        case 3 === a:
          return[257, a - 3, 0];
        case 4 === a:
          return[258, a - 4, 0];
        case 5 === a:
          return[259, a - 5, 0];
        case 6 === a:
          return[260, a - 6, 0];
        case 7 === a:
          return[261, a - 7, 0];
        case 8 === a:
          return[262, a - 8, 0];
        case 9 === a:
          return[263, a - 9, 0];
        case 10 === a:
          return[264, a - 10, 0];
        case 12 >= a:
          return[265, a - 11, 1];
        case 14 >= a:
          return[266, a - 13, 1];
        case 16 >= a:
          return[267, a - 15, 1];
        case 18 >= a:
          return[268, a - 17, 1];
        case 22 >= a:
          return[269, a - 19, 2];
        case 26 >= a:
          return[270, a - 23, 2];
        case 30 >= a:
          return[271, a - 27, 2];
        case 34 >= a:
          return[272, a - 31, 2];
        case 42 >= a:
          return[273, a - 35, 3];
        case 50 >= a:
          return[274, a - 43, 3];
        case 58 >= a:
          return[275, a - 51, 3];
        case 66 >= a:
          return[276, a - 59, 3];
        case 82 >= a:
          return[277, a - 67, 4];
        case 98 >= a:
          return[278, a - 83, 4];
        case 114 >= a:
          return[279, a - 99, 4];
        case 130 >= a:
          return[280, a - 115, 4];
        case 162 >= a:
          return[281, a - 131, 5];
        case 194 >= a:
          return[282, a - 163, 5];
        case 226 >= a:
          return[283, a - 195, 5];
        case 257 >= a:
          return[284, a - 227, 5];
        case 258 === a:
          return[285, a - 258, 0];
        default:
          m("invalid length: " + a);
      }
    }
    var b = [], c, d;
    for (c = 3;258 >= c;c++) {
      d = a(c), b[c] = d[2] << 24 | d[1] << 16 | d[0];
    }
    return b;
  }();
  w && new Uint32Array(ca);
  function E(a, b) {
    this.l = [];
    this.m = 32768;
    this.d = this.f = this.c = this.t = 0;
    this.input = w ? new Uint8Array(a) : a;
    this.u = !1;
    this.n = F;
    this.K = !1;
    if (b || !(b = {})) {
      b.index && (this.c = b.index), b.bufferSize && (this.m = b.bufferSize), b.bufferType && (this.n = b.bufferType), b.resize && (this.K = b.resize);
    }
    switch(this.n) {
      case G:
        this.a = 32768;
        this.b = new (w ? Uint8Array : Array)(32768 + this.m + 258);
        break;
      case F:
        this.a = 0;
        this.b = new (w ? Uint8Array : Array)(this.m);
        this.e = this.W;
        this.B = this.R;
        this.q = this.V;
        break;
      default:
        m(Error("invalid inflate mode"));
    }
  }
  var G = 0, F = 1;
  E.prototype.r = function() {
    for (;!this.u;) {
      var a = H(this, 3);
      a & 1 && (this.u = !0);
      a >>>= 1;
      switch(a) {
        case 0:
          var b = this.input, c = this.c, d = this.b, g = this.a, f = p, h = p, e = p, k = d.length, l = p;
          this.d = this.f = 0;
          f = b[c++];
          f === p && m(Error("invalid uncompressed block header: LEN (first byte)"));
          h = f;
          f = b[c++];
          f === p && m(Error("invalid uncompressed block header: LEN (second byte)"));
          h |= f << 8;
          f = b[c++];
          f === p && m(Error("invalid uncompressed block header: NLEN (first byte)"));
          e = f;
          f = b[c++];
          f === p && m(Error("invalid uncompressed block header: NLEN (second byte)"));
          e |= f << 8;
          h === ~e && m(Error("invalid uncompressed block header: length verify"));
          c + h > b.length && m(Error("input buffer is broken"));
          switch(this.n) {
            case G:
              for (;g + h > d.length;) {
                l = k - g;
                h -= l;
                if (w) {
                  d.set(b.subarray(c, c + l), g), g += l, c += l;
                } else {
                  for (;l--;) {
                    d[g++] = b[c++];
                  }
                }
                this.a = g;
                d = this.e();
                g = this.a;
              }
              break;
            case F:
              for (;g + h > d.length;) {
                d = this.e({H:2});
              }
              break;
            default:
              m(Error("invalid inflate mode"));
          }
          if (w) {
            d.set(b.subarray(c, c + h), g), g += h, c += h;
          } else {
            for (;h--;) {
              d[g++] = b[c++];
            }
          }
          this.c = c;
          this.a = g;
          this.b = d;
          break;
        case 1:
          this.q(da, ea);
          break;
        case 2:
          fa(this);
          break;
        default:
          m(Error("unknown BTYPE: " + a));
      }
    }
    return this.B();
  };
  var I = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], J = w ? new Uint16Array(I) : I, K = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], L = w ? new Uint16Array(K) : K, ga = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], O = w ? new Uint8Array(ga) : ga, ha = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 
  2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], ia = w ? new Uint16Array(ha) : ha, ja = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], P = w ? new Uint8Array(ja) : ja, Q = new (w ? Uint8Array : Array)(288), R, la;
  R = 0;
  for (la = Q.length;R < la;++R) {
    Q[R] = 143 >= R ? 8 : 255 >= R ? 9 : 279 >= R ? 7 : 8;
  }
  var da = B(Q), S = new (w ? Uint8Array : Array)(30), T, ma;
  T = 0;
  for (ma = S.length;T < ma;++T) {
    S[T] = 5;
  }
  var ea = B(S);
  function H(a, b) {
    for (var c = a.f, d = a.d, g = a.input, f = a.c, h;d < b;) {
      h = g[f++], h === p && m(Error("input buffer is broken")), c |= h << d, d += 8;
    }
    h = c & (1 << b) - 1;
    a.f = c >>> b;
    a.d = d - b;
    a.c = f;
    return h;
  }
  function U(a, b) {
    for (var c = a.f, d = a.d, g = a.input, f = a.c, h = b[0], e = b[1], k, l, q;d < e;) {
      k = g[f++];
      if (k === p) {
        break;
      }
      c |= k << d;
      d += 8;
    }
    l = h[c & (1 << e) - 1];
    q = l >>> 16;
    a.f = c >> q;
    a.d = d - q;
    a.c = f;
    return l & 65535;
  }
  function fa(a) {
    function b(a, b, c) {
      var d, e, f, g;
      for (g = 0;g < a;) {
        switch(d = U(this, b), d) {
          case 16:
            for (f = 3 + H(this, 2);f--;) {
              c[g++] = e;
            }
            break;
          case 17:
            for (f = 3 + H(this, 3);f--;) {
              c[g++] = 0;
            }
            e = 0;
            break;
          case 18:
            for (f = 11 + H(this, 7);f--;) {
              c[g++] = 0;
            }
            e = 0;
            break;
          default:
            e = c[g++] = d;
        }
      }
      return c;
    }
    var c = H(a, 5) + 257, d = H(a, 5) + 1, g = H(a, 4) + 4, f = new (w ? Uint8Array : Array)(J.length), h, e, k, l;
    for (l = 0;l < g;++l) {
      f[J[l]] = H(a, 3);
    }
    h = B(f);
    e = new (w ? Uint8Array : Array)(c);
    k = new (w ? Uint8Array : Array)(d);
    a.q(B(b.call(a, c, h, e)), B(b.call(a, d, h, k)));
  }
  t = E.prototype;
  t.q = function(a, b) {
    var c = this.b, d = this.a;
    this.C = a;
    for (var g = c.length - 258, f, h, e, k;256 !== (f = U(this, a));) {
      if (256 > f) {
        d >= g && (this.a = d, c = this.e(), d = this.a), c[d++] = f;
      } else {
        h = f - 257;
        k = L[h];
        0 < O[h] && (k += H(this, O[h]));
        f = U(this, b);
        e = ia[f];
        0 < P[f] && (e += H(this, P[f]));
        d >= g && (this.a = d, c = this.e(), d = this.a);
        for (;k--;) {
          c[d] = c[d++ - e];
        }
      }
    }
    for (;8 <= this.d;) {
      this.d -= 8, this.c--;
    }
    this.a = d;
  };
  t.V = function(a, b) {
    var c = this.b, d = this.a;
    this.C = a;
    for (var g = c.length, f, h, e, k;256 !== (f = U(this, a));) {
      if (256 > f) {
        d >= g && (c = this.e(), g = c.length), c[d++] = f;
      } else {
        h = f - 257;
        k = L[h];
        0 < O[h] && (k += H(this, O[h]));
        f = U(this, b);
        e = ia[f];
        0 < P[f] && (e += H(this, P[f]));
        d + k > g && (c = this.e(), g = c.length);
        for (;k--;) {
          c[d] = c[d++ - e];
        }
      }
    }
    for (;8 <= this.d;) {
      this.d -= 8, this.c--;
    }
    this.a = d;
  };
  t.e = function() {
    var a = new (w ? Uint8Array : Array)(this.a - 32768), b = this.a - 32768, c, d, g = this.b;
    if (w) {
      a.set(g.subarray(32768, a.length));
    } else {
      c = 0;
      for (d = a.length;c < d;++c) {
        a[c] = g[c + 32768];
      }
    }
    this.l.push(a);
    this.t += a.length;
    if (w) {
      g.set(g.subarray(b, b + 32768));
    } else {
      for (c = 0;32768 > c;++c) {
        g[c] = g[b + c];
      }
    }
    this.a = 32768;
    return g;
  };
  t.W = function(a) {
    var b, c = this.input.length / this.c + 1 | 0, d, g, f, h = this.input, e = this.b;
    a && ("number" === typeof a.H && (c = a.H), "number" === typeof a.P && (c += a.P));
    2 > c ? (d = (h.length - this.c) / this.C[2], f = 258 * (d / 2) | 0, g = f < e.length ? e.length + f : e.length << 1) : g = e.length * c;
    w ? (b = new Uint8Array(g), b.set(e)) : b = e;
    return this.b = b;
  };
  t.B = function() {
    var a = 0, b = this.b, c = this.l, d, g = new (w ? Uint8Array : Array)(this.t + (this.a - 32768)), f, h, e, k;
    if (0 === c.length) {
      return w ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
    }
    f = 0;
    for (h = c.length;f < h;++f) {
      d = c[f];
      e = 0;
      for (k = d.length;e < k;++e) {
        g[a++] = d[e];
      }
    }
    f = 32768;
    for (h = this.a;f < h;++f) {
      g[a++] = b[f];
    }
    this.l = [];
    return this.buffer = g;
  };
  t.R = function() {
    var a, b = this.a;
    w ? this.K ? (a = new Uint8Array(b), a.set(this.b.subarray(0, b))) : a = this.b.subarray(0, b) : (this.b.length > b && (this.b.length = b), a = this.b);
    return this.buffer = a;
  };
  function V(a) {
    a = a || {};
    this.files = [];
    this.v = a.comment;
  }
  V.prototype.L = function(a) {
    this.j = a;
  };
  V.prototype.s = function(a) {
    var b = a[2] & 65535 | 2;
    return b * (b ^ 1) >> 8 & 255;
  };
  V.prototype.k = function(a, b) {
    a[0] = (A[(a[0] ^ b) & 255] ^ a[0] >>> 8) >>> 0;
    a[1] = (6681 * (20173 * (a[1] + (a[0] & 255)) >>> 0) >>> 0) + 1 >>> 0;
    a[2] = (A[(a[2] ^ a[1] >>> 24) & 255] ^ a[2] >>> 8) >>> 0;
  };
  V.prototype.T = function(a) {
    var b = [305419896, 591751049, 878082192], c, d;
    w && (b = new Uint32Array(b));
    c = 0;
    for (d = a.length;c < d;++c) {
      this.k(b, a[c] & 255);
    }
    return b;
  };
  function W(a, b) {
    b = b || {};
    this.input = w && a instanceof Array ? new Uint8Array(a) : a;
    this.c = 0;
    this.ba = b.verify || !1;
    this.j = b.password;
  }
  var na = {O:0, M:8}, X = [80, 75, 1, 2], Y = [80, 75, 3, 4], Z = [80, 75, 5, 6];
  function oa(a, b) {
    this.input = a;
    this.offset = b;
  }
  oa.prototype.parse = function() {
    var a = this.input, b = this.offset;
    (a[b++] !== X[0] || (a[b++] !== X[1] || (a[b++] !== X[2] || a[b++] !== X[3]))) && m(Error("invalid file header signature"));
    this.version = a[b++];
    this.ia = a[b++];
    this.Z = a[b++] | a[b++] << 8;
    this.I = a[b++] | a[b++] << 8;
    this.A = a[b++] | a[b++] << 8;
    this.time = a[b++] | a[b++] << 8;
    this.U = a[b++] | a[b++] << 8;
    this.p = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.z = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.J = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.h = a[b++] | a[b++] << 8;
    this.g = a[b++] | a[b++] << 8;
    this.F = a[b++] | a[b++] << 8;
    this.ea = a[b++] | a[b++] << 8;
    this.ga = a[b++] | a[b++] << 8;
    this.fa = a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24;
    this.$ = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.filename = String.fromCharCode.apply(null, w ? a.subarray(b, b += this.h) : a.slice(b, b += this.h));
    this.X = w ? a.subarray(b, b += this.g) : a.slice(b, b += this.g);
    this.v = w ? a.subarray(b, b + this.F) : a.slice(b, b + this.F);
    this.length = b - this.offset;
  };
  function pa(a, b) {
    this.input = a;
    this.offset = b;
  }
  var qa = {N:1, ca:8, da:2048};
  pa.prototype.parse = function() {
    var a = this.input, b = this.offset;
    (a[b++] !== Y[0] || (a[b++] !== Y[1] || (a[b++] !== Y[2] || a[b++] !== Y[3]))) && m(Error("invalid local file header signature"));
    this.Z = a[b++] | a[b++] << 8;
    this.I = a[b++] | a[b++] << 8;
    this.A = a[b++] | a[b++] << 8;
    this.time = a[b++] | a[b++] << 8;
    this.U = a[b++] | a[b++] << 8;
    this.p = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.z = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.J = (a[b++] | a[b++] << 8 | a[b++] << 16 | a[b++] << 24) >>> 0;
    this.h = a[b++] | a[b++] << 8;
    this.g = a[b++] | a[b++] << 8;
    this.filename = String.fromCharCode.apply(null, w ? a.subarray(b, b += this.h) : a.slice(b, b += this.h));
    this.X = w ? a.subarray(b, b += this.g) : a.slice(b, b += this.g);
    this.length = b - this.offset;
  };
  function $(a) {
    var b = [], c = {}, d, g, f, h;
    if (!a.i) {
      if (a.o === p) {
        var e = a.input, k;
        if (!a.D) {
          a: {
            var l = a.input, q;
            for (q = l.length - 12;0 < q;--q) {
              if (l[q] === Z[0] && (l[q + 1] === Z[1] && (l[q + 2] === Z[2] && l[q + 3] === Z[3]))) {
                a.D = q;
                break a;
              }
            }
            m(Error("End of Central Directory Record not found"));
          }
        }
        k = a.D;
        (e[k++] !== Z[0] || (e[k++] !== Z[1] || (e[k++] !== Z[2] || e[k++] !== Z[3]))) && m(Error("invalid signature"));
        a.ha = e[k++] | e[k++] << 8;
        a.ja = e[k++] | e[k++] << 8;
        a.ka = e[k++] | e[k++] << 8;
        a.aa = e[k++] | e[k++] << 8;
        a.Q = (e[k++] | e[k++] << 8 | e[k++] << 16 | e[k++] << 24) >>> 0;
        a.o = (e[k++] | e[k++] << 8 | e[k++] << 16 | e[k++] << 24) >>> 0;
        a.w = e[k++] | e[k++] << 8;
        a.v = w ? e.subarray(k, k + a.w) : e.slice(k, k + a.w);
      }
      d = a.o;
      f = 0;
      for (h = a.aa;f < h;++f) {
        g = new oa(a.input, d), g.parse(), d += g.length, b[f] = g, c[g.filename] = f;
      }
      a.Q < d - a.o && m(Error("invalid file header size"));
      a.i = b;
      a.G = c;
    }
  }
  t = W.prototype;
  t.Y = function() {
    var a = [], b, c, d;
    this.i || $(this);
    d = this.i;
    b = 0;
    for (c = d.length;b < c;++b) {
      a[b] = d[b].filename;
    }
    return a;
  };
  t.r = function(a, b) {
    var c;
    this.G || $(this);
    c = this.G[a];
    c === p && m(Error(a + " not found"));
    var d;
    d = b || {};
    var g = this.input, f = this.i, h, e, k, l, q, s, r, M;
    f || $(this);
    f[c] === p && m(Error("wrong index"));
    e = f[c].$;
    h = new pa(this.input, e);
    h.parse();
    e += h.length;
    k = h.z;
    if (0 !== (h.I & qa.N)) {
      !d.password && (!this.j && m(Error("please set password")));
      s = this.S(d.password || this.j);
      r = e;
      for (M = e + 12;r < M;++r) {
        ra(this, s, g[r]);
      }
      e += 12;
      k -= 12;
      r = e;
      for (M = e + k;r < M;++r) {
        g[r] = ra(this, s, g[r]);
      }
    }
    switch(h.A) {
      case na.O:
        l = w ? this.input.subarray(e, e + k) : this.input.slice(e, e + k);
        break;
      case na.M:
        l = (new E(this.input, {index:e, bufferSize:h.J})).r();
        break;
      default:
        m(Error("unknown compression type"));
    }
    if (this.ba) {
      var u = p, n, N = "number" === typeof u ? u : u = 0, ka = l.length;
      n = -1;
      for (N = ka & 7;N--;++u) {
        n = n >>> 8 ^ A[(n ^ l[u]) & 255];
      }
      for (N = ka >> 3;N--;u += 8) {
        n = n >>> 8 ^ A[(n ^ l[u]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 1]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 2]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 3]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 4]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 5]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 6]) & 255], n = n >>> 8 ^ A[(n ^ l[u + 7]) & 255];
      }
      q = (n ^ 4294967295) >>> 0;
      h.p !== q && m(Error("wrong crc: file=0x" + h.p.toString(16) + ", data=0x" + q.toString(16)));
    }
    return l;
  };
  t.L = function(a) {
    this.j = a;
  };
  function ra(a, b, c) {
    c ^= a.s(b);
    a.k(b, c);
    return c;
  }
  t.k = V.prototype.k;
  t.S = V.prototype.T;
  t.s = V.prototype.s;
  v("Zlib.Unzip", W);
  v("Zlib.Unzip.prototype.decompress", W.prototype.r);
  v("Zlib.Unzip.prototype.getFilenames", W.prototype.Y);
  v("Zlib.Unzip.prototype.setPassword", W.prototype.L);
}).call(this);
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
  function n(e) {
    throw e;
  }
  var p = void 0, aa = this;
  function r(e, c) {
    var d = e.split("."), b = aa;
    !(d[0] in b) && (b.execScript && b.execScript("var " + d[0]));
    for (var a;d.length && (a = d.shift());) {
      !d.length && c !== p ? b[a] = c : b = b[a] ? b[a] : b[a] = {};
    }
  }
  var u = "undefined" !== typeof Uint8Array && ("undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array);
  new (u ? Uint8Array : Array)(256);
  var v;
  for (v = 0;256 > v;++v) {
    for (var w = v, ba = 7, w = w >>> 1;w;w >>>= 1) {
      --ba;
    }
  }
  function x(e, c, d) {
    var b, a = "number" === typeof c ? c : c = 0, f = "number" === typeof d ? d : e.length;
    b = -1;
    for (a = f & 7;a--;++c) {
      b = b >>> 8 ^ y[(b ^ e[c]) & 255];
    }
    for (a = f >> 3;a--;c += 8) {
      b = b >>> 8 ^ y[(b ^ e[c]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 1]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 2]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 3]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 4]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 5]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 6]) & 255], b = b >>> 8 ^ y[(b ^ e[c + 7]) & 255];
    }
    return(b ^ 4294967295) >>> 0;
  }
  var z = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 
  2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 
  2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 
  2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 
  3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 
  414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117], y = u ? new Uint32Array(z) : 
  z;
  function A() {
  }
  A.prototype.getName = function() {
    return this.name;
  };
  A.prototype.getData = function() {
    return this.data;
  };
  A.prototype.G = function() {
    return this.H;
  };
  r("Zlib.GunzipMember", A);
  r("Zlib.GunzipMember.prototype.getName", A.prototype.getName);
  r("Zlib.GunzipMember.prototype.getData", A.prototype.getData);
  r("Zlib.GunzipMember.prototype.getMtime", A.prototype.G);
  function C(e) {
    var c = e.length, d = 0, b = Number.POSITIVE_INFINITY, a, f, g, k, m, q, t, h, l;
    for (h = 0;h < c;++h) {
      e[h] > d && (d = e[h]), e[h] < b && (b = e[h]);
    }
    a = 1 << d;
    f = new (u ? Uint32Array : Array)(a);
    g = 1;
    k = 0;
    for (m = 2;g <= d;) {
      for (h = 0;h < c;++h) {
        if (e[h] === g) {
          q = 0;
          t = k;
          for (l = 0;l < g;++l) {
            q = q << 1 | t & 1, t >>= 1;
          }
          for (l = q;l < a;l += m) {
            f[l] = g << 16 | h;
          }
          ++k;
        }
      }
      ++g;
      k <<= 1;
      m <<= 1;
    }
    return[f, d, b];
  }
  var D = [], E;
  for (E = 0;288 > E;E++) {
    switch(!0) {
      case 143 >= E:
        D.push([E + 48, 8]);
        break;
      case 255 >= E:
        D.push([E - 144 + 400, 9]);
        break;
      case 279 >= E:
        D.push([E - 256 + 0, 7]);
        break;
      case 287 >= E:
        D.push([E - 280 + 192, 8]);
        break;
      default:
        n("invalid literal: " + E);
    }
  }
  var ca = function() {
    function e(a) {
      switch(!0) {
        case 3 === a:
          return[257, a - 3, 0];
        case 4 === a:
          return[258, a - 4, 0];
        case 5 === a:
          return[259, a - 5, 0];
        case 6 === a:
          return[260, a - 6, 0];
        case 7 === a:
          return[261, a - 7, 0];
        case 8 === a:
          return[262, a - 8, 0];
        case 9 === a:
          return[263, a - 9, 0];
        case 10 === a:
          return[264, a - 10, 0];
        case 12 >= a:
          return[265, a - 11, 1];
        case 14 >= a:
          return[266, a - 13, 1];
        case 16 >= a:
          return[267, a - 15, 1];
        case 18 >= a:
          return[268, a - 17, 1];
        case 22 >= a:
          return[269, a - 19, 2];
        case 26 >= a:
          return[270, a - 23, 2];
        case 30 >= a:
          return[271, a - 27, 2];
        case 34 >= a:
          return[272, a - 31, 2];
        case 42 >= a:
          return[273, a - 35, 3];
        case 50 >= a:
          return[274, a - 43, 3];
        case 58 >= a:
          return[275, a - 51, 3];
        case 66 >= a:
          return[276, a - 59, 3];
        case 82 >= a:
          return[277, a - 67, 4];
        case 98 >= a:
          return[278, a - 83, 4];
        case 114 >= a:
          return[279, a - 99, 4];
        case 130 >= a:
          return[280, a - 115, 4];
        case 162 >= a:
          return[281, a - 131, 5];
        case 194 >= a:
          return[282, a - 163, 5];
        case 226 >= a:
          return[283, a - 195, 5];
        case 257 >= a:
          return[284, a - 227, 5];
        case 258 === a:
          return[285, a - 258, 0];
        default:
          n("invalid length: " + a);
      }
    }
    var c = [], d, b;
    for (d = 3;258 >= d;d++) {
      b = e(d), c[d] = b[2] << 24 | b[1] << 16 | b[0];
    }
    return c;
  }();
  u && new Uint32Array(ca);
  function G(e, c) {
    this.i = [];
    this.j = 32768;
    this.d = this.f = this.c = this.n = 0;
    this.input = u ? new Uint8Array(e) : e;
    this.o = !1;
    this.k = H;
    this.w = !1;
    if (c || !(c = {})) {
      c.index && (this.c = c.index), c.bufferSize && (this.j = c.bufferSize), c.bufferType && (this.k = c.bufferType), c.resize && (this.w = c.resize);
    }
    switch(this.k) {
      case I:
        this.a = 32768;
        this.b = new (u ? Uint8Array : Array)(32768 + this.j + 258);
        break;
      case H:
        this.a = 0;
        this.b = new (u ? Uint8Array : Array)(this.j);
        this.e = this.D;
        this.q = this.A;
        this.l = this.C;
        break;
      default:
        n(Error("invalid inflate mode"));
    }
  }
  var I = 0, H = 1;
  G.prototype.g = function() {
    for (;!this.o;) {
      var e = J(this, 3);
      e & 1 && (this.o = !0);
      e >>>= 1;
      switch(e) {
        case 0:
          var c = this.input, d = this.c, b = this.b, a = this.a, f = p, g = p, k = p, m = b.length, q = p;
          this.d = this.f = 0;
          f = c[d++];
          f === p && n(Error("invalid uncompressed block header: LEN (first byte)"));
          g = f;
          f = c[d++];
          f === p && n(Error("invalid uncompressed block header: LEN (second byte)"));
          g |= f << 8;
          f = c[d++];
          f === p && n(Error("invalid uncompressed block header: NLEN (first byte)"));
          k = f;
          f = c[d++];
          f === p && n(Error("invalid uncompressed block header: NLEN (second byte)"));
          k |= f << 8;
          g === ~k && n(Error("invalid uncompressed block header: length verify"));
          d + g > c.length && n(Error("input buffer is broken"));
          switch(this.k) {
            case I:
              for (;a + g > b.length;) {
                q = m - a;
                g -= q;
                if (u) {
                  b.set(c.subarray(d, d + q), a), a += q, d += q;
                } else {
                  for (;q--;) {
                    b[a++] = c[d++];
                  }
                }
                this.a = a;
                b = this.e();
                a = this.a;
              }
              break;
            case H:
              for (;a + g > b.length;) {
                b = this.e({t:2});
              }
              break;
            default:
              n(Error("invalid inflate mode"));
          }
          if (u) {
            b.set(c.subarray(d, d + g), a), a += g, d += g;
          } else {
            for (;g--;) {
              b[a++] = c[d++];
            }
          }
          this.c = d;
          this.a = a;
          this.b = b;
          break;
        case 1:
          this.l(da, ea);
          break;
        case 2:
          fa(this);
          break;
        default:
          n(Error("unknown BTYPE: " + e));
      }
    }
    return this.q();
  };
  var K = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], L = u ? new Uint16Array(K) : K, N = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], O = u ? new Uint16Array(N) : N, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], Q = u ? new Uint8Array(P) : P, T = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 
  3073, 4097, 6145, 8193, 12289, 16385, 24577], ga = u ? new Uint16Array(T) : T, ha = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], U = u ? new Uint8Array(ha) : ha, V = new (u ? Uint8Array : Array)(288), W, ia;
  W = 0;
  for (ia = V.length;W < ia;++W) {
    V[W] = 143 >= W ? 8 : 255 >= W ? 9 : 279 >= W ? 7 : 8;
  }
  var da = C(V), X = new (u ? Uint8Array : Array)(30), Y, ja;
  Y = 0;
  for (ja = X.length;Y < ja;++Y) {
    X[Y] = 5;
  }
  var ea = C(X);
  function J(e, c) {
    for (var d = e.f, b = e.d, a = e.input, f = e.c, g;b < c;) {
      g = a[f++], g === p && n(Error("input buffer is broken")), d |= g << b, b += 8;
    }
    g = d & (1 << c) - 1;
    e.f = d >>> c;
    e.d = b - c;
    e.c = f;
    return g;
  }
  function Z(e, c) {
    for (var d = e.f, b = e.d, a = e.input, f = e.c, g = c[0], k = c[1], m, q, t;b < k;) {
      m = a[f++];
      if (m === p) {
        break;
      }
      d |= m << b;
      b += 8;
    }
    q = g[d & (1 << k) - 1];
    t = q >>> 16;
    e.f = d >> t;
    e.d = b - t;
    e.c = f;
    return q & 65535;
  }
  function fa(e) {
    function c(a, c, b) {
      var d, e, f, g;
      for (g = 0;g < a;) {
        switch(d = Z(this, c), d) {
          case 16:
            for (f = 3 + J(this, 2);f--;) {
              b[g++] = e;
            }
            break;
          case 17:
            for (f = 3 + J(this, 3);f--;) {
              b[g++] = 0;
            }
            e = 0;
            break;
          case 18:
            for (f = 11 + J(this, 7);f--;) {
              b[g++] = 0;
            }
            e = 0;
            break;
          default:
            e = b[g++] = d;
        }
      }
      return b;
    }
    var d = J(e, 5) + 257, b = J(e, 5) + 1, a = J(e, 4) + 4, f = new (u ? Uint8Array : Array)(L.length), g, k, m, q;
    for (q = 0;q < a;++q) {
      f[L[q]] = J(e, 3);
    }
    g = C(f);
    k = new (u ? Uint8Array : Array)(d);
    m = new (u ? Uint8Array : Array)(b);
    e.l(C(c.call(e, d, g, k)), C(c.call(e, b, g, m)));
  }
  G.prototype.l = function(e, c) {
    var d = this.b, b = this.a;
    this.r = e;
    for (var a = d.length - 258, f, g, k, m;256 !== (f = Z(this, e));) {
      if (256 > f) {
        b >= a && (this.a = b, d = this.e(), b = this.a), d[b++] = f;
      } else {
        g = f - 257;
        m = O[g];
        0 < Q[g] && (m += J(this, Q[g]));
        f = Z(this, c);
        k = ga[f];
        0 < U[f] && (k += J(this, U[f]));
        b >= a && (this.a = b, d = this.e(), b = this.a);
        for (;m--;) {
          d[b] = d[b++ - k];
        }
      }
    }
    for (;8 <= this.d;) {
      this.d -= 8, this.c--;
    }
    this.a = b;
  };
  G.prototype.C = function(e, c) {
    var d = this.b, b = this.a;
    this.r = e;
    for (var a = d.length, f, g, k, m;256 !== (f = Z(this, e));) {
      if (256 > f) {
        b >= a && (d = this.e(), a = d.length), d[b++] = f;
      } else {
        g = f - 257;
        m = O[g];
        0 < Q[g] && (m += J(this, Q[g]));
        f = Z(this, c);
        k = ga[f];
        0 < U[f] && (k += J(this, U[f]));
        b + m > a && (d = this.e(), a = d.length);
        for (;m--;) {
          d[b] = d[b++ - k];
        }
      }
    }
    for (;8 <= this.d;) {
      this.d -= 8, this.c--;
    }
    this.a = b;
  };
  G.prototype.e = function() {
    var e = new (u ? Uint8Array : Array)(this.a - 32768), c = this.a - 32768, d, b, a = this.b;
    if (u) {
      e.set(a.subarray(32768, e.length));
    } else {
      d = 0;
      for (b = e.length;d < b;++d) {
        e[d] = a[d + 32768];
      }
    }
    this.i.push(e);
    this.n += e.length;
    if (u) {
      a.set(a.subarray(c, c + 32768));
    } else {
      for (d = 0;32768 > d;++d) {
        a[d] = a[c + d];
      }
    }
    this.a = 32768;
    return a;
  };
  G.prototype.D = function(e) {
    var c, d = this.input.length / this.c + 1 | 0, b, a, f, g = this.input, k = this.b;
    e && ("number" === typeof e.t && (d = e.t), "number" === typeof e.z && (d += e.z));
    2 > d ? (b = (g.length - this.c) / this.r[2], f = 258 * (b / 2) | 0, a = f < k.length ? k.length + f : k.length << 1) : a = k.length * d;
    u ? (c = new Uint8Array(a), c.set(k)) : c = k;
    return this.b = c;
  };
  G.prototype.q = function() {
    var e = 0, c = this.b, d = this.i, b, a = new (u ? Uint8Array : Array)(this.n + (this.a - 32768)), f, g, k, m;
    if (0 === d.length) {
      return u ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
    }
    f = 0;
    for (g = d.length;f < g;++f) {
      b = d[f];
      k = 0;
      for (m = b.length;k < m;++k) {
        a[e++] = b[k];
      }
    }
    f = 32768;
    for (g = this.a;f < g;++f) {
      a[e++] = c[f];
    }
    this.i = [];
    return this.buffer = a;
  };
  G.prototype.A = function() {
    var e, c = this.a;
    u ? this.w ? (e = new Uint8Array(c), e.set(this.b.subarray(0, c))) : e = this.b.subarray(0, c) : (this.b.length > c && (this.b.length = c), e = this.b);
    return this.buffer = e;
  };
  function $(e) {
    this.input = e;
    this.c = 0;
    this.m = [];
    this.s = !1;
  }
  $.prototype.F = function() {
    this.s || this.g();
    return this.m.slice();
  };
  $.prototype.g = function() {
    for (var e = this.input.length;this.c < e;) {
      var c = new A, d = p, b = p, a = p, f = p, g = p, k = p, m = p, q = p, t = p, h = this.input, l = this.c;
      c.u = h[l++];
      c.v = h[l++];
      (31 !== c.u || 139 !== c.v) && n(Error("invalid file signature:" + c.u + "," + c.v));
      c.p = h[l++];
      switch(c.p) {
        case 8:
          break;
        default:
          n(Error("unknown compression method: " + c.p));
      }
      c.h = h[l++];
      q = h[l++] | h[l++] << 8 | h[l++] << 16 | h[l++] << 24;
      c.H = new Date(1E3 * q);
      c.N = h[l++];
      c.M = h[l++];
      0 < (c.h & 4) && (c.I = h[l++] | h[l++] << 8, l += c.I);
      if (0 < (c.h & 8)) {
        m = [];
        for (k = 0;0 < (g = h[l++]);) {
          m[k++] = String.fromCharCode(g);
        }
        c.name = m.join("");
      }
      if (0 < (c.h & 16)) {
        m = [];
        for (k = 0;0 < (g = h[l++]);) {
          m[k++] = String.fromCharCode(g);
        }
        c.J = m.join("");
      }
      0 < (c.h & 2) && (c.B = x(h, 0, l) & 65535, c.B !== (h[l++] | h[l++] << 8) && n(Error("invalid header crc16")));
      d = h[h.length - 4] | h[h.length - 3] << 8 | h[h.length - 2] << 16 | h[h.length - 1] << 24;
      h.length - l - 4 - 4 < 512 * d && (f = d);
      b = new G(h, {index:l, bufferSize:f});
      c.data = a = b.g();
      l = b.c;
      c.K = t = (h[l++] | h[l++] << 8 | h[l++] << 16 | h[l++] << 24) >>> 0;
      x(a, p, p) !== t && n(Error("invalid CRC-32 checksum: 0x" + x(a, p, p).toString(16) + " / 0x" + t.toString(16)));
      c.L = d = (h[l++] | h[l++] << 8 | h[l++] << 16 | h[l++] << 24) >>> 0;
      (a.length & 4294967295) !== d && n(Error("invalid input size: " + (a.length & 4294967295) + " / " + d));
      this.m.push(c);
      this.c = l;
    }
    this.s = !0;
    var F = this.m, s, M, R = 0, S = 0, B;
    s = 0;
    for (M = F.length;s < M;++s) {
      S += F[s].data.length;
    }
    if (u) {
      B = new Uint8Array(S);
      for (s = 0;s < M;++s) {
        B.set(F[s].data, R), R += F[s].data.length;
      }
    } else {
      B = [];
      for (s = 0;s < M;++s) {
        B[s] = F[s].data;
      }
      B = Array.prototype.concat.apply([], B);
    }
    return B;
  };
  r("Zlib.Gunzip", $);
  r("Zlib.Gunzip.prototype.decompress", $.prototype.g);
  r("Zlib.Gunzip.prototype.getMembers", $.prototype.F);
}).call(this);
if (typeof window !== "undefined") {
  !function(t, e, i) {
    var n = t.L, o = {};
    o.version = "0.7.2", o.noConflict = function() {
      return t.L = n, this;
    }, t.L = o, o.Util = {extend:function(t) {
      var e, i, n, o, s = Array.prototype.slice.call(arguments, 1);
      for (i = 0, n = s.length;n > i;i++) {
        o = s[i] || {};
        for (e in o) {
          o.hasOwnProperty(e) && (t[e] = o[e]);
        }
      }
      return t;
    }, bind:function(t, e) {
      var i = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
      return function() {
        return t.apply(e, i || arguments);
      };
    }, stamp:function() {
      var t = 0, e = "_leaflet_id";
      return function(i) {
        return i[e] = i[e] || ++t, i[e];
      };
    }(), invokeEach:function(t, e, i) {
      var n, o;
      if ("object" == typeof t) {
        o = Array.prototype.slice.call(arguments, 3);
        for (n in t) {
          e.apply(i, [n, t[n]].concat(o));
        }
        return!0;
      }
      return!1;
    }, limitExecByInterval:function(t, e, i) {
      var n, o;
      return function s() {
        var a = arguments;
        return n ? void(o = !0) : (n = !0, setTimeout(function() {
          n = !1, o && (s.apply(i, a), o = !1);
        }, e), void t.apply(i, a));
      };
    }, falseFn:function() {
      return!1;
    }, formatNum:function(t, e) {
      var i = Math.pow(10, e || 5);
      return Math.round(t * i) / i;
    }, trim:function(t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
    }, splitWords:function(t) {
      return o.Util.trim(t).split(/\s+/);
    }, setOptions:function(t, e) {
      return t.options = o.extend({}, t.options, e), t.options;
    }, getParamString:function(t, e, i) {
      var n = [];
      for (var o in t) {
        n.push(encodeURIComponent(i ? o.toUpperCase() : o) + "=" + encodeURIComponent(t[o]));
      }
      return(e && -1 !== e.indexOf("?") ? "&" : "?") + n.join("&");
    }, template:function(t, e) {
      return t.replace(/\{ *([\w_]+) *\}/g, function(t, n) {
        var o = e[n];
        if (o === i) {
          throw new Error("No value provided for variable " + t);
        }
        return "function" == typeof o && (o = o(e)), o;
      });
    }, isArray:Array.isArray || function(t) {
      return "[object Array]" === Object.prototype.toString.call(t);
    }, emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="}, function() {
      function e(e) {
        var i, n, o = ["webkit", "moz", "o", "ms"];
        for (i = 0;i < o.length && !n;i++) {
          n = t[o[i] + e];
        }
        return n;
      }
      function i(e) {
        var i = +new Date, o = Math.max(0, 16 - (i - n));
        return n = i + o, t.setTimeout(e, o);
      }
      var n = 0, s = t.requestAnimationFrame || (e("RequestAnimationFrame") || i), a = t.cancelAnimationFrame || (e("CancelAnimationFrame") || (e("CancelRequestAnimationFrame") || function(e) {
        t.clearTimeout(e);
      }));
      o.Util.requestAnimFrame = function(e, n, a, r) {
        return e = o.bind(e, n), a && s === i ? void e() : s.call(t, e, r);
      }, o.Util.cancelAnimFrame = function(e) {
        e && a.call(t, e);
      };
    }(), o.extend = o.Util.extend, o.bind = o.Util.bind, o.stamp = o.Util.stamp, o.setOptions = o.Util.setOptions, o.Class = function() {
    }, o.Class.extend = function(t) {
      var e = function() {
        this.initialize && this.initialize.apply(this, arguments), this._initHooks && this.callInitHooks();
      }, i = function() {
      };
      i.prototype = this.prototype;
      var n = new i;
      n.constructor = e, e.prototype = n;
      for (var s in this) {
        this.hasOwnProperty(s) && ("prototype" !== s && (e[s] = this[s]));
      }
      t.statics && (o.extend(e, t.statics), delete t.statics), t.includes && (o.Util.extend.apply(null, [n].concat(t.includes)), delete t.includes), t.options && (n.options && (t.options = o.extend({}, n.options, t.options))), o.extend(n, t), n._initHooks = [];
      var a = this;
      return e.__super__ = a.prototype, n.callInitHooks = function() {
        if (!this._initHooksCalled) {
          a.prototype.callInitHooks && a.prototype.callInitHooks.call(this), this._initHooksCalled = !0;
          for (var t = 0, e = n._initHooks.length;e > t;t++) {
            n._initHooks[t].call(this);
          }
        }
      }, e;
    }, o.Class.include = function(t) {
      o.extend(this.prototype, t);
    }, o.Class.mergeOptions = function(t) {
      o.extend(this.prototype.options, t);
    }, o.Class.addInitHook = function(t) {
      var e = Array.prototype.slice.call(arguments, 1), i = "function" == typeof t ? t : function() {
        this[t].apply(this, e);
      };
      this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i);
    };
    var s = "_leaflet_events";
    o.Mixin = {}, o.Mixin.Events = {addEventListener:function(t, e, i) {
      if (o.Util.invokeEach(t, this.addEventListener, this, e, i)) {
        return this;
      }
      var n, a, r, h, l, u, c, d = this[s] = this[s] || {}, p = i && (i !== this && o.stamp(i));
      for (t = o.Util.splitWords(t), n = 0, a = t.length;a > n;n++) {
        r = {action:e, context:i || this}, h = t[n], p ? (l = h + "_idx", u = l + "_len", c = d[l] = d[l] || {}, c[p] || (c[p] = [], d[u] = (d[u] || 0) + 1), c[p].push(r)) : (d[h] = d[h] || [], d[h].push(r));
      }
      return this;
    }, hasEventListeners:function(t) {
      var e = this[s];
      return!!e && (t in e && e[t].length > 0 || t + "_idx" in e && e[t + "_idx_len"] > 0);
    }, removeEventListener:function(t, e, i) {
      if (!this[s]) {
        return this;
      }
      if (!t) {
        return this.clearAllEventListeners();
      }
      if (o.Util.invokeEach(t, this.removeEventListener, this, e, i)) {
        return this;
      }
      var n, a, r, h, l, u, c, d, p, _ = this[s], m = i && (i !== this && o.stamp(i));
      for (t = o.Util.splitWords(t), n = 0, a = t.length;a > n;n++) {
        if (r = t[n], u = r + "_idx", c = u + "_len", d = _[u], e) {
          if (h = m && d ? d[m] : _[r]) {
            for (l = h.length - 1;l >= 0;l--) {
              h[l].action !== e || (i && h[l].context !== i || (p = h.splice(l, 1), p[0].action = o.Util.falseFn));
            }
            i && (d && (0 === h.length && (delete d[m], _[c]--)));
          }
        } else {
          delete _[r], delete _[u], delete _[c];
        }
      }
      return this;
    }, clearAllEventListeners:function() {
      return delete this[s], this;
    }, fireEvent:function(t, e) {
      if (!this.hasEventListeners(t)) {
        return this;
      }
      var i, n, a, r, h, l = o.Util.extend({}, e, {type:t, target:this}), u = this[s];
      if (u[t]) {
        for (i = u[t].slice(), n = 0, a = i.length;a > n;n++) {
          i[n].action.call(i[n].context, l);
        }
      }
      r = u[t + "_idx"];
      for (h in r) {
        if (i = r[h].slice()) {
          for (n = 0, a = i.length;a > n;n++) {
            i[n].action.call(i[n].context, l);
          }
        }
      }
      return this;
    }, addOneTimeEventListener:function(t, e, i) {
      if (o.Util.invokeEach(t, this.addOneTimeEventListener, this, e, i)) {
        return this;
      }
      var n = o.bind(function() {
        this.removeEventListener(t, e, i).removeEventListener(t, n, i);
      }, this);
      return this.addEventListener(t, e, i).addEventListener(t, n, i);
    }}, o.Mixin.Events.on = o.Mixin.Events.addEventListener, o.Mixin.Events.off = o.Mixin.Events.removeEventListener, o.Mixin.Events.once = o.Mixin.Events.addOneTimeEventListener, o.Mixin.Events.fire = o.Mixin.Events.fireEvent, function() {
      var n = "ActiveXObject" in t, s = n && !e.addEventListener, a = navigator.userAgent.toLowerCase(), r = -1 !== a.indexOf("webkit"), h = -1 !== a.indexOf("chrome"), l = -1 !== a.indexOf("phantom"), u = -1 !== a.indexOf("android"), c = -1 !== a.search("android [23]"), d = -1 !== a.indexOf("gecko"), p = typeof orientation != i + "", _ = t.navigator && (t.navigator.msPointerEnabled && (t.navigator.msMaxTouchPoints && !t.PointerEvent)), m = t.PointerEvent && (t.navigator.pointerEnabled && t.navigator.maxTouchPoints) || 
      _, f = "devicePixelRatio" in t && t.devicePixelRatio > 1 || "matchMedia" in t && (t.matchMedia("(min-resolution:144dpi)") && t.matchMedia("(min-resolution:144dpi)").matches), g = e.documentElement, v = n && "transition" in g.style, y = "WebKitCSSMatrix" in t && ("m11" in new t.WebKitCSSMatrix && !c), P = "MozPerspective" in g.style, L = "OTransition" in g.style, x = !t.L_DISABLE_3D && ((v || (y || (P || L))) && !l), w = !t.L_NO_TOUCH && (!l && function() {
        var t = "ontouchstart";
        if (m || t in g) {
          return!0;
        }
        var i = e.createElement("div"), n = !1;
        return i.setAttribute ? (i.setAttribute(t, "return;"), "function" == typeof i[t] && (n = !0), i.removeAttribute(t), i = null, n) : !1;
      }());
      o.Browser = {ie:n, ielt9:s, webkit:r, gecko:d && (!r && (!t.opera && !n)), android:u, android23:c, chrome:h, ie3d:v, webkit3d:y, gecko3d:P, opera3d:L, any3d:x, mobile:p, mobileWebkit:p && r, mobileWebkit3d:p && y, mobileOpera:p && t.opera, touch:w, msPointer:_, pointer:m, retina:f};
    }(), o.Point = function(t, e, i) {
      this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e;
    }, o.Point.prototype = {clone:function() {
      return new o.Point(this.x, this.y);
    }, add:function(t) {
      return this.clone()._add(o.point(t));
    }, _add:function(t) {
      return this.x += t.x, this.y += t.y, this;
    }, subtract:function(t) {
      return this.clone()._subtract(o.point(t));
    }, _subtract:function(t) {
      return this.x -= t.x, this.y -= t.y, this;
    }, divideBy:function(t) {
      return this.clone()._divideBy(t);
    }, _divideBy:function(t) {
      return this.x /= t, this.y /= t, this;
    }, multiplyBy:function(t) {
      return this.clone()._multiplyBy(t);
    }, _multiplyBy:function(t) {
      return this.x *= t, this.y *= t, this;
    }, round:function() {
      return this.clone()._round();
    }, _round:function() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }, floor:function() {
      return this.clone()._floor();
    }, _floor:function() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }, distanceTo:function(t) {
      t = o.point(t);
      var e = t.x - this.x, i = t.y - this.y;
      return Math.sqrt(e * e + i * i);
    }, equals:function(t) {
      return t = o.point(t), t.x === this.x && t.y === this.y;
    }, contains:function(t) {
      return t = o.point(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y);
    }, toString:function() {
      return "Point(" + o.Util.formatNum(this.x) + ", " + o.Util.formatNum(this.y) + ")";
    }}, o.point = function(t, e, n) {
      return t instanceof o.Point ? t : o.Util.isArray(t) ? new o.Point(t[0], t[1]) : t === i || null === t ? t : new o.Point(t, e, n);
    }, o.Bounds = function(t, e) {
      if (t) {
        for (var i = e ? [t, e] : t, n = 0, o = i.length;o > n;n++) {
          this.extend(i[n]);
        }
      }
    }, o.Bounds.prototype = {extend:function(t) {
      return t = o.point(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this;
    }, getCenter:function(t) {
      return new o.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t);
    }, getBottomLeft:function() {
      return new o.Point(this.min.x, this.max.y);
    }, getTopRight:function() {
      return new o.Point(this.max.x, this.min.y);
    }, getSize:function() {
      return this.max.subtract(this.min);
    }, contains:function(t) {
      var e, i;
      return t = "number" == typeof t[0] || t instanceof o.Point ? o.point(t) : o.bounds(t), t instanceof o.Bounds ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && (i.x <= this.max.x && (e.y >= this.min.y && i.y <= this.max.y));
    }, intersects:function(t) {
      t = o.bounds(t);
      var e = this.min, i = this.max, n = t.min, s = t.max, a = s.x >= e.x && n.x <= i.x, r = s.y >= e.y && n.y <= i.y;
      return a && r;
    }, isValid:function() {
      return!(!this.min || !this.max);
    }}, o.bounds = function(t, e) {
      return!t || t instanceof o.Bounds ? t : new o.Bounds(t, e);
    }, o.Transformation = function(t, e, i, n) {
      this._a = t, this._b = e, this._c = i, this._d = n;
    }, o.Transformation.prototype = {transform:function(t, e) {
      return this._transform(t.clone(), e);
    }, _transform:function(t, e) {
      return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t;
    }, untransform:function(t, e) {
      return e = e || 1, new o.Point((t.x / e - this._b) / this._a, (t.y / e - this._d) / this._c);
    }}, o.DomUtil = {get:function(t) {
      return "string" == typeof t ? e.getElementById(t) : t;
    }, getStyle:function(t, i) {
      var n = t.style[i];
      if (!n && (t.currentStyle && (n = t.currentStyle[i])), (!n || "auto" === n) && e.defaultView) {
        var o = e.defaultView.getComputedStyle(t, null);
        n = o ? o[i] : null;
      }
      return "auto" === n ? null : n;
    }, getViewportOffset:function(t) {
      var i, n = 0, s = 0, a = t, r = e.body, h = e.documentElement;
      do {
        if (n += a.offsetTop || 0, s += a.offsetLeft || 0, n += parseInt(o.DomUtil.getStyle(a, "borderTopWidth"), 10) || 0, s += parseInt(o.DomUtil.getStyle(a, "borderLeftWidth"), 10) || 0, i = o.DomUtil.getStyle(a, "position"), a.offsetParent === r && "absolute" === i) {
          break;
        }
        if ("fixed" === i) {
          n += r.scrollTop || (h.scrollTop || 0), s += r.scrollLeft || (h.scrollLeft || 0);
          break;
        }
        if ("relative" === i && !a.offsetLeft) {
          var l = o.DomUtil.getStyle(a, "width"), u = o.DomUtil.getStyle(a, "max-width"), c = a.getBoundingClientRect();
          ("none" !== l || "none" !== u) && (s += c.left + a.clientLeft), n += c.top + (r.scrollTop || (h.scrollTop || 0));
          break;
        }
        a = a.offsetParent;
      } while (a);
      a = t;
      do {
        if (a === r) {
          break;
        }
        n -= a.scrollTop || 0, s -= a.scrollLeft || 0, a = a.parentNode;
      } while (a);
      return new o.Point(s, n);
    }, documentIsLtr:function() {
      return o.DomUtil._docIsLtrCached || (o.DomUtil._docIsLtrCached = !0, o.DomUtil._docIsLtr = "ltr" === o.DomUtil.getStyle(e.body, "direction")), o.DomUtil._docIsLtr;
    }, create:function(t, i, n) {
      var o = e.createElement(t);
      return o.className = i, n && n.appendChild(o), o;
    }, hasClass:function(t, e) {
      if (t.classList !== i) {
        return t.classList.contains(e);
      }
      var n = o.DomUtil._getClass(t);
      return n.length > 0 && (new RegExp("(^|\\s)" + e + "(\\s|$)")).test(n);
    }, addClass:function(t, e) {
      if (t.classList !== i) {
        for (var n = o.Util.splitWords(e), s = 0, a = n.length;a > s;s++) {
          t.classList.add(n[s]);
        }
      } else {
        if (!o.DomUtil.hasClass(t, e)) {
          var r = o.DomUtil._getClass(t);
          o.DomUtil._setClass(t, (r ? r + " " : "") + e);
        }
      }
    }, removeClass:function(t, e) {
      t.classList !== i ? t.classList.remove(e) : o.DomUtil._setClass(t, o.Util.trim((" " + o.DomUtil._getClass(t) + " ").replace(" " + e + " ", " ")));
    }, _setClass:function(t, e) {
      t.className.baseVal === i ? t.className = e : t.className.baseVal = e;
    }, _getClass:function(t) {
      return t.className.baseVal === i ? t.className : t.className.baseVal;
    }, setOpacity:function(t, e) {
      if ("opacity" in t.style) {
        t.style.opacity = e;
      } else {
        if ("filter" in t.style) {
          var i = !1, n = "DXImageTransform.Microsoft.Alpha";
          try {
            i = t.filters.item(n);
          } catch (o) {
            if (1 === e) {
              return;
            }
          }
          e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")";
        }
      }
    }, testProp:function(t) {
      for (var i = e.documentElement.style, n = 0;n < t.length;n++) {
        if (t[n] in i) {
          return t[n];
        }
      }
      return!1;
    }, getTranslateString:function(t) {
      var e = o.Browser.webkit3d, i = "translate" + (e ? "3d" : "") + "(", n = (e ? ",0" : "") + ")";
      return i + t.x + "px," + t.y + "px" + n;
    }, getScaleString:function(t, e) {
      var i = o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1 * t))), n = " scale(" + t + ") ";
      return i + n;
    }, setPosition:function(t, e, i) {
      t._leaflet_pos = e, !i && o.Browser.any3d ? t.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(e) : (t.style.left = e.x + "px", t.style.top = e.y + "px");
    }, getPosition:function(t) {
      return t._leaflet_pos;
    }}, o.DomUtil.TRANSFORM = o.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform"]), o.DomUtil.TRANSITION = o.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), o.DomUtil.TRANSITION_END = "webkitTransition" === o.DomUtil.TRANSITION || "OTransition" === o.DomUtil.TRANSITION ? o.DomUtil.TRANSITION + "End" : "transitionend", function() {
      if ("onselectstart" in e) {
        o.extend(o.DomUtil, {disableTextSelection:function() {
          o.DomEvent.on(t, "selectstart", o.DomEvent.preventDefault);
        }, enableTextSelection:function() {
          o.DomEvent.off(t, "selectstart", o.DomEvent.preventDefault);
        }});
      } else {
        var i = o.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
        o.extend(o.DomUtil, {disableTextSelection:function() {
          if (i) {
            var t = e.documentElement.style;
            this._userSelect = t[i], t[i] = "none";
          }
        }, enableTextSelection:function() {
          i && (e.documentElement.style[i] = this._userSelect, delete this._userSelect);
        }});
      }
      o.extend(o.DomUtil, {disableImageDrag:function() {
        o.DomEvent.on(t, "dragstart", o.DomEvent.preventDefault);
      }, enableImageDrag:function() {
        o.DomEvent.off(t, "dragstart", o.DomEvent.preventDefault);
      }});
    }(), o.LatLng = function(t, e, n) {
      if (t = parseFloat(t), e = parseFloat(e), isNaN(t) || isNaN(e)) {
        throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
      }
      this.lat = t, this.lng = e, n !== i && (this.alt = parseFloat(n));
    }, o.extend(o.LatLng, {DEG_TO_RAD:Math.PI / 180, RAD_TO_DEG:180 / Math.PI, MAX_MARGIN:1E-9}), o.LatLng.prototype = {equals:function(t) {
      if (!t) {
        return!1;
      }
      t = o.latLng(t);
      var e = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
      return e <= o.LatLng.MAX_MARGIN;
    }, toString:function(t) {
      return "LatLng(" + o.Util.formatNum(this.lat, t) + ", " + o.Util.formatNum(this.lng, t) + ")";
    }, distanceTo:function(t) {
      t = o.latLng(t);
      var e = 6378137, i = o.LatLng.DEG_TO_RAD, n = (t.lat - this.lat) * i, s = (t.lng - this.lng) * i, a = this.lat * i, r = t.lat * i, h = Math.sin(n / 2), l = Math.sin(s / 2), u = h * h + l * l * Math.cos(a) * Math.cos(r);
      return 2 * e * Math.atan2(Math.sqrt(u), Math.sqrt(1 - u));
    }, wrap:function(t, e) {
      var i = this.lng;
      return t = t || -180, e = e || 180, i = (i + e) % (e - t) + (t > i || i === e ? e : t), new o.LatLng(this.lat, i);
    }}, o.latLng = function(t, e) {
      return t instanceof o.LatLng ? t : o.Util.isArray(t) ? "number" == typeof t[0] || "string" == typeof t[0] ? new o.LatLng(t[0], t[1], t[2]) : null : t === i || null === t ? t : "object" == typeof t && "lat" in t ? new o.LatLng(t.lat, "lng" in t ? t.lng : t.lon) : e === i ? null : new o.LatLng(t, e);
    }, o.LatLngBounds = function(t, e) {
      if (t) {
        for (var i = e ? [t, e] : t, n = 0, o = i.length;o > n;n++) {
          this.extend(i[n]);
        }
      }
    }, o.LatLngBounds.prototype = {extend:function(t) {
      if (!t) {
        return this;
      }
      var e = o.latLng(t);
      return t = null !== e ? e : o.latLngBounds(t), t instanceof o.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(t.lat, this._southWest.lat), this._southWest.lng = Math.min(t.lng, this._southWest.lng), this._northEast.lat = Math.max(t.lat, this._northEast.lat), this._northEast.lng = Math.max(t.lng, this._northEast.lng)) : (this._southWest = new o.LatLng(t.lat, t.lng), this._northEast = new o.LatLng(t.lat, t.lng)) : t instanceof o.LatLngBounds && (this.extend(t._southWest), 
      this.extend(t._northEast)), this;
    }, pad:function(t) {
      var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, s = Math.abs(e.lng - i.lng) * t;
      return new o.LatLngBounds(new o.LatLng(e.lat - n, e.lng - s), new o.LatLng(i.lat + n, i.lng + s));
    }, getCenter:function() {
      return new o.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    }, getSouthWest:function() {
      return this._southWest;
    }, getNorthEast:function() {
      return this._northEast;
    }, getNorthWest:function() {
      return new o.LatLng(this.getNorth(), this.getWest());
    }, getSouthEast:function() {
      return new o.LatLng(this.getSouth(), this.getEast());
    }, getWest:function() {
      return this._southWest.lng;
    }, getSouth:function() {
      return this._southWest.lat;
    }, getEast:function() {
      return this._northEast.lng;
    }, getNorth:function() {
      return this._northEast.lat;
    }, contains:function(t) {
      t = "number" == typeof t[0] || t instanceof o.LatLng ? o.latLng(t) : o.latLngBounds(t);
      var e, i, n = this._southWest, s = this._northEast;
      return t instanceof o.LatLngBounds ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && (i.lat <= s.lat && (e.lng >= n.lng && i.lng <= s.lng));
    }, intersects:function(t) {
      t = o.latLngBounds(t);
      var e = this._southWest, i = this._northEast, n = t.getSouthWest(), s = t.getNorthEast(), a = s.lat >= e.lat && n.lat <= i.lat, r = s.lng >= e.lng && n.lng <= i.lng;
      return a && r;
    }, toBBoxString:function() {
      return[this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
    }, equals:function(t) {
      return t ? (t = o.latLngBounds(t), this._southWest.equals(t.getSouthWest()) && this._northEast.equals(t.getNorthEast())) : !1;
    }, isValid:function() {
      return!(!this._southWest || !this._northEast);
    }}, o.latLngBounds = function(t, e) {
      return!t || t instanceof o.LatLngBounds ? t : new o.LatLngBounds(t, e);
    }, o.Projection = {}, o.Projection.SphericalMercator = {MAX_LATITUDE:85.0511287798, project:function(t) {
      var e = o.LatLng.DEG_TO_RAD, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, t.lat), -i), s = t.lng * e, a = n * e;
      return a = Math.log(Math.tan(Math.PI / 4 + a / 2)), new o.Point(s, a);
    }, unproject:function(t) {
      var e = o.LatLng.RAD_TO_DEG, i = t.x * e, n = (2 * Math.atan(Math.exp(t.y)) - Math.PI / 2) * e;
      return new o.LatLng(n, i);
    }}, o.Projection.LonLat = {project:function(t) {
      return new o.Point(t.lng, t.lat);
    }, unproject:function(t) {
      return new o.LatLng(t.y, t.x);
    }}, o.CRS = {latLngToPoint:function(t, e) {
      var i = this.projection.project(t), n = this.scale(e);
      return this.transformation._transform(i, n);
    }, pointToLatLng:function(t, e) {
      var i = this.scale(e), n = this.transformation.untransform(t, i);
      return this.projection.unproject(n);
    }, project:function(t) {
      return this.projection.project(t);
    }, scale:function(t) {
      return 256 * Math.pow(2, t);
    }, getSize:function(t) {
      var e = this.scale(t);
      return o.point(e, e);
    }}, o.CRS.Simple = o.extend({}, o.CRS, {projection:o.Projection.LonLat, transformation:new o.Transformation(1, 0, -1, 0), scale:function(t) {
      return Math.pow(2, t);
    }}), o.CRS.EPSG3857 = o.extend({}, o.CRS, {code:"EPSG:3857", projection:o.Projection.SphericalMercator, transformation:new o.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5), project:function(t) {
      var e = this.projection.project(t), i = 6378137;
      return e.multiplyBy(i);
    }}), o.CRS.EPSG900913 = o.extend({}, o.CRS.EPSG3857, {code:"EPSG:900913"}), o.CRS.EPSG4326 = o.extend({}, o.CRS, {code:"EPSG:4326", projection:o.Projection.LonLat, transformation:new o.Transformation(1 / 360, 0.5, -1 / 360, 0.5)}), o.Map = o.Class.extend({includes:o.Mixin.Events, options:{crs:o.CRS.EPSG3857, fadeAnimation:o.DomUtil.TRANSITION && !o.Browser.android23, trackResize:!0, markerZoomAnimation:o.DomUtil.TRANSITION && o.Browser.any3d}, initialize:function(t, e) {
      e = o.setOptions(this, e), this._initContainer(t), this._initLayout(), this._onResize = o.bind(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.center && (e.zoom !== i && this.setView(o.latLng(e.center), e.zoom, {reset:!0})), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._tileLayersNum = 0, this.callInitHooks(), this._addLayers(e.layers);
    }, setView:function(t, e) {
      return e = e === i ? this.getZoom() : e, this._resetView(o.latLng(t), this._limitZoom(e)), this;
    }, setZoom:function(t, e) {
      return this._loaded ? this.setView(this.getCenter(), t, {zoom:e}) : (this._zoom = this._limitZoom(t), this);
    }, zoomIn:function(t, e) {
      return this.setZoom(this._zoom + (t || 1), e);
    }, zoomOut:function(t, e) {
      return this.setZoom(this._zoom - (t || 1), e);
    }, setZoomAround:function(t, e, i) {
      var n = this.getZoomScale(e), s = this.getSize().divideBy(2), a = t instanceof o.Point ? t : this.latLngToContainerPoint(t), r = a.subtract(s).multiplyBy(1 - 1 / n), h = this.containerPointToLatLng(s.add(r));
      return this.setView(h, e, {zoom:i});
    }, fitBounds:function(t, e) {
      e = e || {}, t = t.getBounds ? t.getBounds() : o.latLngBounds(t);
      var i = o.point(e.paddingTopLeft || (e.padding || [0, 0])), n = o.point(e.paddingBottomRight || (e.padding || [0, 0])), s = this.getBoundsZoom(t, !1, i.add(n)), a = n.subtract(i).divideBy(2), r = this.project(t.getSouthWest(), s), h = this.project(t.getNorthEast(), s), l = this.unproject(r.add(h).divideBy(2).add(a), s);
      return s = e && e.maxZoom ? Math.min(e.maxZoom, s) : s, this.setView(l, s, e);
    }, fitWorld:function(t) {
      return this.fitBounds([[-90, -180], [90, 180]], t);
    }, panTo:function(t, e) {
      return this.setView(t, this._zoom, {pan:e});
    }, panBy:function(t) {
      return this.fire("movestart"), this._rawPanBy(o.point(t)), this.fire("move"), this.fire("moveend");
    }, setMaxBounds:function(t) {
      return t = o.latLngBounds(t), this.options.maxBounds = t, t ? (this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this);
    }, panInsideBounds:function(t, e) {
      var i = this.getCenter(), n = this._limitCenter(i, this._zoom, t);
      return i.equals(n) ? this : this.panTo(n, e);
    }, addLayer:function(t) {
      var e = o.stamp(t);
      return this._layers[e] ? this : (this._layers[e] = t, !t.options || (isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[e] = t, this._updateZoomLevels())), this.options.zoomAnimation && (o.TileLayer && (t instanceof o.TileLayer && (this._tileLayersNum++, this._tileLayersToLoad++, t.on("load", this._onTileLayerLoad, this)))), this._loaded && this._layerAdd(t), this);
    }, removeLayer:function(t) {
      var e = o.stamp(t);
      return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && this.fire("layerremove", {layer:t}), this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels()), this.options.zoomAnimation && (o.TileLayer && (t instanceof o.TileLayer && (this._tileLayersNum--, this._tileLayersToLoad--, t.off("load", this._onTileLayerLoad, this)))), this) : this;
    }, hasLayer:function(t) {
      return t ? o.stamp(t) in this._layers : !1;
    }, eachLayer:function(t, e) {
      for (var i in this._layers) {
        t.call(e, this._layers[i]);
      }
      return this;
    }, invalidateSize:function(t) {
      if (!this._loaded) {
        return this;
      }
      t = o.extend({animate:!1, pan:!0}, t === !0 ? {animate:!0} : t);
      var e = this.getSize();
      this._sizeChanged = !0, this._initialCenter = null;
      var i = this.getSize(), n = e.divideBy(2).round(), s = i.divideBy(2).round(), a = n.subtract(s);
      return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(o.bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {oldSize:e, newSize:i})) : this;
    }, addHandler:function(t, e) {
      if (!e) {
        return this;
      }
      var i = this[t] = new e(this);
      return this._handlers.push(i), this.options[t] && i.enable(), this;
    }, remove:function() {
      this._loaded && this.fire("unload"), this._initEvents("off");
      try {
        delete this._container._leaflet;
      } catch (t) {
        this._container._leaflet = i;
      }
      return this._clearPanes(), this._clearControlPos && this._clearControlPos(), this._clearHandlers(), this;
    }, getCenter:function() {
      return this._checkIfLoaded(), this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint());
    }, getZoom:function() {
      return this._zoom;
    }, getBounds:function() {
      var t = this.getPixelBounds(), e = this.unproject(t.getBottomLeft()), i = this.unproject(t.getTopRight());
      return new o.LatLngBounds(e, i);
    }, getMinZoom:function() {
      return this.options.minZoom === i ? this._layersMinZoom === i ? 0 : this._layersMinZoom : this.options.minZoom;
    }, getMaxZoom:function() {
      return this.options.maxZoom === i ? this._layersMaxZoom === i ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
    }, getBoundsZoom:function(t, e, i) {
      t = o.latLngBounds(t);
      var n, s = this.getMinZoom() - (e ? 1 : 0), a = this.getMaxZoom(), r = this.getSize(), h = t.getNorthWest(), l = t.getSouthEast(), u = !0;
      i = o.point(i || [0, 0]);
      do {
        s++, n = this.project(l, s).subtract(this.project(h, s)).add(i), u = e ? n.x < r.x || n.y < r.y : r.contains(n);
      } while (u && a >= s);
      return u && e ? null : e ? s : s - 1;
    }, getSize:function() {
      return(!this._size || this._sizeChanged) && (this._size = new o.Point(this._container.clientWidth, this._container.clientHeight), this._sizeChanged = !1), this._size.clone();
    }, getPixelBounds:function() {
      var t = this._getTopLeftPoint();
      return new o.Bounds(t, t.add(this.getSize()));
    }, getPixelOrigin:function() {
      return this._checkIfLoaded(), this._initialTopLeftPoint;
    }, getPanes:function() {
      return this._panes;
    }, getContainer:function() {
      return this._container;
    }, getZoomScale:function(t) {
      var e = this.options.crs;
      return e.scale(t) / e.scale(this._zoom);
    }, getScaleZoom:function(t) {
      return this._zoom + Math.log(t) / Math.LN2;
    }, project:function(t, e) {
      return e = e === i ? this._zoom : e, this.options.crs.latLngToPoint(o.latLng(t), e);
    }, unproject:function(t, e) {
      return e = e === i ? this._zoom : e, this.options.crs.pointToLatLng(o.point(t), e);
    }, layerPointToLatLng:function(t) {
      var e = o.point(t).add(this.getPixelOrigin());
      return this.unproject(e);
    }, latLngToLayerPoint:function(t) {
      var e = this.project(o.latLng(t))._round();
      return e._subtract(this.getPixelOrigin());
    }, containerPointToLayerPoint:function(t) {
      return o.point(t).subtract(this._getMapPanePos());
    }, layerPointToContainerPoint:function(t) {
      return o.point(t).add(this._getMapPanePos());
    }, containerPointToLatLng:function(t) {
      var e = this.containerPointToLayerPoint(o.point(t));
      return this.layerPointToLatLng(e);
    }, latLngToContainerPoint:function(t) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)));
    }, mouseEventToContainerPoint:function(t) {
      return o.DomEvent.getMousePosition(t, this._container);
    }, mouseEventToLayerPoint:function(t) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t));
    }, mouseEventToLatLng:function(t) {
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(t));
    }, _initContainer:function(t) {
      var e = this._container = o.DomUtil.get(t);
      if (!e) {
        throw new Error("Map container not found.");
      }
      if (e._leaflet) {
        throw new Error("Map container is already initialized.");
      }
      e._leaflet = !0;
    }, _initLayout:function() {
      var t = this._container;
      o.DomUtil.addClass(t, "leaflet-container" + (o.Browser.touch ? " leaflet-touch" : "") + (o.Browser.retina ? " leaflet-retina" : "") + (o.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
      var e = o.DomUtil.getStyle(t, "position");
      "absolute" !== e && ("relative" !== e && ("fixed" !== e && (t.style.position = "relative"))), this._initPanes(), this._initControlPos && this._initControlPos();
    }, _initPanes:function() {
      var t = this._panes = {};
      this._mapPane = t.mapPane = this._createPane("leaflet-map-pane", this._container), this._tilePane = t.tilePane = this._createPane("leaflet-tile-pane", this._mapPane), t.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane), t.shadowPane = this._createPane("leaflet-shadow-pane"), t.overlayPane = this._createPane("leaflet-overlay-pane"), t.markerPane = this._createPane("leaflet-marker-pane"), t.popupPane = this._createPane("leaflet-popup-pane");
      var e = " leaflet-zoom-hide";
      this.options.markerZoomAnimation || (o.DomUtil.addClass(t.markerPane, e), o.DomUtil.addClass(t.shadowPane, e), o.DomUtil.addClass(t.popupPane, e));
    }, _createPane:function(t, e) {
      return o.DomUtil.create("div", t, e || this._panes.objectsPane);
    }, _clearPanes:function() {
      this._container.removeChild(this._mapPane);
    }, _addLayers:function(t) {
      t = t ? o.Util.isArray(t) ? t : [t] : [];
      for (var e = 0, i = t.length;i > e;e++) {
        this.addLayer(t[e]);
      }
    }, _resetView:function(t, e, i, n) {
      var s = this._zoom !== e;
      n || (this.fire("movestart"), s && this.fire("zoomstart")), this._zoom = e, this._initialCenter = t, this._initialTopLeftPoint = this._getNewTopLeftPoint(t), i ? this._initialTopLeftPoint._add(this._getMapPanePos()) : o.DomUtil.setPosition(this._mapPane, new o.Point(0, 0)), this._tileLayersToLoad = this._tileLayersNum;
      var a = !this._loaded;
      this._loaded = !0, a && (this.fire("load"), this.eachLayer(this._layerAdd, this)), this.fire("viewreset", {hard:!i}), this.fire("move"), (s || n) && this.fire("zoomend"), this.fire("moveend", {hard:!i});
    }, _rawPanBy:function(t) {
      o.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(t));
    }, _getZoomSpan:function() {
      return this.getMaxZoom() - this.getMinZoom();
    }, _updateZoomLevels:function() {
      var t, e = 1 / 0, n = -1 / 0, o = this._getZoomSpan();
      for (t in this._zoomBoundLayers) {
        var s = this._zoomBoundLayers[t];
        isNaN(s.options.minZoom) || (e = Math.min(e, s.options.minZoom)), isNaN(s.options.maxZoom) || (n = Math.max(n, s.options.maxZoom));
      }
      t === i ? this._layersMaxZoom = this._layersMinZoom = i : (this._layersMaxZoom = n, this._layersMinZoom = e), o !== this._getZoomSpan() && this.fire("zoomlevelschange");
    }, _panInsideMaxBounds:function() {
      this.panInsideBounds(this.options.maxBounds);
    }, _checkIfLoaded:function() {
      if (!this._loaded) {
        throw new Error("Set map center and zoom first.");
      }
    }, _initEvents:function(e) {
      if (o.DomEvent) {
        e = e || "on", o.DomEvent[e](this._container, "click", this._onMouseClick, this);
        var i, n, s = ["dblclick", "mousedown", "mouseup", "mouseenter", "mouseleave", "mousemove", "contextmenu"];
        for (i = 0, n = s.length;n > i;i++) {
          o.DomEvent[e](this._container, s[i], this._fireMouseEvent, this);
        }
        this.options.trackResize && o.DomEvent[e](t, "resize", this._onResize, this);
      }
    }, _onResize:function() {
      o.Util.cancelAnimFrame(this._resizeRequest), this._resizeRequest = o.Util.requestAnimFrame(function() {
        this.invalidateSize({debounceMoveend:!0});
      }, this, !1, this._container);
    }, _onMouseClick:function(t) {
      !this._loaded || (!t._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || (o.DomEvent._skipped(t) || (this.fire("preclick"), this._fireMouseEvent(t))));
    }, _fireMouseEvent:function(t) {
      if (this._loaded && !o.DomEvent._skipped(t)) {
        var e = t.type;
        if (e = "mouseenter" === e ? "mouseover" : "mouseleave" === e ? "mouseout" : e, this.hasEventListeners(e)) {
          "contextmenu" === e && o.DomEvent.preventDefault(t);
          var i = this.mouseEventToContainerPoint(t), n = this.containerPointToLayerPoint(i), s = this.layerPointToLatLng(n);
          this.fire(e, {latlng:s, layerPoint:n, containerPoint:i, originalEvent:t});
        }
      }
    }, _onTileLayerLoad:function() {
      this._tileLayersToLoad--, this._tileLayersNum && (!this._tileLayersToLoad && this.fire("tilelayersload"));
    }, _clearHandlers:function() {
      for (var t = 0, e = this._handlers.length;e > t;t++) {
        this._handlers[t].disable();
      }
    }, whenReady:function(t, e) {
      return this._loaded ? t.call(e || this, this) : this.on("load", t, e), this;
    }, _layerAdd:function(t) {
      t.onAdd(this), this.fire("layeradd", {layer:t});
    }, _getMapPanePos:function() {
      return o.DomUtil.getPosition(this._mapPane);
    }, _moved:function() {
      var t = this._getMapPanePos();
      return t && !t.equals([0, 0]);
    }, _getTopLeftPoint:function() {
      return this.getPixelOrigin().subtract(this._getMapPanePos());
    }, _getNewTopLeftPoint:function(t, e) {
      var i = this.getSize()._divideBy(2);
      return this.project(t, e)._subtract(i)._round();
    }, _latLngToNewLayerPoint:function(t, e, i) {
      var n = this._getNewTopLeftPoint(i, e).add(this._getMapPanePos());
      return this.project(t, e)._subtract(n);
    }, _getCenterLayerPoint:function() {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    }, _getCenterOffset:function(t) {
      return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint());
    }, _limitCenter:function(t, e, i) {
      if (!i) {
        return t;
      }
      var n = this.project(t, e), s = this.getSize().divideBy(2), a = new o.Bounds(n.subtract(s), n.add(s)), r = this._getBoundsOffset(a, i, e);
      return this.unproject(n.add(r), e);
    }, _limitOffset:function(t, e) {
      if (!e) {
        return t;
      }
      var i = this.getPixelBounds(), n = new o.Bounds(i.min.add(t), i.max.add(t));
      return t.add(this._getBoundsOffset(n, e));
    }, _getBoundsOffset:function(t, e, i) {
      var n = this.project(e.getNorthWest(), i).subtract(t.min), s = this.project(e.getSouthEast(), i).subtract(t.max), a = this._rebound(n.x, -s.x), r = this._rebound(n.y, -s.y);
      return new o.Point(a, r);
    }, _rebound:function(t, e) {
      return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e));
    }, _limitZoom:function(t) {
      var e = this.getMinZoom(), i = this.getMaxZoom();
      return Math.max(e, Math.min(i, t));
    }}), o.map = function(t, e) {
      return new o.Map(t, e);
    }, o.Projection.Mercator = {MAX_LATITUDE:85.0840591556, R_MINOR:6356752.314245179, R_MAJOR:6378137, project:function(t) {
      var e = o.LatLng.DEG_TO_RAD, i = this.MAX_LATITUDE, n = Math.max(Math.min(i, t.lat), -i), s = this.R_MAJOR, a = this.R_MINOR, r = t.lng * e * s, h = n * e, l = a / s, u = Math.sqrt(1 - l * l), c = u * Math.sin(h);
      c = Math.pow((1 - c) / (1 + c), 0.5 * u);
      var d = Math.tan(0.5 * (0.5 * Math.PI - h)) / c;
      return h = -s * Math.log(d), new o.Point(r, h);
    }, unproject:function(t) {
      for (var e, i = o.LatLng.RAD_TO_DEG, n = this.R_MAJOR, s = this.R_MINOR, a = t.x * i / n, r = s / n, h = Math.sqrt(1 - r * r), l = Math.exp(-t.y / n), u = Math.PI / 2 - 2 * Math.atan(l), c = 15, d = 1E-7, p = c, _ = 0.1;Math.abs(_) > d && --p > 0;) {
        e = h * Math.sin(u), _ = Math.PI / 2 - 2 * Math.atan(l * Math.pow((1 - e) / (1 + e), 0.5 * h)) - u, u += _;
      }
      return new o.LatLng(u * i, a);
    }}, o.CRS.EPSG3395 = o.extend({}, o.CRS, {code:"EPSG:3395", projection:o.Projection.Mercator, transformation:function() {
      var t = o.Projection.Mercator, e = t.R_MAJOR, i = 0.5 / (Math.PI * e);
      return new o.Transformation(i, 0.5, -i, 0.5);
    }()}), o.TileLayer = o.Class.extend({includes:o.Mixin.Events, options:{minZoom:0, maxZoom:18, tileSize:256, subdomains:"abc", errorTileUrl:"", attribution:"", zoomOffset:0, opacity:1, unloadInvisibleTiles:o.Browser.mobile, updateWhenIdle:o.Browser.mobile}, initialize:function(t, e) {
      e = o.setOptions(this, e), e.detectRetina && (o.Browser.retina && (e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomOffset++, e.minZoom > 0 && e.minZoom--, this.options.maxZoom--))), e.bounds && (e.bounds = o.latLngBounds(e.bounds)), this._url = t;
      var i = this.options.subdomains;
      "string" == typeof i && (this.options.subdomains = i.split(""));
    }, onAdd:function(t) {
      this._map = t, this._animated = t._zoomAnimated, this._initContainer(), t.on({viewreset:this._reset, moveend:this._update}, this), this._animated && t.on({zoomanim:this._animateZoom, zoomend:this._endZoomAnim}, this), this.options.updateWhenIdle || (this._limitedUpdate = o.Util.limitExecByInterval(this._update, 150, this), t.on("move", this._limitedUpdate, this)), this._reset(), this._update();
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, onRemove:function(t) {
      this._container.parentNode.removeChild(this._container), t.off({viewreset:this._reset, moveend:this._update}, this), this._animated && t.off({zoomanim:this._animateZoom, zoomend:this._endZoomAnim}, this), this.options.updateWhenIdle || t.off("move", this._limitedUpdate, this), this._container = null, this._map = null;
    }, bringToFront:function() {
      var t = this._map._panes.tilePane;
      return this._container && (t.appendChild(this._container), this._setAutoZIndex(t, Math.max)), this;
    }, bringToBack:function() {
      var t = this._map._panes.tilePane;
      return this._container && (t.insertBefore(this._container, t.firstChild), this._setAutoZIndex(t, Math.min)), this;
    }, getAttribution:function() {
      return this.options.attribution;
    }, getContainer:function() {
      return this._container;
    }, setOpacity:function(t) {
      return this.options.opacity = t, this._map && this._updateOpacity(), this;
    }, setZIndex:function(t) {
      return this.options.zIndex = t, this._updateZIndex(), this;
    }, setUrl:function(t, e) {
      return this._url = t, e || this.redraw(), this;
    }, redraw:function() {
      return this._map && (this._reset({hard:!0}), this._update()), this;
    }, _updateZIndex:function() {
      this._container && (this.options.zIndex !== i && (this._container.style.zIndex = this.options.zIndex));
    }, _setAutoZIndex:function(t, e) {
      var i, n, o, s = t.children, a = -e(1 / 0, -1 / 0);
      for (n = 0, o = s.length;o > n;n++) {
        s[n] !== this._container && (i = parseInt(s[n].style.zIndex, 10), isNaN(i) || (a = e(a, i)));
      }
      this.options.zIndex = this._container.style.zIndex = (isFinite(a) ? a : 0) + e(1, -1);
    }, _updateOpacity:function() {
      var t, e = this._tiles;
      if (o.Browser.ielt9) {
        for (t in e) {
          o.DomUtil.setOpacity(e[t], this.options.opacity);
        }
      } else {
        o.DomUtil.setOpacity(this._container, this.options.opacity);
      }
    }, _initContainer:function() {
      var t = this._map._panes.tilePane;
      if (!this._container) {
        if (this._container = o.DomUtil.create("div", "leaflet-layer"), this._updateZIndex(), this._animated) {
          var e = "leaflet-tile-container";
          this._bgBuffer = o.DomUtil.create("div", e, this._container), this._tileContainer = o.DomUtil.create("div", e, this._container);
        } else {
          this._tileContainer = this._container;
        }
        t.appendChild(this._container), this.options.opacity < 1 && this._updateOpacity();
      }
    }, _reset:function(t) {
      for (var e in this._tiles) {
        this.fire("tileunload", {tile:this._tiles[e]});
      }
      this._tiles = {}, this._tilesToLoad = 0, this.options.reuseTiles && (this._unusedTiles = []), this._tileContainer.innerHTML = "", this._animated && (t && (t.hard && this._clearBgBuffer())), this._initContainer();
    }, _getTileSize:function() {
      var t = this._map, e = t.getZoom() + this.options.zoomOffset, i = this.options.maxNativeZoom, n = this.options.tileSize;
      return i && (e > i && (n = Math.round(t.getZoomScale(e) / t.getZoomScale(i) * n))), n;
    }, _update:function() {
      if (this._map) {
        var t = this._map, e = t.getPixelBounds(), i = t.getZoom(), n = this._getTileSize();
        if (!(i > this.options.maxZoom || i < this.options.minZoom)) {
          var s = o.bounds(e.min.divideBy(n)._floor(), e.max.divideBy(n)._floor());
          this._addTilesFromCenterOut(s), (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(s);
        }
      }
    }, _addTilesFromCenterOut:function(t) {
      var i, n, s, a = [], r = t.getCenter();
      for (i = t.min.y;i <= t.max.y;i++) {
        for (n = t.min.x;n <= t.max.x;n++) {
          s = new o.Point(n, i), this._tileShouldBeLoaded(s) && a.push(s);
        }
      }
      var h = a.length;
      if (0 !== h) {
        a.sort(function(t, e) {
          return t.distanceTo(r) - e.distanceTo(r);
        });
        var l = e.createDocumentFragment();
        for (this._tilesToLoad || this.fire("loading"), this._tilesToLoad += h, n = 0;h > n;n++) {
          this._addTile(a[n], l);
        }
        this._tileContainer.appendChild(l);
      }
    }, _tileShouldBeLoaded:function(t) {
      if (t.x + ":" + t.y in this._tiles) {
        return!1;
      }
      var e = this.options;
      if (!e.continuousWorld) {
        var i = this._getWrapTileNum();
        if (e.noWrap && (t.x < 0 || t.x >= i.x) || (t.y < 0 || t.y >= i.y)) {
          return!1;
        }
      }
      if (e.bounds) {
        var n = e.tileSize, o = t.multiplyBy(n), s = o.add([n, n]), a = this._map.unproject(o), r = this._map.unproject(s);
        if (e.continuousWorld || (e.noWrap || (a = a.wrap(), r = r.wrap())), !e.bounds.intersects([a, r])) {
          return!1;
        }
      }
      return!0;
    }, _removeOtherTiles:function(t) {
      var e, i, n, o;
      for (o in this._tiles) {
        e = o.split(":"), i = parseInt(e[0], 10), n = parseInt(e[1], 10), (i < t.min.x || (i > t.max.x || (n < t.min.y || n > t.max.y))) && this._removeTile(o);
      }
    }, _removeTile:function(t) {
      var e = this._tiles[t];
      this.fire("tileunload", {tile:e, url:e.src}), this.options.reuseTiles ? (o.DomUtil.removeClass(e, "leaflet-tile-loaded"), this._unusedTiles.push(e)) : e.parentNode === this._tileContainer && this._tileContainer.removeChild(e), o.Browser.android || (e.onload = null, e.src = o.Util.emptyImageUrl), delete this._tiles[t];
    }, _addTile:function(t, e) {
      var i = this._getTilePos(t), n = this._getTile();
      o.DomUtil.setPosition(n, i, o.Browser.chrome), this._tiles[t.x + ":" + t.y] = n, this._loadTile(n, t), n.parentNode !== this._tileContainer && e.appendChild(n);
    }, _getZoomForUrl:function() {
      var t = this.options, e = this._map.getZoom();
      return t.zoomReverse && (e = t.maxZoom - e), e += t.zoomOffset, t.maxNativeZoom ? Math.min(e, t.maxNativeZoom) : e;
    }, _getTilePos:function(t) {
      var e = this._map.getPixelOrigin(), i = this._getTileSize();
      return t.multiplyBy(i).subtract(e);
    }, getTileUrl:function(t) {
      return o.Util.template(this._url, o.extend({s:this._getSubdomain(t), z:t.z, x:t.x, y:t.y}, this.options));
    }, _getWrapTileNum:function() {
      var t = this._map.options.crs, e = t.getSize(this._map.getZoom());
      return e.divideBy(this._getTileSize())._floor();
    }, _adjustTilePoint:function(t) {
      var e = this._getWrapTileNum();
      this.options.continuousWorld || (this.options.noWrap || (t.x = (t.x % e.x + e.x) % e.x)), this.options.tms && (t.y = e.y - t.y - 1), t.z = this._getZoomForUrl();
    }, _getSubdomain:function(t) {
      var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
      return this.options.subdomains[e];
    }, _getTile:function() {
      if (this.options.reuseTiles && this._unusedTiles.length > 0) {
        var t = this._unusedTiles.pop();
        return this._resetTile(t), t;
      }
      return this._createTile();
    }, _resetTile:function() {
    }, _createTile:function() {
      var t = o.DomUtil.create("img", "leaflet-tile");
      return t.style.width = t.style.height = this._getTileSize() + "px", t.galleryimg = "no", t.onselectstart = t.onmousemove = o.Util.falseFn, o.Browser.ielt9 && (this.options.opacity !== i && o.DomUtil.setOpacity(t, this.options.opacity)), o.Browser.mobileWebkit3d && (t.style.WebkitBackfaceVisibility = "hidden"), t;
    }, _loadTile:function(t, e) {
      t._layer = this, t.onload = this._tileOnLoad, t.onerror = this._tileOnError, this._adjustTilePoint(e), t.src = this.getTileUrl(e), this.fire("tileloadstart", {tile:t, url:t.src});
    }, _tileLoaded:function() {
      this._tilesToLoad--, this._animated && o.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated"), this._tilesToLoad || (this.fire("load"), this._animated && (clearTimeout(this._clearBgBufferTimer), this._clearBgBufferTimer = setTimeout(o.bind(this._clearBgBuffer, this), 500)));
    }, _tileOnLoad:function() {
      var t = this._layer;
      this.src !== o.Util.emptyImageUrl && (o.DomUtil.addClass(this, "leaflet-tile-loaded"), t.fire("tileload", {tile:this, url:this.src})), t._tileLoaded();
    }, _tileOnError:function() {
      var t = this._layer;
      t.fire("tileerror", {tile:this, url:this.src});
      var e = t.options.errorTileUrl;
      e && (this.src = e), t._tileLoaded();
    }}), o.tileLayer = function(t, e) {
      return new o.TileLayer(t, e);
    }, o.TileLayer.WMS = o.TileLayer.extend({defaultWmsParams:{service:"WMS", request:"GetMap", version:"1.1.1", layers:"", styles:"", format:"image/jpeg", transparent:!1}, initialize:function(t, e) {
      this._url = t;
      var i = o.extend({}, this.defaultWmsParams), n = e.tileSize || this.options.tileSize;
      i.width = i.height = e.detectRetina && o.Browser.retina ? 2 * n : n;
      for (var s in e) {
        this.options.hasOwnProperty(s) || ("crs" === s || (i[s] = e[s]));
      }
      this.wmsParams = i, o.setOptions(this, e);
    }, onAdd:function(t) {
      this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
      var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
      this.wmsParams[e] = this._crs.code, o.TileLayer.prototype.onAdd.call(this, t);
    }, getTileUrl:function(t) {
      var e = this._map, i = this.options.tileSize, n = t.multiplyBy(i), s = n.add([i, i]), a = this._crs.project(e.unproject(n, t.z)), r = this._crs.project(e.unproject(s, t.z)), h = this._wmsVersion >= 1.3 && this._crs === o.CRS.EPSG4326 ? [r.y, a.x, a.y, r.x].join(",") : [a.x, r.y, r.x, a.y].join(","), l = o.Util.template(this._url, {s:this._getSubdomain(t)});
      return l + o.Util.getParamString(this.wmsParams, l, !0) + "&BBOX=" + h;
    }, setParams:function(t, e) {
      return o.extend(this.wmsParams, t), e || this.redraw(), this;
    }}), o.tileLayer.wms = function(t, e) {
      return new o.TileLayer.WMS(t, e);
    }, o.TileLayer.Canvas = o.TileLayer.extend({options:{async:!1}, initialize:function(t) {
      o.setOptions(this, t);
    }, redraw:function() {
      this._map && (this._reset({hard:!0}), this._update());
      for (var t in this._tiles) {
        this._redrawTile(this._tiles[t]);
      }
      return this;
    }, _redrawTile:function(t) {
      this.drawTile(t, t._tilePoint, this._map._zoom);
    }, _createTile:function() {
      var t = o.DomUtil.create("canvas", "leaflet-tile");
      return t.width = t.height = this.options.tileSize, t.onselectstart = t.onmousemove = o.Util.falseFn, t;
    }, _loadTile:function(t, e) {
      t._layer = this, t._tilePoint = e, this._redrawTile(t), this.options.async || this.tileDrawn(t);
    }, drawTile:function() {
    }, tileDrawn:function(t) {
      this._tileOnLoad.call(t);
    }}), o.tileLayer.canvas = function(t) {
      return new o.TileLayer.Canvas(t);
    }, o.ImageOverlay = o.Class.extend({includes:o.Mixin.Events, options:{opacity:1}, initialize:function(t, e, i) {
      this._url = t, this._bounds = o.latLngBounds(e), o.setOptions(this, i);
    }, onAdd:function(t) {
      this._map = t, this._image || this._initImage(), t._panes.overlayPane.appendChild(this._image), t.on("viewreset", this._reset, this), t.options.zoomAnimation && (o.Browser.any3d && t.on("zoomanim", this._animateZoom, this)), this._reset();
    }, onRemove:function(t) {
      t.getPanes().overlayPane.removeChild(this._image), t.off("viewreset", this._reset, this), t.options.zoomAnimation && t.off("zoomanim", this._animateZoom, this);
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, setOpacity:function(t) {
      return this.options.opacity = t, this._updateOpacity(), this;
    }, bringToFront:function() {
      return this._image && this._map._panes.overlayPane.appendChild(this._image), this;
    }, bringToBack:function() {
      var t = this._map._panes.overlayPane;
      return this._image && t.insertBefore(this._image, t.firstChild), this;
    }, setUrl:function(t) {
      this._url = t, this._image.src = this._url;
    }, getAttribution:function() {
      return this.options.attribution;
    }, _initImage:function() {
      this._image = o.DomUtil.create("img", "leaflet-image-layer"), this._map.options.zoomAnimation && o.Browser.any3d ? o.DomUtil.addClass(this._image, "leaflet-zoom-animated") : o.DomUtil.addClass(this._image, "leaflet-zoom-hide"), this._updateOpacity(), o.extend(this._image, {galleryimg:"no", onselectstart:o.Util.falseFn, onmousemove:o.Util.falseFn, onload:o.bind(this._onImageLoad, this), src:this._url});
    }, _animateZoom:function(t) {
      var e = this._map, i = this._image, n = e.getZoomScale(t.zoom), s = this._bounds.getNorthWest(), a = this._bounds.getSouthEast(), r = e._latLngToNewLayerPoint(s, t.zoom, t.center), h = e._latLngToNewLayerPoint(a, t.zoom, t.center)._subtract(r), l = r._add(h._multiplyBy(0.5 * (1 - 1 / n)));
      i.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(l) + " scale(" + n + ") ";
    }, _reset:function() {
      var t = this._image, e = this._map.latLngToLayerPoint(this._bounds.getNorthWest()), i = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);
      o.DomUtil.setPosition(t, e), t.style.width = i.x + "px", t.style.height = i.y + "px";
    }, _onImageLoad:function() {
      this.fire("load");
    }, _updateOpacity:function() {
      o.DomUtil.setOpacity(this._image, this.options.opacity);
    }}), o.imageOverlay = function(t, e, i) {
      return new o.ImageOverlay(t, e, i);
    }, o.Icon = o.Class.extend({options:{className:""}, initialize:function(t) {
      o.setOptions(this, t);
    }, createIcon:function(t) {
      return this._createIcon("icon", t);
    }, createShadow:function(t) {
      return this._createIcon("shadow", t);
    }, _createIcon:function(t, e) {
      var i = this._getIconUrl(t);
      if (!i) {
        if ("icon" === t) {
          throw new Error("iconUrl not set in Icon options (see the docs).");
        }
        return null;
      }
      var n;
      return n = e && "IMG" === e.tagName ? this._createImg(i, e) : this._createImg(i), this._setIconStyles(n, t), n;
    }, _setIconStyles:function(t, e) {
      var i, n = this.options, s = o.point(n[e + "Size"]);
      i = o.point("shadow" === e ? n.shadowAnchor || n.iconAnchor : n.iconAnchor), !i && (s && (i = s.divideBy(2, !0))), t.className = "leaflet-marker-" + e + " " + n.className, i && (t.style.marginLeft = -i.x + "px", t.style.marginTop = -i.y + "px"), s && (t.style.width = s.x + "px", t.style.height = s.y + "px");
    }, _createImg:function(t, i) {
      return i = i || e.createElement("img"), i.src = t, i;
    }, _getIconUrl:function(t) {
      return o.Browser.retina && this.options[t + "RetinaUrl"] ? this.options[t + "RetinaUrl"] : this.options[t + "Url"];
    }}), o.icon = function(t) {
      return new o.Icon(t);
    }, o.Icon.Default = o.Icon.extend({options:{iconSize:[25, 41], iconAnchor:[12, 41], popupAnchor:[1, -34], shadowSize:[41, 41]}, _getIconUrl:function(t) {
      var e = t + "Url";
      if (this.options[e]) {
        return this.options[e];
      }
      o.Browser.retina && ("icon" === t && (t += "-2x"));
      var i = o.Icon.Default.imagePath;
      if (!i) {
        throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
      }
      return i + "/marker-" + t + ".png";
    }}), o.Icon.Default.imagePath = function() {
      var t, i, n, o, s, a = e.getElementsByTagName("script"), r = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
      for (t = 0, i = a.length;i > t;t++) {
        if (n = a[t].src, o = n.match(r)) {
          return s = n.split(r)[0], (s ? s + "/" : "") + "images";
        }
      }
    }(), o.Marker = o.Class.extend({includes:o.Mixin.Events, options:{icon:new o.Icon.Default, title:"", alt:"", clickable:!0, draggable:!1, keyboard:!0, zIndexOffset:0, opacity:1, riseOnHover:!1, riseOffset:250}, initialize:function(t, e) {
      o.setOptions(this, e), this._latlng = o.latLng(t);
    }, onAdd:function(t) {
      this._map = t, t.on("viewreset", this.update, this), this._initIcon(), this.update(), this.fire("add"), t.options.zoomAnimation && (t.options.markerZoomAnimation && t.on("zoomanim", this._animateZoom, this));
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, onRemove:function(t) {
      this.dragging && this.dragging.disable(), this._removeIcon(), this._removeShadow(), this.fire("remove"), t.off({viewreset:this.update, zoomanim:this._animateZoom}, this), this._map = null;
    }, getLatLng:function() {
      return this._latlng;
    }, setLatLng:function(t) {
      return this._latlng = o.latLng(t), this.update(), this.fire("move", {latlng:this._latlng});
    }, setZIndexOffset:function(t) {
      return this.options.zIndexOffset = t, this.update(), this;
    }, setIcon:function(t) {
      return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup), this;
    }, update:function() {
      if (this._icon) {
        var t = this._map.latLngToLayerPoint(this._latlng).round();
        this._setPos(t);
      }
      return this;
    }, _initIcon:function() {
      var t = this.options, e = this._map, i = e.options.zoomAnimation && e.options.markerZoomAnimation, n = i ? "leaflet-zoom-animated" : "leaflet-zoom-hide", s = t.icon.createIcon(this._icon), a = !1;
      s !== this._icon && (this._icon && this._removeIcon(), a = !0, t.title && (s.title = t.title), t.alt && (s.alt = t.alt)), o.DomUtil.addClass(s, n), t.keyboard && (s.tabIndex = "0"), this._icon = s, this._initInteraction(), t.riseOnHover && o.DomEvent.on(s, "mouseover", this._bringToFront, this).on(s, "mouseout", this._resetZIndex, this);
      var r = t.icon.createShadow(this._shadow), h = !1;
      r !== this._shadow && (this._removeShadow(), h = !0), r && o.DomUtil.addClass(r, n), this._shadow = r, t.opacity < 1 && this._updateOpacity();
      var l = this._map._panes;
      a && l.markerPane.appendChild(this._icon), r && (h && l.shadowPane.appendChild(this._shadow));
    }, _removeIcon:function() {
      this.options.riseOnHover && o.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex), this._map._panes.markerPane.removeChild(this._icon), this._icon = null;
    }, _removeShadow:function() {
      this._shadow && this._map._panes.shadowPane.removeChild(this._shadow), this._shadow = null;
    }, _setPos:function(t) {
      o.DomUtil.setPosition(this._icon, t), this._shadow && o.DomUtil.setPosition(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex();
    }, _updateZIndex:function(t) {
      this._icon.style.zIndex = this._zIndex + t;
    }, _animateZoom:function(t) {
      var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
      this._setPos(e);
    }, _initInteraction:function() {
      if (this.options.clickable) {
        var t = this._icon, e = ["dblclick", "mousedown", "mouseover", "mouseout", "contextmenu"];
        o.DomUtil.addClass(t, "leaflet-clickable"), o.DomEvent.on(t, "click", this._onMouseClick, this), o.DomEvent.on(t, "keypress", this._onKeyPress, this);
        for (var i = 0;i < e.length;i++) {
          o.DomEvent.on(t, e[i], this._fireMouseEvent, this);
        }
        o.Handler.MarkerDrag && (this.dragging = new o.Handler.MarkerDrag(this), this.options.draggable && this.dragging.enable());
      }
    }, _onMouseClick:function(t) {
      var e = this.dragging && this.dragging.moved();
      (this.hasEventListeners(t.type) || e) && o.DomEvent.stopPropagation(t), e || (this.dragging && this.dragging._enabled || (!this._map.dragging || !this._map.dragging.moved())) && this.fire(t.type, {originalEvent:t, latlng:this._latlng});
    }, _onKeyPress:function(t) {
      13 === t.keyCode && this.fire("click", {originalEvent:t, latlng:this._latlng});
    }, _fireMouseEvent:function(t) {
      this.fire(t.type, {originalEvent:t, latlng:this._latlng}), "contextmenu" === t.type && (this.hasEventListeners(t.type) && o.DomEvent.preventDefault(t)), "mousedown" !== t.type ? o.DomEvent.stopPropagation(t) : o.DomEvent.preventDefault(t);
    }, setOpacity:function(t) {
      return this.options.opacity = t, this._map && this._updateOpacity(), this;
    }, _updateOpacity:function() {
      o.DomUtil.setOpacity(this._icon, this.options.opacity), this._shadow && o.DomUtil.setOpacity(this._shadow, this.options.opacity);
    }, _bringToFront:function() {
      this._updateZIndex(this.options.riseOffset);
    }, _resetZIndex:function() {
      this._updateZIndex(0);
    }}), o.marker = function(t, e) {
      return new o.Marker(t, e);
    }, o.DivIcon = o.Icon.extend({options:{iconSize:[12, 12], className:"leaflet-div-icon", html:!1}, createIcon:function(t) {
      var i = t && "DIV" === t.tagName ? t : e.createElement("div"), n = this.options;
      return i.innerHTML = n.html !== !1 ? n.html : "", n.bgPos && (i.style.backgroundPosition = -n.bgPos.x + "px " + -n.bgPos.y + "px"), this._setIconStyles(i, "icon"), i;
    }, createShadow:function() {
      return null;
    }}), o.divIcon = function(t) {
      return new o.DivIcon(t);
    }, o.Map.mergeOptions({closePopupOnClick:!0}), o.Popup = o.Class.extend({includes:o.Mixin.Events, options:{minWidth:50, maxWidth:300, autoPan:!0, closeButton:!0, offset:[0, 7], autoPanPadding:[5, 5], keepInView:!1, className:"", zoomAnimation:!0}, initialize:function(t, e) {
      o.setOptions(this, t), this._source = e, this._animated = o.Browser.any3d && this.options.zoomAnimation, this._isOpen = !1;
    }, onAdd:function(t) {
      this._map = t, this._container || this._initLayout();
      var e = t.options.fadeAnimation;
      e && o.DomUtil.setOpacity(this._container, 0), t._panes.popupPane.appendChild(this._container), t.on(this._getEvents(), this), this.update(), e && o.DomUtil.setOpacity(this._container, 1), this.fire("open"), t.fire("popupopen", {popup:this}), this._source && this._source.fire("popupopen", {popup:this});
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, openOn:function(t) {
      return t.openPopup(this), this;
    }, onRemove:function(t) {
      t._panes.popupPane.removeChild(this._container), o.Util.falseFn(this._container.offsetWidth), t.off(this._getEvents(), this), t.options.fadeAnimation && o.DomUtil.setOpacity(this._container, 0), this._map = null, this.fire("close"), t.fire("popupclose", {popup:this}), this._source && this._source.fire("popupclose", {popup:this});
    }, getLatLng:function() {
      return this._latlng;
    }, setLatLng:function(t) {
      return this._latlng = o.latLng(t), this._map && (this._updatePosition(), this._adjustPan()), this;
    }, getContent:function() {
      return this._content;
    }, setContent:function(t) {
      return this._content = t, this.update(), this;
    }, update:function() {
      this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
    }, _getEvents:function() {
      var t = {viewreset:this._updatePosition};
      return this._animated && (t.zoomanim = this._zoomAnimation), ("closeOnClick" in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t;
    }, _close:function() {
      this._map && this._map.closePopup(this);
    }, _initLayout:function() {
      var t, e = "leaflet-popup", i = e + " " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"), n = this._container = o.DomUtil.create("div", i);
      this.options.closeButton && (t = this._closeButton = o.DomUtil.create("a", e + "-close-button", n), t.href = "#close", t.innerHTML = "&#215;", o.DomEvent.disableClickPropagation(t), o.DomEvent.on(t, "click", this._onCloseButtonClick, this));
      var s = this._wrapper = o.DomUtil.create("div", e + "-content-wrapper", n);
      o.DomEvent.disableClickPropagation(s), this._contentNode = o.DomUtil.create("div", e + "-content", s), o.DomEvent.disableScrollPropagation(this._contentNode), o.DomEvent.on(s, "contextmenu", o.DomEvent.stopPropagation), this._tipContainer = o.DomUtil.create("div", e + "-tip-container", n), this._tip = o.DomUtil.create("div", e + "-tip", this._tipContainer);
    }, _updateContent:function() {
      if (this._content) {
        if ("string" == typeof this._content) {
          this._contentNode.innerHTML = this._content;
        } else {
          for (;this._contentNode.hasChildNodes();) {
            this._contentNode.removeChild(this._contentNode.firstChild);
          }
          this._contentNode.appendChild(this._content);
        }
        this.fire("contentupdate");
      }
    }, _updateLayout:function() {
      var t = this._contentNode, e = t.style;
      e.width = "", e.whiteSpace = "nowrap";
      var i = t.offsetWidth;
      i = Math.min(i, this.options.maxWidth), i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "";
      var n = t.offsetHeight, s = this.options.maxHeight, a = "leaflet-popup-scrolled";
      s && n > s ? (e.height = s + "px", o.DomUtil.addClass(t, a)) : o.DomUtil.removeClass(t, a), this._containerWidth = this._container.offsetWidth;
    }, _updatePosition:function() {
      if (this._map) {
        var t = this._map.latLngToLayerPoint(this._latlng), e = this._animated, i = o.point(this.options.offset);
        e && o.DomUtil.setPosition(this._container, t), this._containerBottom = -i.y - (e ? 0 : t.y), this._containerLeft = -Math.round(this._containerWidth / 2) + i.x + (e ? 0 : t.x), this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px";
      }
    }, _zoomAnimation:function(t) {
      var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
      o.DomUtil.setPosition(this._container, e);
    }, _adjustPan:function() {
      if (this.options.autoPan) {
        var t = this._map, e = this._container.offsetHeight, i = this._containerWidth, n = new o.Point(this._containerLeft, -e - this._containerBottom);
        this._animated && n._add(o.DomUtil.getPosition(this._container));
        var s = t.layerPointToContainerPoint(n), a = o.point(this.options.autoPanPadding), r = o.point(this.options.autoPanPaddingTopLeft || a), h = o.point(this.options.autoPanPaddingBottomRight || a), l = t.getSize(), u = 0, c = 0;
        s.x + i + h.x > l.x && (u = s.x + i - l.x + h.x), s.x - u - r.x < 0 && (u = s.x - r.x), s.y + e + h.y > l.y && (c = s.y + e - l.y + h.y), s.y - c - r.y < 0 && (c = s.y - r.y), (u || c) && t.fire("autopanstart").panBy([u, c]);
      }
    }, _onCloseButtonClick:function(t) {
      this._close(), o.DomEvent.stop(t);
    }}), o.popup = function(t, e) {
      return new o.Popup(t, e);
    }, o.Map.include({openPopup:function(t, e, i) {
      if (this.closePopup(), !(t instanceof o.Popup)) {
        var n = t;
        t = (new o.Popup(i)).setLatLng(e).setContent(n);
      }
      return t._isOpen = !0, this._popup = t, this.addLayer(t);
    }, closePopup:function(t) {
      return t && t !== this._popup || (t = this._popup, this._popup = null), t && (this.removeLayer(t), t._isOpen = !1), this;
    }}), o.Marker.include({openPopup:function() {
      return this._popup && (this._map && (!this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng), this._map.openPopup(this._popup)))), this;
    }, closePopup:function() {
      return this._popup && this._popup._close(), this;
    }, togglePopup:function() {
      return this._popup && (this._popup._isOpen ? this.closePopup() : this.openPopup()), this;
    }, bindPopup:function(t, e) {
      var i = o.point(this.options.icon.options.popupAnchor || [0, 0]);
      return i = i.add(o.Popup.prototype.options.offset), e && (e.offset && (i = i.add(e.offset))), e = o.extend({offset:i}, e), this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this), this._popupHandlersAdded = !0), t instanceof o.Popup ? (o.setOptions(t, e), this._popup = t) : this._popup = (new o.Popup(e, this)).setContent(t), this;
    }, setPopupContent:function(t) {
      return this._popup && this._popup.setContent(t), this;
    }, unbindPopup:function() {
      return this._popup && (this._popup = null, this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this), this._popupHandlersAdded = !1), this;
    }, getPopup:function() {
      return this._popup;
    }, _movePopup:function(t) {
      this._popup.setLatLng(t.latlng);
    }}), o.LayerGroup = o.Class.extend({initialize:function(t) {
      this._layers = {};
      var e, i;
      if (t) {
        for (e = 0, i = t.length;i > e;e++) {
          this.addLayer(t[e]);
        }
      }
    }, addLayer:function(t) {
      var e = this.getLayerId(t);
      return this._layers[e] = t, this._map && this._map.addLayer(t), this;
    }, removeLayer:function(t) {
      var e = t in this._layers ? t : this.getLayerId(t);
      return this._map && (this._layers[e] && this._map.removeLayer(this._layers[e])), delete this._layers[e], this;
    }, hasLayer:function(t) {
      return t ? t in this._layers || this.getLayerId(t) in this._layers : !1;
    }, clearLayers:function() {
      return this.eachLayer(this.removeLayer, this), this;
    }, invoke:function(t) {
      var e, i, n = Array.prototype.slice.call(arguments, 1);
      for (e in this._layers) {
        i = this._layers[e], i[t] && i[t].apply(i, n);
      }
      return this;
    }, onAdd:function(t) {
      this._map = t, this.eachLayer(t.addLayer, t);
    }, onRemove:function(t) {
      this.eachLayer(t.removeLayer, t), this._map = null;
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, eachLayer:function(t, e) {
      for (var i in this._layers) {
        t.call(e, this._layers[i]);
      }
      return this;
    }, getLayer:function(t) {
      return this._layers[t];
    }, getLayers:function() {
      var t = [];
      for (var e in this._layers) {
        t.push(this._layers[e]);
      }
      return t;
    }, setZIndex:function(t) {
      return this.invoke("setZIndex", t);
    }, getLayerId:function(t) {
      return o.stamp(t);
    }}), o.layerGroup = function(t) {
      return new o.LayerGroup(t);
    }, o.FeatureGroup = o.LayerGroup.extend({includes:o.Mixin.Events, statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"}, addLayer:function(t) {
      return this.hasLayer(t) ? this : ("on" in t && t.on(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.addLayer.call(this, t), this._popupContent && (t.bindPopup && t.bindPopup(this._popupContent, this._popupOptions)), this.fire("layeradd", {layer:t}));
    }, removeLayer:function(t) {
      return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.off(o.FeatureGroup.EVENTS, this._propagateEvent, this), o.LayerGroup.prototype.removeLayer.call(this, t), this._popupContent && this.invoke("unbindPopup"), this.fire("layerremove", {layer:t})) : this;
    }, bindPopup:function(t, e) {
      return this._popupContent = t, this._popupOptions = e, this.invoke("bindPopup", t, e);
    }, openPopup:function(t) {
      for (var e in this._layers) {
        this._layers[e].openPopup(t);
        break;
      }
      return this;
    }, setStyle:function(t) {
      return this.invoke("setStyle", t);
    }, bringToFront:function() {
      return this.invoke("bringToFront");
    }, bringToBack:function() {
      return this.invoke("bringToBack");
    }, getBounds:function() {
      var t = new o.LatLngBounds;
      return this.eachLayer(function(e) {
        t.extend(e instanceof o.Marker ? e.getLatLng() : e.getBounds());
      }), t;
    }, _propagateEvent:function(t) {
      t = o.extend({layer:t.target, target:this}, t), this.fire(t.type, t);
    }}), o.featureGroup = function(t) {
      return new o.FeatureGroup(t);
    }, o.Path = o.Class.extend({includes:[o.Mixin.Events], statics:{CLIP_PADDING:function() {
      var e = o.Browser.mobile ? 1280 : 2E3, i = (e / Math.max(t.outerWidth, t.outerHeight) - 1) / 2;
      return Math.max(0, Math.min(0.5, i));
    }()}, options:{stroke:!0, color:"#0033ff", dashArray:null, lineCap:null, lineJoin:null, weight:5, opacity:0.5, fill:!1, fillColor:null, fillOpacity:0.2, clickable:!0}, initialize:function(t) {
      o.setOptions(this, t);
    }, onAdd:function(t) {
      this._map = t, this._container || (this._initElements(), this._initEvents()), this.projectLatlngs(), this._updatePath(), this._container && this._map._pathRoot.appendChild(this._container), this.fire("add"), t.on({viewreset:this.projectLatlngs, moveend:this._updatePath}, this);
    }, addTo:function(t) {
      return t.addLayer(this), this;
    }, onRemove:function(t) {
      t._pathRoot.removeChild(this._container), this.fire("remove"), this._map = null, o.Browser.vml && (this._container = null, this._stroke = null, this._fill = null), t.off({viewreset:this.projectLatlngs, moveend:this._updatePath}, this);
    }, projectLatlngs:function() {
    }, setStyle:function(t) {
      return o.setOptions(this, t), this._container && this._updateStyle(), this;
    }, redraw:function() {
      return this._map && (this.projectLatlngs(), this._updatePath()), this;
    }}), o.Map.include({_updatePathViewport:function() {
      var t = o.Path.CLIP_PADDING, e = this.getSize(), i = o.DomUtil.getPosition(this._mapPane), n = i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()), s = n.add(e.multiplyBy(1 + 2 * t)._round());
      this._pathViewport = new o.Bounds(n, s);
    }}), o.Path.SVG_NS = "http://www.w3.org/2000/svg", o.Browser.svg = !(!e.createElementNS || !e.createElementNS(o.Path.SVG_NS, "svg").createSVGRect), o.Path = o.Path.extend({statics:{SVG:o.Browser.svg}, bringToFront:function() {
      var t = this._map._pathRoot, e = this._container;
      return e && (t.lastChild !== e && t.appendChild(e)), this;
    }, bringToBack:function() {
      var t = this._map._pathRoot, e = this._container, i = t.firstChild;
      return e && (i !== e && t.insertBefore(e, i)), this;
    }, getPathString:function() {
    }, _createElement:function(t) {
      return e.createElementNS(o.Path.SVG_NS, t);
    }, _initElements:function() {
      this._map._initPathRoot(), this._initPath(), this._initStyle();
    }, _initPath:function() {
      this._container = this._createElement("g"), this._path = this._createElement("path"), this.options.className && o.DomUtil.addClass(this._path, this.options.className), this._container.appendChild(this._path);
    }, _initStyle:function() {
      this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"), this._path.setAttribute("stroke-linecap", "round")), this.options.fill && this._path.setAttribute("fill-rule", "evenodd"), this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents), this.options.clickable || (this.options.pointerEvents || this._path.setAttribute("pointer-events", "none")), this._updateStyle();
    }, _updateStyle:function() {
      this.options.stroke ? (this._path.setAttribute("stroke", this.options.color), this._path.setAttribute("stroke-opacity", this.options.opacity), this._path.setAttribute("stroke-width", this.options.weight), this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"), this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap), this.options.lineJoin && this._path.setAttribute("stroke-linejoin", 
      this.options.lineJoin)) : this._path.setAttribute("stroke", "none"), this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color), this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none");
    }, _updatePath:function() {
      var t = this.getPathString();
      t || (t = "M0 0"), this._path.setAttribute("d", t);
    }, _initEvents:function() {
      if (this.options.clickable) {
        (o.Browser.svg || !o.Browser.vml) && o.DomUtil.addClass(this._path, "leaflet-clickable"), o.DomEvent.on(this._container, "click", this._onMouseClick, this);
        for (var t = ["dblclick", "mousedown", "mouseover", "mouseout", "mousemove", "contextmenu"], e = 0;e < t.length;e++) {
          o.DomEvent.on(this._container, t[e], this._fireMouseEvent, this);
        }
      }
    }, _onMouseClick:function(t) {
      this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(t);
    }, _fireMouseEvent:function(t) {
      if (this.hasEventListeners(t.type)) {
        var e = this._map, i = e.mouseEventToContainerPoint(t), n = e.containerPointToLayerPoint(i), s = e.layerPointToLatLng(n);
        this.fire(t.type, {latlng:s, layerPoint:n, containerPoint:i, originalEvent:t}), "contextmenu" === t.type && o.DomEvent.preventDefault(t), "mousemove" !== t.type && o.DomEvent.stopPropagation(t);
      }
    }}), o.Map.include({_initPathRoot:function() {
      this._pathRoot || (this._pathRoot = o.Path.prototype._createElement("svg"), this._panes.overlayPane.appendChild(this._pathRoot), this.options.zoomAnimation && o.Browser.any3d ? (o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"), this.on({zoomanim:this._animatePathZoom, zoomend:this._endPathZoom})) : o.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"), this.on("moveend", this._updateSvgViewport), this._updateSvgViewport());
    }, _animatePathZoom:function(t) {
      var e = this.getZoomScale(t.zoom), i = this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);
      this._pathRoot.style[o.DomUtil.TRANSFORM] = o.DomUtil.getTranslateString(i) + " scale(" + e + ") ", this._pathZooming = !0;
    }, _endPathZoom:function() {
      this._pathZooming = !1;
    }, _updateSvgViewport:function() {
      if (!this._pathZooming) {
        this._updatePathViewport();
        var t = this._pathViewport, e = t.min, i = t.max, n = i.x - e.x, s = i.y - e.y, a = this._pathRoot, r = this._panes.overlayPane;
        o.Browser.mobileWebkit && r.removeChild(a), o.DomUtil.setPosition(a, e), a.setAttribute("width", n), a.setAttribute("height", s), a.setAttribute("viewBox", [e.x, e.y, n, s].join(" ")), o.Browser.mobileWebkit && r.appendChild(a);
      }
    }}), o.Path.include({bindPopup:function(t, e) {
      return t instanceof o.Popup ? this._popup = t : ((!this._popup || e) && (this._popup = new o.Popup(e, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this), this._popupHandlersAdded = !0), this;
    }, unbindPopup:function() {
      return this._popup && (this._popup = null, this.off("click", this._openPopup).off("remove", this.closePopup), this._popupHandlersAdded = !1), this;
    }, openPopup:function(t) {
      return this._popup && (t = t || (this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)]), this._openPopup({latlng:t})), this;
    }, closePopup:function() {
      return this._popup && this._popup._close(), this;
    }, _openPopup:function(t) {
      this._popup.setLatLng(t.latlng), this._map.openPopup(this._popup);
    }}), o.Browser.vml = !o.Browser.svg && function() {
      try {
        var t = e.createElement("div");
        t.innerHTML = '<v:shape adj="1"/>';
        var i = t.firstChild;
        return i.style.behavior = "url(#default#VML)", i && "object" == typeof i.adj;
      } catch (n) {
        return!1;
      }
    }(), o.Path = o.Browser.svg || !o.Browser.vml ? o.Path : o.Path.extend({statics:{VML:!0, CLIP_PADDING:0.02}, _createElement:function() {
      try {
        return e.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(t) {
          return e.createElement("<lvml:" + t + ' class="lvml">');
        };
      } catch (t) {
        return function(t) {
          return e.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }
    }(), _initPath:function() {
      var t = this._container = this._createElement("shape");
      o.DomUtil.addClass(t, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : "")), this.options.clickable && o.DomUtil.addClass(t, "leaflet-clickable"), t.coordsize = "1 1", this._path = this._createElement("path"), t.appendChild(this._path), this._map._pathRoot.appendChild(t);
    }, _initStyle:function() {
      this._updateStyle();
    }, _updateStyle:function() {
      var t = this._stroke, e = this._fill, i = this.options, n = this._container;
      n.stroked = i.stroke, n.filled = i.fill, i.stroke ? (t || (t = this._stroke = this._createElement("stroke"), t.endcap = "round", n.appendChild(t)), t.weight = i.weight + "px", t.color = i.color, t.opacity = i.opacity, t.dashStyle = i.dashArray ? o.Util.isArray(i.dashArray) ? i.dashArray.join(" ") : i.dashArray.replace(/( *, *)/g, " ") : "", i.lineCap && (t.endcap = i.lineCap.replace("butt", "flat")), i.lineJoin && (t.joinstyle = i.lineJoin)) : t && (n.removeChild(t), this._stroke = null), i.fill ? 
      (e || (e = this._fill = this._createElement("fill"), n.appendChild(e)), e.color = i.fillColor || i.color, e.opacity = i.fillOpacity) : e && (n.removeChild(e), this._fill = null);
    }, _updatePath:function() {
      var t = this._container.style;
      t.display = "none", this._path.v = this.getPathString() + " ", t.display = "";
    }}), o.Map.include(o.Browser.svg || !o.Browser.vml ? {} : {_initPathRoot:function() {
      if (!this._pathRoot) {
        var t = this._pathRoot = e.createElement("div");
        t.className = "leaflet-vml-container", this._panes.overlayPane.appendChild(t), this.on("moveend", this._updatePathViewport), this._updatePathViewport();
      }
    }}), o.Browser.canvas = function() {
      return!!e.createElement("canvas").getContext;
    }(), o.Path = o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? o.Path : o.Path.extend({statics:{CANVAS:!0, SVG:!1}, redraw:function() {
      return this._map && (this.projectLatlngs(), this._requestUpdate()), this;
    }, setStyle:function(t) {
      return o.setOptions(this, t), this._map && (this._updateStyle(), this._requestUpdate()), this;
    }, onRemove:function(t) {
      t.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this), this.options.clickable && (this._map.off("click", this._onClick, this), this._map.off("mousemove", this._onMouseMove, this)), this._requestUpdate(), this._map = null;
    }, _requestUpdate:function() {
      this._map && (!o.Path._updateRequest && (o.Path._updateRequest = o.Util.requestAnimFrame(this._fireMapMoveEnd, this._map)));
    }, _fireMapMoveEnd:function() {
      o.Path._updateRequest = null, this.fire("moveend");
    }, _initElements:function() {
      this._map._initPathRoot(), this._ctx = this._map._canvasCtx;
    }, _updateStyle:function() {
      var t = this.options;
      t.stroke && (this._ctx.lineWidth = t.weight, this._ctx.strokeStyle = t.color), t.fill && (this._ctx.fillStyle = t.fillColor || t.color);
    }, _drawPath:function() {
      var t, e, i, n, s, a;
      for (this._ctx.beginPath(), t = 0, i = this._parts.length;i > t;t++) {
        for (e = 0, n = this._parts[t].length;n > e;e++) {
          s = this._parts[t][e], a = (0 === e ? "move" : "line") + "To", this._ctx[a](s.x, s.y);
        }
        this instanceof o.Polygon && this._ctx.closePath();
      }
    }, _checkIfEmpty:function() {
      return!this._parts.length;
    }, _updatePath:function() {
      if (!this._checkIfEmpty()) {
        var t = this._ctx, e = this.options;
        this._drawPath(), t.save(), this._updateStyle(), e.fill && (t.globalAlpha = e.fillOpacity, t.fill()), e.stroke && (t.globalAlpha = e.opacity, t.stroke()), t.restore();
      }
    }, _initEvents:function() {
      this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this), this._map.on("click", this._onClick, this));
    }, _onClick:function(t) {
      this._containsPoint(t.layerPoint) && this.fire("click", t);
    }, _onMouseMove:function(t) {
      this._map && (!this._map._animatingZoom && (this._containsPoint(t.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer", this._mouseInside = !0, this.fire("mouseover", t)) : this._mouseInside && (this._ctx.canvas.style.cursor = "", this._mouseInside = !1, this.fire("mouseout", t))));
    }}), o.Map.include(o.Path.SVG && !t.L_PREFER_CANVAS || !o.Browser.canvas ? {} : {_initPathRoot:function() {
      var t, i = this._pathRoot;
      i || (i = this._pathRoot = e.createElement("canvas"), i.style.position = "absolute", t = this._canvasCtx = i.getContext("2d"), t.lineCap = "round", t.lineJoin = "round", this._panes.overlayPane.appendChild(i), this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated", this.on("zoomanim", this._animatePathZoom), this.on("zoomend", this._endPathZoom)), this.on("moveend", this._updateCanvasViewport), this._updateCanvasViewport());
    }, _updateCanvasViewport:function() {
      if (!this._pathZooming) {
        this._updatePathViewport();
        var t = this._pathViewport, e = t.min, i = t.max.subtract(e), n = this._pathRoot;
        o.DomUtil.setPosition(n, e), n.width = i.x, n.height = i.y, n.getContext("2d").translate(-e.x, -e.y);
      }
    }}), o.LineUtil = {simplify:function(t, e) {
      if (!e || !t.length) {
        return t.slice();
      }
      var i = e * e;
      return t = this._reducePoints(t, i), t = this._simplifyDP(t, i);
    }, pointToSegmentDistance:function(t, e, i) {
      return Math.sqrt(this._sqClosestPointOnSegment(t, e, i, !0));
    }, closestPointOnSegment:function(t, e, i) {
      return this._sqClosestPointOnSegment(t, e, i);
    }, _simplifyDP:function(t, e) {
      var n = t.length, o = typeof Uint8Array != i + "" ? Uint8Array : Array, s = new o(n);
      s[0] = s[n - 1] = 1, this._simplifyDPStep(t, s, e, 0, n - 1);
      var a, r = [];
      for (a = 0;n > a;a++) {
        s[a] && r.push(t[a]);
      }
      return r;
    }, _simplifyDPStep:function(t, e, i, n, o) {
      var s, a, r, h = 0;
      for (a = n + 1;o - 1 >= a;a++) {
        r = this._sqClosestPointOnSegment(t[a], t[n], t[o], !0), r > h && (s = a, h = r);
      }
      h > i && (e[s] = 1, this._simplifyDPStep(t, e, i, n, s), this._simplifyDPStep(t, e, i, s, o));
    }, _reducePoints:function(t, e) {
      for (var i = [t[0]], n = 1, o = 0, s = t.length;s > n;n++) {
        this._sqDist(t[n], t[o]) > e && (i.push(t[n]), o = n);
      }
      return s - 1 > o && i.push(t[s - 1]), i;
    }, clipSegment:function(t, e, i, n) {
      var o, s, a, r = n ? this._lastCode : this._getBitCode(t, i), h = this._getBitCode(e, i);
      for (this._lastCode = h;;) {
        if (!(r | h)) {
          return[t, e];
        }
        if (r & h) {
          return!1;
        }
        o = r || h, s = this._getEdgeIntersection(t, e, o, i), a = this._getBitCode(s, i), o === r ? (t = s, r = a) : (e = s, h = a);
      }
    }, _getEdgeIntersection:function(t, e, i, n) {
      var s = e.x - t.x, a = e.y - t.y, r = n.min, h = n.max;
      return 8 & i ? new o.Point(t.x + s * (h.y - t.y) / a, h.y) : 4 & i ? new o.Point(t.x + s * (r.y - t.y) / a, r.y) : 2 & i ? new o.Point(h.x, t.y + a * (h.x - t.x) / s) : 1 & i ? new o.Point(r.x, t.y + a * (r.x - t.x) / s) : void 0;
    }, _getBitCode:function(t, e) {
      var i = 0;
      return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i;
    }, _sqDist:function(t, e) {
      var i = e.x - t.x, n = e.y - t.y;
      return i * i + n * n;
    }, _sqClosestPointOnSegment:function(t, e, i, n) {
      var s, a = e.x, r = e.y, h = i.x - a, l = i.y - r, u = h * h + l * l;
      return u > 0 && (s = ((t.x - a) * h + (t.y - r) * l) / u, s > 1 ? (a = i.x, r = i.y) : s > 0 && (a += h * s, r += l * s)), h = t.x - a, l = t.y - r, n ? h * h + l * l : new o.Point(a, r);
    }}, o.Polyline = o.Path.extend({initialize:function(t, e) {
      o.Path.prototype.initialize.call(this, e), this._latlngs = this._convertLatLngs(t);
    }, options:{smoothFactor:1, noClip:!1}, projectLatlngs:function() {
      this._originalPoints = [];
      for (var t = 0, e = this._latlngs.length;e > t;t++) {
        this._originalPoints[t] = this._map.latLngToLayerPoint(this._latlngs[t]);
      }
    }, getPathString:function() {
      for (var t = 0, e = this._parts.length, i = "";e > t;t++) {
        i += this._getPathPartStr(this._parts[t]);
      }
      return i;
    }, getLatLngs:function() {
      return this._latlngs;
    }, setLatLngs:function(t) {
      return this._latlngs = this._convertLatLngs(t), this.redraw();
    }, addLatLng:function(t) {
      return this._latlngs.push(o.latLng(t)), this.redraw();
    }, spliceLatLngs:function() {
      var t = [].splice.apply(this._latlngs, arguments);
      return this._convertLatLngs(this._latlngs, !0), this.redraw(), t;
    }, closestLayerPoint:function(t) {
      for (var e, i, n = 1 / 0, s = this._parts, a = null, r = 0, h = s.length;h > r;r++) {
        for (var l = s[r], u = 1, c = l.length;c > u;u++) {
          e = l[u - 1], i = l[u];
          var d = o.LineUtil._sqClosestPointOnSegment(t, e, i, !0);
          n > d && (n = d, a = o.LineUtil._sqClosestPointOnSegment(t, e, i));
        }
      }
      return a && (a.distance = Math.sqrt(n)), a;
    }, getBounds:function() {
      return new o.LatLngBounds(this.getLatLngs());
    }, _convertLatLngs:function(t, e) {
      var i, n, s = e ? t : [];
      for (i = 0, n = t.length;n > i;i++) {
        if (o.Util.isArray(t[i]) && "number" != typeof t[i][0]) {
          return;
        }
        s[i] = o.latLng(t[i]);
      }
      return s;
    }, _initEvents:function() {
      o.Path.prototype._initEvents.call(this);
    }, _getPathPartStr:function(t) {
      for (var e, i = o.Path.VML, n = 0, s = t.length, a = "";s > n;n++) {
        e = t[n], i && e._round(), a += (n ? "L" : "M") + e.x + " " + e.y;
      }
      return a;
    }, _clipPoints:function() {
      var t, e, i, n = this._originalPoints, s = n.length;
      if (this.options.noClip) {
        return void(this._parts = [n]);
      }
      this._parts = [];
      var a = this._parts, r = this._map._pathViewport, h = o.LineUtil;
      for (t = 0, e = 0;s - 1 > t;t++) {
        i = h.clipSegment(n[t], n[t + 1], r, t), i && (a[e] = a[e] || [], a[e].push(i[0]), (i[1] !== n[t + 1] || t === s - 2) && (a[e].push(i[1]), e++));
      }
    }, _simplifyPoints:function() {
      for (var t = this._parts, e = o.LineUtil, i = 0, n = t.length;n > i;i++) {
        t[i] = e.simplify(t[i], this.options.smoothFactor);
      }
    }, _updatePath:function() {
      this._map && (this._clipPoints(), this._simplifyPoints(), o.Path.prototype._updatePath.call(this));
    }}), o.polyline = function(t, e) {
      return new o.Polyline(t, e);
    }, o.PolyUtil = {}, o.PolyUtil.clipPolygon = function(t, e) {
      var i, n, s, a, r, h, l, u, c, d = [1, 4, 2, 8], p = o.LineUtil;
      for (n = 0, l = t.length;l > n;n++) {
        t[n]._code = p._getBitCode(t[n], e);
      }
      for (a = 0;4 > a;a++) {
        for (u = d[a], i = [], n = 0, l = t.length, s = l - 1;l > n;s = n++) {
          r = t[n], h = t[s], r._code & u ? h._code & u || (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)) : (h._code & u && (c = p._getEdgeIntersection(h, r, u, e), c._code = p._getBitCode(c, e), i.push(c)), i.push(r));
        }
        t = i;
      }
      return t;
    }, o.Polygon = o.Polyline.extend({options:{fill:!0}, initialize:function(t, e) {
      o.Polyline.prototype.initialize.call(this, t, e), this._initWithHoles(t);
    }, _initWithHoles:function(t) {
      var e, i, n;
      if (t && (o.Util.isArray(t[0]) && "number" != typeof t[0][0])) {
        for (this._latlngs = this._convertLatLngs(t[0]), this._holes = t.slice(1), e = 0, i = this._holes.length;i > e;e++) {
          n = this._holes[e] = this._convertLatLngs(this._holes[e]), n[0].equals(n[n.length - 1]) && n.pop();
        }
      }
      t = this._latlngs, t.length >= 2 && (t[0].equals(t[t.length - 1]) && t.pop());
    }, projectLatlngs:function() {
      if (o.Polyline.prototype.projectLatlngs.call(this), this._holePoints = [], this._holes) {
        var t, e, i, n;
        for (t = 0, i = this._holes.length;i > t;t++) {
          for (this._holePoints[t] = [], e = 0, n = this._holes[t].length;n > e;e++) {
            this._holePoints[t][e] = this._map.latLngToLayerPoint(this._holes[t][e]);
          }
        }
      }
    }, setLatLngs:function(t) {
      return t && (o.Util.isArray(t[0]) && "number" != typeof t[0][0]) ? (this._initWithHoles(t), this.redraw()) : o.Polyline.prototype.setLatLngs.call(this, t);
    }, _clipPoints:function() {
      var t = this._originalPoints, e = [];
      if (this._parts = [t].concat(this._holePoints), !this.options.noClip) {
        for (var i = 0, n = this._parts.length;n > i;i++) {
          var s = o.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
          s.length && e.push(s);
        }
        this._parts = e;
      }
    }, _getPathPartStr:function(t) {
      var e = o.Polyline.prototype._getPathPartStr.call(this, t);
      return e + (o.Browser.svg ? "z" : "x");
    }}), o.polygon = function(t, e) {
      return new o.Polygon(t, e);
    }, function() {
      function t(t) {
        return o.FeatureGroup.extend({initialize:function(t, e) {
          this._layers = {}, this._options = e, this.setLatLngs(t);
        }, setLatLngs:function(e) {
          var i = 0, n = e.length;
          for (this.eachLayer(function(t) {
            n > i ? t.setLatLngs(e[i++]) : this.removeLayer(t);
          }, this);n > i;) {
            this.addLayer(new t(e[i++], this._options));
          }
          return this;
        }, getLatLngs:function() {
          var t = [];
          return this.eachLayer(function(e) {
            t.push(e.getLatLngs());
          }), t;
        }});
      }
      o.MultiPolyline = t(o.Polyline), o.MultiPolygon = t(o.Polygon), o.multiPolyline = function(t, e) {
        return new o.MultiPolyline(t, e);
      }, o.multiPolygon = function(t, e) {
        return new o.MultiPolygon(t, e);
      };
    }(), o.Rectangle = o.Polygon.extend({initialize:function(t, e) {
      o.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(t), e);
    }, setBounds:function(t) {
      this.setLatLngs(this._boundsToLatLngs(t));
    }, _boundsToLatLngs:function(t) {
      return t = o.latLngBounds(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()];
    }}), o.rectangle = function(t, e) {
      return new o.Rectangle(t, e);
    }, o.Circle = o.Path.extend({initialize:function(t, e, i) {
      o.Path.prototype.initialize.call(this, i), this._latlng = o.latLng(t), this._mRadius = e;
    }, options:{fill:!0}, setLatLng:function(t) {
      return this._latlng = o.latLng(t), this.redraw();
    }, setRadius:function(t) {
      return this._mRadius = t, this.redraw();
    }, projectLatlngs:function() {
      var t = this._getLngRadius(), e = this._latlng, i = this._map.latLngToLayerPoint([e.lat, e.lng - t]);
      this._point = this._map.latLngToLayerPoint(e), this._radius = Math.max(this._point.x - i.x, 1);
    }, getBounds:function() {
      var t = this._getLngRadius(), e = this._mRadius / 40075017 * 360, i = this._latlng;
      return new o.LatLngBounds([i.lat - e, i.lng - t], [i.lat + e, i.lng + t]);
    }, getLatLng:function() {
      return this._latlng;
    }, getPathString:function() {
      var t = this._point, e = this._radius;
      return this._checkIfEmpty() ? "" : o.Browser.svg ? "M" + t.x + "," + (t.y - e) + "A" + e + "," + e + ",0,1,1," + (t.x - 0.1) + "," + (t.y - e) + " z" : (t._round(), e = Math.round(e), "AL " + t.x + "," + t.y + " " + e + "," + e + " 0,23592600");
    }, getRadius:function() {
      return this._mRadius;
    }, _getLatRadius:function() {
      return this._mRadius / 40075017 * 360;
    }, _getLngRadius:function() {
      return this._getLatRadius() / Math.cos(o.LatLng.DEG_TO_RAD * this._latlng.lat);
    }, _checkIfEmpty:function() {
      if (!this._map) {
        return!1;
      }
      var t = this._map._pathViewport, e = this._radius, i = this._point;
      return i.x - e > t.max.x || (i.y - e > t.max.y || (i.x + e < t.min.x || i.y + e < t.min.y));
    }}), o.circle = function(t, e, i) {
      return new o.Circle(t, e, i);
    }, o.CircleMarker = o.Circle.extend({options:{radius:10, weight:2}, initialize:function(t, e) {
      o.Circle.prototype.initialize.call(this, t, null, e), this._radius = this.options.radius;
    }, projectLatlngs:function() {
      this._point = this._map.latLngToLayerPoint(this._latlng);
    }, _updateStyle:function() {
      o.Circle.prototype._updateStyle.call(this), this.setRadius(this.options.radius);
    }, setLatLng:function(t) {
      return o.Circle.prototype.setLatLng.call(this, t), this._popup && (this._popup._isOpen && this._popup.setLatLng(t)), this;
    }, setRadius:function(t) {
      return this.options.radius = this._radius = t, this.redraw();
    }, getRadius:function() {
      return this._radius;
    }}), o.circleMarker = function(t, e) {
      return new o.CircleMarker(t, e);
    }, o.Polyline.include(o.Path.CANVAS ? {_containsPoint:function(t, e) {
      var i, n, s, a, r, h, l, u = this.options.weight / 2;
      for (o.Browser.touch && (u += 10), i = 0, a = this._parts.length;a > i;i++) {
        for (l = this._parts[i], n = 0, r = l.length, s = r - 1;r > n;s = n++) {
          if ((e || 0 !== n) && (h = o.LineUtil.pointToSegmentDistance(t, l[s], l[n]), u >= h)) {
            return!0;
          }
        }
      }
      return!1;
    }} : {}), o.Polygon.include(o.Path.CANVAS ? {_containsPoint:function(t) {
      var e, i, n, s, a, r, h, l, u = !1;
      if (o.Polyline.prototype._containsPoint.call(this, t, !0)) {
        return!0;
      }
      for (s = 0, h = this._parts.length;h > s;s++) {
        for (e = this._parts[s], a = 0, l = e.length, r = l - 1;l > a;r = a++) {
          i = e[a], n = e[r], i.y > t.y != n.y > t.y && (t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (u = !u));
        }
      }
      return u;
    }} : {}), o.Circle.include(o.Path.CANVAS ? {_drawPath:function() {
      var t = this._point;
      this._ctx.beginPath(), this._ctx.arc(t.x, t.y, this._radius, 0, 2 * Math.PI, !1);
    }, _containsPoint:function(t) {
      var e = this._point, i = this.options.stroke ? this.options.weight / 2 : 0;
      return t.distanceTo(e) <= this._radius + i;
    }} : {}), o.CircleMarker.include(o.Path.CANVAS ? {_updateStyle:function() {
      o.Path.prototype._updateStyle.call(this);
    }} : {}), o.GeoJSON = o.FeatureGroup.extend({initialize:function(t, e) {
      o.setOptions(this, e), this._layers = {}, t && this.addData(t);
    }, addData:function(t) {
      var e, i, n, s = o.Util.isArray(t) ? t : t.features;
      if (s) {
        for (e = 0, i = s.length;i > e;e++) {
          n = s[e], (n.geometries || (n.geometry || (n.features || n.coordinates))) && this.addData(s[e]);
        }
        return this;
      }
      var a = this.options;
      if (!a.filter || a.filter(t)) {
        var r = o.GeoJSON.geometryToLayer(t, a.pointToLayer, a.coordsToLatLng, a);
        return r.feature = o.GeoJSON.asFeature(t), r.defaultOptions = r.options, this.resetStyle(r), a.onEachFeature && a.onEachFeature(t, r), this.addLayer(r);
      }
    }, resetStyle:function(t) {
      var e = this.options.style;
      e && (o.Util.extend(t.options, t.defaultOptions), this._setLayerStyle(t, e));
    }, setStyle:function(t) {
      this.eachLayer(function(e) {
        this._setLayerStyle(e, t);
      }, this);
    }, _setLayerStyle:function(t, e) {
      "function" == typeof e && (e = e(t.feature)), t.setStyle && t.setStyle(e);
    }}), o.extend(o.GeoJSON, {geometryToLayer:function(t, e, i, n) {
      var s, a, r, h, l = "Feature" === t.type ? t.geometry : t, u = l.coordinates, c = [];
      switch(i = i || this.coordsToLatLng, l.type) {
        case "Point":
          return s = i(u), e ? e(t, s) : new o.Marker(s);
        case "MultiPoint":
          for (r = 0, h = u.length;h > r;r++) {
            s = i(u[r]), c.push(e ? e(t, s) : new o.Marker(s));
          }
          return new o.FeatureGroup(c);
        case "LineString":
          return a = this.coordsToLatLngs(u, 0, i), new o.Polyline(a, n);
        case "Polygon":
          if (2 === u.length && !u[1].length) {
            throw new Error("Invalid GeoJSON object.");
          }
          return a = this.coordsToLatLngs(u, 1, i), new o.Polygon(a, n);
        case "MultiLineString":
          return a = this.coordsToLatLngs(u, 1, i), new o.MultiPolyline(a, n);
        case "MultiPolygon":
          return a = this.coordsToLatLngs(u, 2, i), new o.MultiPolygon(a, n);
        case "GeometryCollection":
          for (r = 0, h = l.geometries.length;h > r;r++) {
            c.push(this.geometryToLayer({geometry:l.geometries[r], type:"Feature", properties:t.properties}, e, i, n));
          }
          return new o.FeatureGroup(c);
        default:
          throw new Error("Invalid GeoJSON object.");;
      }
    }, coordsToLatLng:function(t) {
      return new o.LatLng(t[1], t[0], t[2]);
    }, coordsToLatLngs:function(t, e, i) {
      var n, o, s, a = [];
      for (o = 0, s = t.length;s > o;o++) {
        n = e ? this.coordsToLatLngs(t[o], e - 1, i) : (i || this.coordsToLatLng)(t[o]), a.push(n);
      }
      return a;
    }, latLngToCoords:function(t) {
      var e = [t.lng, t.lat];
      return t.alt !== i && e.push(t.alt), e;
    }, latLngsToCoords:function(t) {
      for (var e = [], i = 0, n = t.length;n > i;i++) {
        e.push(o.GeoJSON.latLngToCoords(t[i]));
      }
      return e;
    }, getFeature:function(t, e) {
      return t.feature ? o.extend({}, t.feature, {geometry:e}) : o.GeoJSON.asFeature(e);
    }, asFeature:function(t) {
      return "Feature" === t.type ? t : {type:"Feature", properties:{}, geometry:t};
    }});
    var a = {toGeoJSON:function() {
      return o.GeoJSON.getFeature(this, {type:"Point", coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())});
    }};
    o.Marker.include(a), o.Circle.include(a), o.CircleMarker.include(a), o.Polyline.include({toGeoJSON:function() {
      return o.GeoJSON.getFeature(this, {type:"LineString", coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())});
    }}), o.Polygon.include({toGeoJSON:function() {
      var t, e, i, n = [o.GeoJSON.latLngsToCoords(this.getLatLngs())];
      if (n[0].push(n[0][0]), this._holes) {
        for (t = 0, e = this._holes.length;e > t;t++) {
          i = o.GeoJSON.latLngsToCoords(this._holes[t]), i.push(i[0]), n.push(i);
        }
      }
      return o.GeoJSON.getFeature(this, {type:"Polygon", coordinates:n});
    }}), function() {
      function t(t) {
        return function() {
          var e = [];
          return this.eachLayer(function(t) {
            e.push(t.toGeoJSON().geometry.coordinates);
          }), o.GeoJSON.getFeature(this, {type:t, coordinates:e});
        };
      }
      o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}), o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}), o.LayerGroup.include({toGeoJSON:function() {
        var e, i = this.feature && this.feature.geometry, n = [];
        if (i && "MultiPoint" === i.type) {
          return t("MultiPoint").call(this);
        }
        var s = i && "GeometryCollection" === i.type;
        return this.eachLayer(function(t) {
          t.toGeoJSON && (e = t.toGeoJSON(), n.push(s ? e.geometry : o.GeoJSON.asFeature(e)));
        }), s ? o.GeoJSON.getFeature(this, {geometries:n, type:"GeometryCollection"}) : {type:"FeatureCollection", features:n};
      }});
    }(), o.geoJson = function(t, e) {
      return new o.GeoJSON(t, e);
    }, o.DomEvent = {addListener:function(t, e, i, n) {
      var s, a, r, h = o.stamp(i), l = "_leaflet_" + e + h;
      return t[l] ? this : (s = function(e) {
        return i.call(n || t, e || o.DomEvent._getEvent());
      }, o.Browser.pointer && 0 === e.indexOf("touch") ? this.addPointerListener(t, e, s, h) : (o.Browser.touch && ("dblclick" === e && (this.addDoubleTapListener && this.addDoubleTapListener(t, s, h))), "addEventListener" in t ? "mousewheel" === e ? (t.addEventListener("DOMMouseScroll", s, !1), t.addEventListener(e, s, !1)) : "mouseenter" === e || "mouseleave" === e ? (a = s, r = "mouseenter" === e ? "mouseover" : "mouseout", s = function(e) {
        return o.DomEvent._checkMouse(t, e) ? a(e) : void 0;
      }, t.addEventListener(r, s, !1)) : "click" === e && o.Browser.android ? (a = s, s = function(t) {
        return o.DomEvent._filterClick(t, a);
      }, t.addEventListener(e, s, !1)) : t.addEventListener(e, s, !1) : "attachEvent" in t && t.attachEvent("on" + e, s), t[l] = s, this));
    }, removeListener:function(t, e, i) {
      var n = o.stamp(i), s = "_leaflet_" + e + n, a = t[s];
      return a ? (o.Browser.pointer && 0 === e.indexOf("touch") ? this.removePointerListener(t, e, n) : o.Browser.touch && ("dblclick" === e && this.removeDoubleTapListener) ? this.removeDoubleTapListener(t, n) : "removeEventListener" in t ? "mousewheel" === e ? (t.removeEventListener("DOMMouseScroll", a, !1), t.removeEventListener(e, a, !1)) : "mouseenter" === e || "mouseleave" === e ? t.removeEventListener("mouseenter" === e ? "mouseover" : "mouseout", a, !1) : t.removeEventListener(e, a, !1) : 
      "detachEvent" in t && t.detachEvent("on" + e, a), t[s] = null, this) : this;
    }, stopPropagation:function(t) {
      return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, o.DomEvent._skipped(t), this;
    }, disableScrollPropagation:function(t) {
      var e = o.DomEvent.stopPropagation;
      return o.DomEvent.on(t, "mousewheel", e).on(t, "MozMousePixelScroll", e);
    }, disableClickPropagation:function(t) {
      for (var e = o.DomEvent.stopPropagation, i = o.Draggable.START.length - 1;i >= 0;i--) {
        o.DomEvent.on(t, o.Draggable.START[i], e);
      }
      return o.DomEvent.on(t, "click", o.DomEvent._fakeStop).on(t, "dblclick", e);
    }, preventDefault:function(t) {
      return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;
    }, stop:function(t) {
      return o.DomEvent.preventDefault(t).stopPropagation(t);
    }, getMousePosition:function(t, e) {
      if (!e) {
        return new o.Point(t.clientX, t.clientY);
      }
      var i = e.getBoundingClientRect();
      return new o.Point(t.clientX - i.left - e.clientLeft, t.clientY - i.top - e.clientTop);
    }, getWheelDelta:function(t) {
      var e = 0;
      return t.wheelDelta && (e = t.wheelDelta / 120), t.detail && (e = -t.detail / 3), e;
    }, _skipEvents:{}, _fakeStop:function(t) {
      o.DomEvent._skipEvents[t.type] = !0;
    }, _skipped:function(t) {
      var e = this._skipEvents[t.type];
      return this._skipEvents[t.type] = !1, e;
    }, _checkMouse:function(t, e) {
      var i = e.relatedTarget;
      if (!i) {
        return!0;
      }
      try {
        for (;i && i !== t;) {
          i = i.parentNode;
        }
      } catch (n) {
        return!1;
      }
      return i !== t;
    }, _getEvent:function() {
      var e = t.event;
      if (!e) {
        for (var i = arguments.callee.caller;i && (e = i.arguments[0], !e || t.Event !== e.constructor);) {
          i = i.caller;
        }
      }
      return e;
    }, _filterClick:function(t, e) {
      var i = t.timeStamp || t.originalEvent.timeStamp, n = o.DomEvent._lastClick && i - o.DomEvent._lastClick;
      return n && (n > 100 && 1E3 > n) || t.target._simulatedClick && !t._simulated ? void o.DomEvent.stop(t) : (o.DomEvent._lastClick = i, e(t));
    }}, o.DomEvent.on = o.DomEvent.addListener, o.DomEvent.off = o.DomEvent.removeListener, o.Draggable = o.Class.extend({includes:o.Mixin.Events, statics:{START:o.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"], END:{mousedown:"mouseup", touchstart:"touchend", pointerdown:"touchend", MSPointerDown:"touchend"}, MOVE:{mousedown:"mousemove", touchstart:"touchmove", pointerdown:"touchmove", MSPointerDown:"touchmove"}}, initialize:function(t, e) {
      this._element = t, this._dragStartTarget = e || t;
    }, enable:function() {
      if (!this._enabled) {
        for (var t = o.Draggable.START.length - 1;t >= 0;t--) {
          o.DomEvent.on(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
        }
        this._enabled = !0;
      }
    }, disable:function() {
      if (this._enabled) {
        for (var t = o.Draggable.START.length - 1;t >= 0;t--) {
          o.DomEvent.off(this._dragStartTarget, o.Draggable.START[t], this._onDown, this);
        }
        this._enabled = !1, this._moved = !1;
      }
    }, _onDown:function(t) {
      if (this._moved = !1, !(t.shiftKey || (1 !== t.which && (1 !== t.button && !t.touches) || (o.DomEvent.stopPropagation(t), o.Draggable._disabled || (o.DomUtil.disableImageDrag(), o.DomUtil.disableTextSelection(), this._moving))))) {
        var i = t.touches ? t.touches[0] : t;
        this._startPoint = new o.Point(i.clientX, i.clientY), this._startPos = this._newPos = o.DomUtil.getPosition(this._element), o.DomEvent.on(e, o.Draggable.MOVE[t.type], this._onMove, this).on(e, o.Draggable.END[t.type], this._onUp, this);
      }
    }, _onMove:function(t) {
      if (t.touches && t.touches.length > 1) {
        return void(this._moved = !0);
      }
      var i = t.touches && 1 === t.touches.length ? t.touches[0] : t, n = new o.Point(i.clientX, i.clientY), s = n.subtract(this._startPoint);
      (s.x || s.y) && (o.DomEvent.preventDefault(t), this._moved || (this.fire("dragstart"), this._moved = !0, this._startPos = o.DomUtil.getPosition(this._element).subtract(s), o.DomUtil.addClass(e.body, "leaflet-dragging"), o.DomUtil.addClass(t.target || t.srcElement, "leaflet-drag-target")), this._newPos = this._startPos.add(s), this._moving = !0, o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget));
    }, _updatePosition:function() {
      this.fire("predrag"), o.DomUtil.setPosition(this._element, this._newPos), this.fire("drag");
    }, _onUp:function(t) {
      o.DomUtil.removeClass(e.body, "leaflet-dragging"), o.DomUtil.removeClass(t.target || t.srcElement, "leaflet-drag-target");
      for (var i in o.Draggable.MOVE) {
        o.DomEvent.off(e, o.Draggable.MOVE[i], this._onMove).off(e, o.Draggable.END[i], this._onUp);
      }
      o.DomUtil.enableImageDrag(), o.DomUtil.enableTextSelection(), this._moved && (this._moving && (o.Util.cancelAnimFrame(this._animRequest), this.fire("dragend", {distance:this._newPos.distanceTo(this._startPos)}))), this._moving = !1;
    }}), o.Handler = o.Class.extend({initialize:function(t) {
      this._map = t;
    }, enable:function() {
      this._enabled || (this._enabled = !0, this.addHooks());
    }, disable:function() {
      this._enabled && (this._enabled = !1, this.removeHooks());
    }, enabled:function() {
      return!!this._enabled;
    }}), o.Map.mergeOptions({dragging:!0, inertia:!o.Browser.android23, inertiaDeceleration:3400, inertiaMaxSpeed:1 / 0, inertiaThreshold:o.Browser.touch ? 32 : 18, easeLinearity:0.25, worldCopyJump:!1}), o.Map.Drag = o.Handler.extend({addHooks:function() {
      if (!this._draggable) {
        var t = this._map;
        this._draggable = new o.Draggable(t._mapPane, t._container), this._draggable.on({dragstart:this._onDragStart, drag:this._onDrag, dragend:this._onDragEnd}, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this), t.on("viewreset", this._onViewReset, this), t.whenReady(this._onViewReset, this));
      }
      this._draggable.enable();
    }, removeHooks:function() {
      this._draggable.disable();
    }, moved:function() {
      return this._draggable && this._draggable._moved;
    }, _onDragStart:function() {
      var t = this._map;
      t._panAnim && t._panAnim.stop(), t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = []);
    }, _onDrag:function() {
      if (this._map.options.inertia) {
        var t = this._lastTime = +new Date, e = this._lastPos = this._draggable._newPos;
        this._positions.push(e), this._times.push(t), t - this._times[0] > 200 && (this._positions.shift(), this._times.shift());
      }
      this._map.fire("move").fire("drag");
    }, _onViewReset:function() {
      var t = this._map.getSize()._divideBy(2), e = this._map.latLngToLayerPoint([0, 0]);
      this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.project([0, 180]).x;
    }, _onPreDrag:function() {
      var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, o = (n - e + i) % t + e - i, s = (n + e + i) % t - e - i, a = Math.abs(o + i) < Math.abs(s + i) ? o : s;
      this._draggable._newPos.x = a;
    }, _onDragEnd:function(t) {
      var e = this._map, i = e.options, n = +new Date - this._lastTime, s = !i.inertia || (n > i.inertiaThreshold || !this._positions[0]);
      if (e.fire("dragend", t), s) {
        e.fire("moveend");
      } else {
        var a = this._lastPos.subtract(this._positions[0]), r = (this._lastTime + n - this._times[0]) / 1E3, h = i.easeLinearity, l = a.multiplyBy(h / r), u = l.distanceTo([0, 0]), c = Math.min(i.inertiaMaxSpeed, u), d = l.multiplyBy(c / u), p = c / (i.inertiaDeceleration * h), _ = d.multiplyBy(-p / 2).round();
        _.x && _.y ? (_ = e._limitOffset(_, e.options.maxBounds), o.Util.requestAnimFrame(function() {
          e.panBy(_, {duration:p, easeLinearity:h, noMoveStart:!0});
        })) : e.fire("moveend");
      }
    }}), o.Map.addInitHook("addHandler", "dragging", o.Map.Drag), o.Map.mergeOptions({doubleClickZoom:!0}), o.Map.DoubleClickZoom = o.Handler.extend({addHooks:function() {
      this._map.on("dblclick", this._onDoubleClick, this);
    }, removeHooks:function() {
      this._map.off("dblclick", this._onDoubleClick, this);
    }, _onDoubleClick:function(t) {
      var e = this._map, i = e.getZoom() + (t.originalEvent.shiftKey ? -1 : 1);
      "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i);
    }}), o.Map.addInitHook("addHandler", "doubleClickZoom", o.Map.DoubleClickZoom), o.Map.mergeOptions({scrollWheelZoom:!0}), o.Map.ScrollWheelZoom = o.Handler.extend({addHooks:function() {
      o.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this), o.DomEvent.on(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault), this._delta = 0;
    }, removeHooks:function() {
      o.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll), o.DomEvent.off(this._map._container, "MozMousePixelScroll", o.DomEvent.preventDefault);
    }, _onWheelScroll:function(t) {
      var e = o.DomEvent.getWheelDelta(t);
      this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date);
      var i = Math.max(40 - (+new Date - this._startTime), 0);
      clearTimeout(this._timer), this._timer = setTimeout(o.bind(this._performZoom, this), i), o.DomEvent.preventDefault(t), o.DomEvent.stopPropagation(t);
    }, _performZoom:function() {
      var t = this._map, e = this._delta, i = t.getZoom();
      e = e > 0 ? Math.ceil(e) : Math.floor(e), e = Math.max(Math.min(e, 4), -4), e = t._limitZoom(i + e) - i, this._delta = 0, this._startTime = null, e && ("center" === t.options.scrollWheelZoom ? t.setZoom(i + e) : t.setZoomAround(this._lastMousePos, i + e));
    }}), o.Map.addInitHook("addHandler", "scrollWheelZoom", o.Map.ScrollWheelZoom), o.extend(o.DomEvent, {_touchstart:o.Browser.msPointer ? "MSPointerDown" : o.Browser.pointer ? "pointerdown" : "touchstart", _touchend:o.Browser.msPointer ? "MSPointerUp" : o.Browser.pointer ? "pointerup" : "touchend", addDoubleTapListener:function(t, i, n) {
      function s(t) {
        var e;
        if (o.Browser.pointer ? (_.push(t.pointerId), e = _.length) : e = t.touches.length, !(e > 1)) {
          var i = Date.now(), n = i - (r || i);
          h = t.touches ? t.touches[0] : t, l = n > 0 && u >= n, r = i;
        }
      }
      function a(t) {
        if (o.Browser.pointer) {
          var e = _.indexOf(t.pointerId);
          if (-1 === e) {
            return;
          }
          _.splice(e, 1);
        }
        if (l) {
          if (o.Browser.pointer) {
            var n, s = {};
            for (var a in h) {
              n = h[a], s[a] = "function" == typeof n ? n.bind(h) : n;
            }
            h = s;
          }
          h.type = "dblclick", i(h), r = null;
        }
      }
      var r, h, l = !1, u = 250, c = "_leaflet_", d = this._touchstart, p = this._touchend, _ = [];
      t[c + d + n] = s, t[c + p + n] = a;
      var m = o.Browser.pointer ? e.documentElement : t;
      return t.addEventListener(d, s, !1), m.addEventListener(p, a, !1), o.Browser.pointer && m.addEventListener(o.DomEvent.POINTER_CANCEL, a, !1), this;
    }, removeDoubleTapListener:function(t, i) {
      var n = "_leaflet_";
      return t.removeEventListener(this._touchstart, t[n + this._touchstart + i], !1), (o.Browser.pointer ? e.documentElement : t).removeEventListener(this._touchend, t[n + this._touchend + i], !1), o.Browser.pointer && e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL, t[n + this._touchend + i], !1), this;
    }}), o.extend(o.DomEvent, {POINTER_DOWN:o.Browser.msPointer ? "MSPointerDown" : "pointerdown", POINTER_MOVE:o.Browser.msPointer ? "MSPointerMove" : "pointermove", POINTER_UP:o.Browser.msPointer ? "MSPointerUp" : "pointerup", POINTER_CANCEL:o.Browser.msPointer ? "MSPointerCancel" : "pointercancel", _pointers:[], _pointerDocumentListener:!1, addPointerListener:function(t, e, i, n) {
      switch(e) {
        case "touchstart":
          return this.addPointerListenerStart(t, e, i, n);
        case "touchend":
          return this.addPointerListenerEnd(t, e, i, n);
        case "touchmove":
          return this.addPointerListenerMove(t, e, i, n);
        default:
          throw "Unknown touch event type";;
      }
    }, addPointerListenerStart:function(t, i, n, s) {
      var a = "_leaflet_", r = this._pointers, h = function(t) {
        o.DomEvent.preventDefault(t);
        for (var e = !1, i = 0;i < r.length;i++) {
          if (r[i].pointerId === t.pointerId) {
            e = !0;
            break;
          }
        }
        e || r.push(t), t.touches = r.slice(), t.changedTouches = [t], n(t);
      };
      if (t[a + "touchstart" + s] = h, t.addEventListener(this.POINTER_DOWN, h, !1), !this._pointerDocumentListener) {
        var l = function(t) {
          for (var e = 0;e < r.length;e++) {
            if (r[e].pointerId === t.pointerId) {
              r.splice(e, 1);
              break;
            }
          }
        };
        e.documentElement.addEventListener(this.POINTER_UP, l, !1), e.documentElement.addEventListener(this.POINTER_CANCEL, l, !1), this._pointerDocumentListener = !0;
      }
      return this;
    }, addPointerListenerMove:function(t, e, i, n) {
      function o(t) {
        if (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && "mouse" !== t.pointerType || 0 !== t.buttons) {
          for (var e = 0;e < a.length;e++) {
            if (a[e].pointerId === t.pointerId) {
              a[e] = t;
              break;
            }
          }
          t.touches = a.slice(), t.changedTouches = [t], i(t);
        }
      }
      var s = "_leaflet_", a = this._pointers;
      return t[s + "touchmove" + n] = o, t.addEventListener(this.POINTER_MOVE, o, !1), this;
    }, addPointerListenerEnd:function(t, e, i, n) {
      var o = "_leaflet_", s = this._pointers, a = function(t) {
        for (var e = 0;e < s.length;e++) {
          if (s[e].pointerId === t.pointerId) {
            s.splice(e, 1);
            break;
          }
        }
        t.touches = s.slice(), t.changedTouches = [t], i(t);
      };
      return t[o + "touchend" + n] = a, t.addEventListener(this.POINTER_UP, a, !1), t.addEventListener(this.POINTER_CANCEL, a, !1), this;
    }, removePointerListener:function(t, e, i) {
      var n = "_leaflet_", o = t[n + e + i];
      switch(e) {
        case "touchstart":
          t.removeEventListener(this.POINTER_DOWN, o, !1);
          break;
        case "touchmove":
          t.removeEventListener(this.POINTER_MOVE, o, !1);
          break;
        case "touchend":
          t.removeEventListener(this.POINTER_UP, o, !1), t.removeEventListener(this.POINTER_CANCEL, o, !1);
      }
      return this;
    }}), o.Map.mergeOptions({touchZoom:o.Browser.touch && !o.Browser.android23, bounceAtZoomLimits:!0}), o.Map.TouchZoom = o.Handler.extend({addHooks:function() {
      o.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this);
    }, removeHooks:function() {
      o.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this);
    }, _onTouchStart:function(t) {
      var i = this._map;
      if (t.touches && (2 === t.touches.length && (!i._animatingZoom && !this._zooming))) {
        var n = i.mouseEventToLayerPoint(t.touches[0]), s = i.mouseEventToLayerPoint(t.touches[1]), a = i._getCenterLayerPoint();
        this._startCenter = n.add(s)._divideBy(2), this._startDist = n.distanceTo(s), this._moved = !1, this._zooming = !0, this._centerOffset = a.subtract(this._startCenter), i._panAnim && i._panAnim.stop(), o.DomEvent.on(e, "touchmove", this._onTouchMove, this).on(e, "touchend", this._onTouchEnd, this), o.DomEvent.preventDefault(t);
      }
    }, _onTouchMove:function(t) {
      var e = this._map;
      if (t.touches && (2 === t.touches.length && this._zooming)) {
        var i = e.mouseEventToLayerPoint(t.touches[0]), n = e.mouseEventToLayerPoint(t.touches[1]);
        this._scale = i.distanceTo(n) / this._startDist, this._delta = i._add(n)._divideBy(2)._subtract(this._startCenter), 1 !== this._scale && ((e.options.bounceAtZoomLimits || !(e.getZoom() === e.getMinZoom() && this._scale < 1 || e.getZoom() === e.getMaxZoom() && this._scale > 1)) && (this._moved || (o.DomUtil.addClass(e._mapPane, "leaflet-touching"), e.fire("movestart").fire("zoomstart"), this._moved = !0), o.Util.cancelAnimFrame(this._animRequest), this._animRequest = o.Util.requestAnimFrame(this._updateOnMove, 
        this, !0, this._map._container), o.DomEvent.preventDefault(t)));
      }
    }, _updateOnMove:function() {
      var t = this._map, e = this._getScaleOrigin(), i = t.layerPointToLatLng(e), n = t.getScaleZoom(this._scale);
      t._animateZoom(i, n, this._startCenter, this._scale, this._delta);
    }, _onTouchEnd:function() {
      if (!this._moved || !this._zooming) {
        return void(this._zooming = !1);
      }
      var t = this._map;
      this._zooming = !1, o.DomUtil.removeClass(t._mapPane, "leaflet-touching"), o.Util.cancelAnimFrame(this._animRequest), o.DomEvent.off(e, "touchmove", this._onTouchMove).off(e, "touchend", this._onTouchEnd);
      var i = this._getScaleOrigin(), n = t.layerPointToLatLng(i), s = t.getZoom(), a = t.getScaleZoom(this._scale) - s, r = a > 0 ? Math.ceil(a) : Math.floor(a), h = t._limitZoom(s + r), l = t.getZoomScale(h) / this._scale;
      t._animateZoom(n, h, i, l);
    }, _getScaleOrigin:function() {
      var t = this._centerOffset.subtract(this._delta).divideBy(this._scale);
      return this._startCenter.add(t);
    }}), o.Map.addInitHook("addHandler", "touchZoom", o.Map.TouchZoom), o.Map.mergeOptions({tap:!0, tapTolerance:15}), o.Map.Tap = o.Handler.extend({addHooks:function() {
      o.DomEvent.on(this._map._container, "touchstart", this._onDown, this);
    }, removeHooks:function() {
      o.DomEvent.off(this._map._container, "touchstart", this._onDown, this);
    }, _onDown:function(t) {
      if (t.touches) {
        if (o.DomEvent.preventDefault(t), this._fireClick = !0, t.touches.length > 1) {
          return this._fireClick = !1, void clearTimeout(this._holdTimeout);
        }
        var i = t.touches[0], n = i.target;
        this._startPos = this._newPos = new o.Point(i.clientX, i.clientY), n.tagName && ("a" === n.tagName.toLowerCase() && o.DomUtil.addClass(n, "leaflet-active")), this._holdTimeout = setTimeout(o.bind(function() {
          this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent("contextmenu", i));
        }, this), 1E3), o.DomEvent.on(e, "touchmove", this._onMove, this).on(e, "touchend", this._onUp, this);
      }
    }, _onUp:function(t) {
      if (clearTimeout(this._holdTimeout), o.DomEvent.off(e, "touchmove", this._onMove, this).off(e, "touchend", this._onUp, this), this._fireClick && (t && t.changedTouches)) {
        var i = t.changedTouches[0], n = i.target;
        n && (n.tagName && ("a" === n.tagName.toLowerCase() && o.DomUtil.removeClass(n, "leaflet-active"))), this._isTapValid() && this._simulateEvent("click", i);
      }
    }, _isTapValid:function() {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    }, _onMove:function(t) {
      var e = t.touches[0];
      this._newPos = new o.Point(e.clientX, e.clientY);
    }, _simulateEvent:function(i, n) {
      var o = e.createEvent("MouseEvents");
      o._simulated = !0, n.target._simulatedClick = !0, o.initMouseEvent(i, !0, !0, t, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), n.target.dispatchEvent(o);
    }}), o.Browser.touch && (!o.Browser.pointer && o.Map.addInitHook("addHandler", "tap", o.Map.Tap)), o.Map.mergeOptions({boxZoom:!0}), o.Map.BoxZoom = o.Handler.extend({initialize:function(t) {
      this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._moved = !1;
    }, addHooks:function() {
      o.DomEvent.on(this._container, "mousedown", this._onMouseDown, this);
    }, removeHooks:function() {
      o.DomEvent.off(this._container, "mousedown", this._onMouseDown), this._moved = !1;
    }, moved:function() {
      return this._moved;
    }, _onMouseDown:function(t) {
      return this._moved = !1, !t.shiftKey || 1 !== t.which && 1 !== t.button ? !1 : (o.DomUtil.disableTextSelection(), o.DomUtil.disableImageDrag(), this._startLayerPoint = this._map.mouseEventToLayerPoint(t), void o.DomEvent.on(e, "mousemove", this._onMouseMove, this).on(e, "mouseup", this._onMouseUp, this).on(e, "keydown", this._onKeyDown, this));
    }, _onMouseMove:function(t) {
      this._moved || (this._box = o.DomUtil.create("div", "leaflet-zoom-box", this._pane), o.DomUtil.setPosition(this._box, this._startLayerPoint), this._container.style.cursor = "crosshair", this._map.fire("boxzoomstart"));
      var e = this._startLayerPoint, i = this._box, n = this._map.mouseEventToLayerPoint(t), s = n.subtract(e), a = new o.Point(Math.min(n.x, e.x), Math.min(n.y, e.y));
      o.DomUtil.setPosition(i, a), this._moved = !0, i.style.width = Math.max(0, Math.abs(s.x) - 4) + "px", i.style.height = Math.max(0, Math.abs(s.y) - 4) + "px";
    }, _finish:function() {
      this._moved && (this._pane.removeChild(this._box), this._container.style.cursor = ""), o.DomUtil.enableTextSelection(), o.DomUtil.enableImageDrag(), o.DomEvent.off(e, "mousemove", this._onMouseMove).off(e, "mouseup", this._onMouseUp).off(e, "keydown", this._onKeyDown);
    }, _onMouseUp:function(t) {
      this._finish();
      var e = this._map, i = e.mouseEventToLayerPoint(t);
      if (!this._startLayerPoint.equals(i)) {
        var n = new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint), e.layerPointToLatLng(i));
        e.fitBounds(n), e.fire("boxzoomend", {boxZoomBounds:n});
      }
    }, _onKeyDown:function(t) {
      27 === t.keyCode && this._finish();
    }}), o.Map.addInitHook("addHandler", "boxZoom", o.Map.BoxZoom), o.Map.mergeOptions({keyboard:!0, keyboardPanOffset:80, keyboardZoomOffset:1}), o.Map.Keyboard = o.Handler.extend({keyCodes:{left:[37], right:[39], down:[40], up:[38], zoomIn:[187, 107, 61, 171], zoomOut:[189, 109, 173]}, initialize:function(t) {
      this._map = t, this._setPanOffset(t.options.keyboardPanOffset), this._setZoomOffset(t.options.keyboardZoomOffset);
    }, addHooks:function() {
      var t = this._map._container;
      -1 === t.tabIndex && (t.tabIndex = "0"), o.DomEvent.on(t, "focus", this._onFocus, this).on(t, "blur", this._onBlur, this).on(t, "mousedown", this._onMouseDown, this), this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this);
    }, removeHooks:function() {
      this._removeHooks();
      var t = this._map._container;
      o.DomEvent.off(t, "focus", this._onFocus, this).off(t, "blur", this._onBlur, this).off(t, "mousedown", this._onMouseDown, this), this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this);
    }, _onMouseDown:function() {
      if (!this._focused) {
        var i = e.body, n = e.documentElement, o = i.scrollTop || n.scrollTop, s = i.scrollLeft || n.scrollLeft;
        this._map._container.focus(), t.scrollTo(s, o);
      }
    }, _onFocus:function() {
      this._focused = !0, this._map.fire("focus");
    }, _onBlur:function() {
      this._focused = !1, this._map.fire("blur");
    }, _setPanOffset:function(t) {
      var e, i, n = this._panKeys = {}, o = this.keyCodes;
      for (e = 0, i = o.left.length;i > e;e++) {
        n[o.left[e]] = [-1 * t, 0];
      }
      for (e = 0, i = o.right.length;i > e;e++) {
        n[o.right[e]] = [t, 0];
      }
      for (e = 0, i = o.down.length;i > e;e++) {
        n[o.down[e]] = [0, t];
      }
      for (e = 0, i = o.up.length;i > e;e++) {
        n[o.up[e]] = [0, -1 * t];
      }
    }, _setZoomOffset:function(t) {
      var e, i, n = this._zoomKeys = {}, o = this.keyCodes;
      for (e = 0, i = o.zoomIn.length;i > e;e++) {
        n[o.zoomIn[e]] = t;
      }
      for (e = 0, i = o.zoomOut.length;i > e;e++) {
        n[o.zoomOut[e]] = -t;
      }
    }, _addHooks:function() {
      o.DomEvent.on(e, "keydown", this._onKeyDown, this);
    }, _removeHooks:function() {
      o.DomEvent.off(e, "keydown", this._onKeyDown, this);
    }, _onKeyDown:function(t) {
      var e = t.keyCode, i = this._map;
      if (e in this._panKeys) {
        if (i._panAnim && i._panAnim._inProgress) {
          return;
        }
        i.panBy(this._panKeys[e]), i.options.maxBounds && i.panInsideBounds(i.options.maxBounds);
      } else {
        if (!(e in this._zoomKeys)) {
          return;
        }
        i.setZoom(i.getZoom() + this._zoomKeys[e]);
      }
      o.DomEvent.stop(t);
    }}), o.Map.addInitHook("addHandler", "keyboard", o.Map.Keyboard), o.Handler.MarkerDrag = o.Handler.extend({initialize:function(t) {
      this._marker = t;
    }, addHooks:function() {
      var t = this._marker._icon;
      this._draggable || (this._draggable = new o.Draggable(t, t)), this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this), this._draggable.enable(), o.DomUtil.addClass(this._marker._icon, "leaflet-marker-draggable");
    }, removeHooks:function() {
      this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this), this._draggable.disable(), o.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable");
    }, moved:function() {
      return this._draggable && this._draggable._moved;
    }, _onDragStart:function() {
      this._marker.closePopup().fire("movestart").fire("dragstart");
    }, _onDrag:function() {
      var t = this._marker, e = t._shadow, i = o.DomUtil.getPosition(t._icon), n = t._map.layerPointToLatLng(i);
      e && o.DomUtil.setPosition(e, i), t._latlng = n, t.fire("move", {latlng:n}).fire("drag");
    }, _onDragEnd:function(t) {
      this._marker.fire("moveend").fire("dragend", t);
    }}), o.Control = o.Class.extend({options:{position:"topright"}, initialize:function(t) {
      o.setOptions(this, t);
    }, getPosition:function() {
      return this.options.position;
    }, setPosition:function(t) {
      var e = this._map;
      return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this;
    }, getContainer:function() {
      return this._container;
    }, addTo:function(t) {
      this._map = t;
      var e = this._container = this.onAdd(t), i = this.getPosition(), n = t._controlCorners[i];
      return o.DomUtil.addClass(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? n.insertBefore(e, n.firstChild) : n.appendChild(e), this;
    }, removeFrom:function(t) {
      var e = this.getPosition(), i = t._controlCorners[e];
      return i.removeChild(this._container), this._map = null, this.onRemove && this.onRemove(t), this;
    }, _refocusOnMap:function() {
      this._map && this._map.getContainer().focus();
    }}), o.control = function(t) {
      return new o.Control(t);
    }, o.Map.include({addControl:function(t) {
      return t.addTo(this), this;
    }, removeControl:function(t) {
      return t.removeFrom(this), this;
    }, _initControlPos:function() {
      function t(t, s) {
        var a = i + t + " " + i + s;
        e[t + s] = o.DomUtil.create("div", a, n);
      }
      var e = this._controlCorners = {}, i = "leaflet-", n = this._controlContainer = o.DomUtil.create("div", i + "control-container", this._container);
      t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right");
    }, _clearControlPos:function() {
      this._container.removeChild(this._controlContainer);
    }}), o.Control.Zoom = o.Control.extend({options:{position:"topleft", zoomInText:"+", zoomInTitle:"Zoom in", zoomOutText:"-", zoomOutTitle:"Zoom out"}, onAdd:function(t) {
      var e = "leaflet-control-zoom", i = o.DomUtil.create("div", e + " leaflet-bar");
      return this._map = t, this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, e + "-in", i, this._zoomIn, this), this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, e + "-out", i, this._zoomOut, this), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i;
    }, onRemove:function(t) {
      t.off("zoomend zoomlevelschange", this._updateDisabled, this);
    }, _zoomIn:function(t) {
      this._map.zoomIn(t.shiftKey ? 3 : 1);
    }, _zoomOut:function(t) {
      this._map.zoomOut(t.shiftKey ? 3 : 1);
    }, _createButton:function(t, e, i, n, s, a) {
      var r = o.DomUtil.create("a", i, n);
      r.innerHTML = t, r.href = "#", r.title = e;
      var h = o.DomEvent.stopPropagation;
      return o.DomEvent.on(r, "click", h).on(r, "mousedown", h).on(r, "dblclick", h).on(r, "click", o.DomEvent.preventDefault).on(r, "click", s, a).on(r, "click", this._refocusOnMap, a), r;
    }, _updateDisabled:function() {
      var t = this._map, e = "leaflet-disabled";
      o.DomUtil.removeClass(this._zoomInButton, e), o.DomUtil.removeClass(this._zoomOutButton, e), t._zoom === t.getMinZoom() && o.DomUtil.addClass(this._zoomOutButton, e), t._zoom === t.getMaxZoom() && o.DomUtil.addClass(this._zoomInButton, e);
    }}), o.Map.mergeOptions({zoomControl:!0}), o.Map.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new o.Control.Zoom, this.addControl(this.zoomControl));
    }), o.control.zoom = function(t) {
      return new o.Control.Zoom(t);
    }, o.Control.Attribution = o.Control.extend({options:{position:"bottomright", prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'}, initialize:function(t) {
      o.setOptions(this, t), this._attributions = {};
    }, onAdd:function(t) {
      this._container = o.DomUtil.create("div", "leaflet-control-attribution"), o.DomEvent.disableClickPropagation(this._container);
      for (var e in t._layers) {
        t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
      }
      return t.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this), this._update(), this._container;
    }, onRemove:function(t) {
      t.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove);
    }, setPrefix:function(t) {
      return this.options.prefix = t, this._update(), this;
    }, addAttribution:function(t) {
      return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : void 0;
    }, removeAttribution:function(t) {
      return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : void 0;
    }, _update:function() {
      if (this._map) {
        var t = [];
        for (var e in this._attributions) {
          this._attributions[e] && t.push(e);
        }
        var i = [];
        this.options.prefix && i.push(this.options.prefix), t.length && i.push(t.join(", ")), this._container.innerHTML = i.join(" | ");
      }
    }, _onLayerAdd:function(t) {
      t.layer.getAttribution && this.addAttribution(t.layer.getAttribution());
    }, _onLayerRemove:function(t) {
      t.layer.getAttribution && this.removeAttribution(t.layer.getAttribution());
    }}), o.Map.mergeOptions({attributionControl:!0}), o.Map.addInitHook(function() {
      this.options.attributionControl && (this.attributionControl = (new o.Control.Attribution).addTo(this));
    }), o.control.attribution = function(t) {
      return new o.Control.Attribution(t);
    }, o.Control.Scale = o.Control.extend({options:{position:"bottomleft", maxWidth:100, metric:!0, imperial:!0, updateWhenIdle:!1}, onAdd:function(t) {
      this._map = t;
      var e = "leaflet-control-scale", i = o.DomUtil.create("div", e), n = this.options;
      return this._addScales(n, e, i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i;
    }, onRemove:function(t) {
      t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
    }, _addScales:function(t, e, i) {
      t.metric && (this._mScale = o.DomUtil.create("div", e + "-line", i)), t.imperial && (this._iScale = o.DomUtil.create("div", e + "-line", i));
    }, _update:function() {
      var t = this._map.getBounds(), e = t.getCenter().lat, i = 6378137 * Math.PI * Math.cos(e * Math.PI / 180), n = i * (t.getNorthEast().lng - t.getSouthWest().lng) / 180, o = this._map.getSize(), s = this.options, a = 0;
      o.x > 0 && (a = n * (s.maxWidth / o.x)), this._updateScales(s, a);
    }, _updateScales:function(t, e) {
      t.metric && (e && this._updateMetric(e)), t.imperial && (e && this._updateImperial(e));
    }, _updateMetric:function(t) {
      var e = this._getRoundNum(t);
      this._mScale.style.width = this._getScaleWidth(e / t) + "px", this._mScale.innerHTML = 1E3 > e ? e + " m" : e / 1E3 + " km";
    }, _updateImperial:function(t) {
      var e, i, n, o = 3.2808399 * t, s = this._iScale;
      o > 5280 ? (e = o / 5280, i = this._getRoundNum(e), s.style.width = this._getScaleWidth(i / e) + "px", s.innerHTML = i + " mi") : (n = this._getRoundNum(o), s.style.width = this._getScaleWidth(n / o) + "px", s.innerHTML = n + " ft");
    }, _getScaleWidth:function(t) {
      return Math.round(this.options.maxWidth * t) - 10;
    }, _getRoundNum:function(t) {
      var e = Math.pow(10, (Math.floor(t) + "").length - 1), i = t / e;
      return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : 1, e * i;
    }}), o.control.scale = function(t) {
      return new o.Control.Scale(t);
    }, o.Control.Layers = o.Control.extend({options:{collapsed:!0, position:"topright", autoZIndex:!0}, initialize:function(t, e, i) {
      o.setOptions(this, i), this._layers = {}, this._lastZIndex = 0, this._handlingClick = !1;
      for (var n in t) {
        this._addLayer(t[n], n);
      }
      for (n in e) {
        this._addLayer(e[n], n, !0);
      }
    }, onAdd:function(t) {
      return this._initLayout(), this._update(), t.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this), this._container;
    }, onRemove:function(t) {
      t.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange);
    }, addBaseLayer:function(t, e) {
      return this._addLayer(t, e), this._update(), this;
    }, addOverlay:function(t, e) {
      return this._addLayer(t, e, !0), this._update(), this;
    }, removeLayer:function(t) {
      var e = o.stamp(t);
      return delete this._layers[e], this._update(), this;
    }, _initLayout:function() {
      var t = "leaflet-control-layers", e = this._container = o.DomUtil.create("div", t);
      e.setAttribute("aria-haspopup", !0), o.Browser.touch ? o.DomEvent.on(e, "click", o.DomEvent.stopPropagation) : o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);
      var i = this._form = o.DomUtil.create("form", t + "-list");
      if (this.options.collapsed) {
        o.Browser.android || o.DomEvent.on(e, "mouseover", this._expand, this).on(e, "mouseout", this._collapse, this);
        var n = this._layersLink = o.DomUtil.create("a", t + "-toggle", e);
        n.href = "#", n.title = "Layers", o.Browser.touch ? o.DomEvent.on(n, "click", o.DomEvent.stop).on(n, "click", this._expand, this) : o.DomEvent.on(n, "focus", this._expand, this), o.DomEvent.on(i, "click", function() {
          setTimeout(o.bind(this._onInputClick, this), 0);
        }, this), this._map.on("click", this._collapse, this);
      } else {
        this._expand();
      }
      this._baseLayersList = o.DomUtil.create("div", t + "-base", i), this._separator = o.DomUtil.create("div", t + "-separator", i), this._overlaysList = o.DomUtil.create("div", t + "-overlays", i), e.appendChild(i);
    }, _addLayer:function(t, e, i) {
      var n = o.stamp(t);
      this._layers[n] = {layer:t, name:e, overlay:i}, this.options.autoZIndex && (t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)));
    }, _update:function() {
      if (this._container) {
        this._baseLayersList.innerHTML = "", this._overlaysList.innerHTML = "";
        var t, e, i = !1, n = !1;
        for (t in this._layers) {
          e = this._layers[t], this._addItem(e), n = n || e.overlay, i = i || !e.overlay;
        }
        this._separator.style.display = n && i ? "" : "none";
      }
    }, _onLayerChange:function(t) {
      var e = this._layers[o.stamp(t.layer)];
      if (e) {
        this._handlingClick || this._update();
        var i = e.overlay ? "layeradd" === t.type ? "overlayadd" : "overlayremove" : "layeradd" === t.type ? "baselayerchange" : null;
        i && this._map.fire(i, e);
      }
    }, _createRadioElement:function(t, i) {
      var n = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"';
      i && (n += ' checked="checked"'), n += "/>";
      var o = e.createElement("div");
      return o.innerHTML = n, o.firstChild;
    }, _addItem:function(t) {
      var i, n = e.createElement("label"), s = this._map.hasLayer(t.layer);
      t.overlay ? (i = e.createElement("input"), i.type = "checkbox", i.className = "leaflet-control-layers-selector", i.defaultChecked = s) : i = this._createRadioElement("leaflet-base-layers", s), i.layerId = o.stamp(t.layer), o.DomEvent.on(i, "click", this._onInputClick, this);
      var a = e.createElement("span");
      a.innerHTML = " " + t.name, n.appendChild(i), n.appendChild(a);
      var r = t.overlay ? this._overlaysList : this._baseLayersList;
      return r.appendChild(n), n;
    }, _onInputClick:function() {
      var t, e, i, n = this._form.getElementsByTagName("input"), o = n.length;
      for (this._handlingClick = !0, t = 0;o > t;t++) {
        e = n[t], i = this._layers[e.layerId], e.checked && !this._map.hasLayer(i.layer) ? this._map.addLayer(i.layer) : !e.checked && (this._map.hasLayer(i.layer) && this._map.removeLayer(i.layer));
      }
      this._handlingClick = !1, this._refocusOnMap();
    }, _expand:function() {
      o.DomUtil.addClass(this._container, "leaflet-control-layers-expanded");
    }, _collapse:function() {
      this._container.className = this._container.className.replace(" leaflet-control-layers-expanded", "");
    }}), o.control.layers = function(t, e, i) {
      return new o.Control.Layers(t, e, i);
    }, o.PosAnimation = o.Class.extend({includes:o.Mixin.Events, run:function(t, e, i, n) {
      this.stop(), this._el = t, this._inProgress = !0, this._newPos = e, this.fire("start"), t.style[o.DomUtil.TRANSITION] = "all " + (i || 0.25) + "s cubic-bezier(0,0," + (n || 0.5) + ",1)", o.DomEvent.on(t, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), o.DomUtil.setPosition(t, e), o.Util.falseFn(t.offsetWidth), this._stepTimer = setInterval(o.bind(this._onStep, this), 50);
    }, stop:function() {
      this._inProgress && (o.DomUtil.setPosition(this._el, this._getPos()), this._onTransitionEnd(), o.Util.falseFn(this._el.offsetWidth));
    }, _onStep:function() {
      var t = this._getPos();
      return t ? (this._el._leaflet_pos = t, void this.fire("step")) : void this._onTransitionEnd();
    }, _transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/, _getPos:function() {
      var e, i, n, s = this._el, a = t.getComputedStyle(s);
      if (o.Browser.any3d) {
        if (n = a[o.DomUtil.TRANSFORM].match(this._transformRe), !n) {
          return;
        }
        e = parseFloat(n[1]), i = parseFloat(n[2]);
      } else {
        e = parseFloat(a.left), i = parseFloat(a.top);
      }
      return new o.Point(e, i, !0);
    }, _onTransitionEnd:function() {
      o.DomEvent.off(this._el, o.DomUtil.TRANSITION_END, this._onTransitionEnd, this), this._inProgress && (this._inProgress = !1, this._el.style[o.DomUtil.TRANSITION] = "", this._el._leaflet_pos = this._newPos, clearInterval(this._stepTimer), this.fire("step").fire("end"));
    }}), o.Map.include({setView:function(t, e, n) {
      if (e = e === i ? this._zoom : this._limitZoom(e), t = this._limitCenter(o.latLng(t), e, this.options.maxBounds), n = n || {}, this._panAnim && this._panAnim.stop(), this._loaded && (!n.reset && n !== !0)) {
        n.animate !== i && (n.zoom = o.extend({animate:n.animate}, n.zoom), n.pan = o.extend({animate:n.animate}, n.pan));
        var s = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan);
        if (s) {
          return clearTimeout(this._sizeTimer), this;
        }
      }
      return this._resetView(t, e), this;
    }, panBy:function(t, e) {
      if (t = o.point(t).round(), e = e || {}, !t.x && !t.y) {
        return this;
      }
      if (this._panAnim || (this._panAnim = new o.PosAnimation, this._panAnim.on({step:this._onPanTransitionStep, end:this._onPanTransitionEnd}, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
        o.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
        var i = this._getMapPanePos().subtract(t);
        this._panAnim.run(this._mapPane, i, e.duration || 0.25, e.easeLinearity);
      } else {
        this._rawPanBy(t), this.fire("move").fire("moveend");
      }
      return this;
    }, _onPanTransitionStep:function() {
      this.fire("move");
    }, _onPanTransitionEnd:function() {
      o.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
    }, _tryAnimatedPan:function(t, e) {
      var i = this._getCenterOffset(t)._floor();
      return(e && e.animate) === !0 || this.getSize().contains(i) ? (this.panBy(i, e), !0) : !1;
    }}), o.PosAnimation = o.DomUtil.TRANSITION ? o.PosAnimation : o.PosAnimation.extend({run:function(t, e, i, n) {
      this.stop(), this._el = t, this._inProgress = !0, this._duration = i || 0.25, this._easeOutPower = 1 / Math.max(n || 0.5, 0.2), this._startPos = o.DomUtil.getPosition(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate();
    }, stop:function() {
      this._inProgress && (this._step(), this._complete());
    }, _animate:function() {
      this._animId = o.Util.requestAnimFrame(this._animate, this), this._step();
    }, _step:function() {
      var t = +new Date - this._startTime, e = 1E3 * this._duration;
      e > t ? this._runFrame(this._easeOut(t / e)) : (this._runFrame(1), this._complete());
    }, _runFrame:function(t) {
      var e = this._startPos.add(this._offset.multiplyBy(t));
      o.DomUtil.setPosition(this._el, e), this.fire("step");
    }, _complete:function() {
      o.Util.cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end");
    }, _easeOut:function(t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }}), o.Map.mergeOptions({zoomAnimation:!0, zoomAnimationThreshold:4}), o.DomUtil.TRANSITION && o.Map.addInitHook(function() {
      this._zoomAnimated = this.options.zoomAnimation && (o.DomUtil.TRANSITION && (o.Browser.any3d && (!o.Browser.android23 && !o.Browser.mobileOpera))), this._zoomAnimated && o.DomEvent.on(this._mapPane, o.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
    }), o.Map.include(o.DomUtil.TRANSITION ? {_catchTransitionEnd:function(t) {
      this._animatingZoom && (t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd());
    }, _nothingToAnimate:function() {
      return!this._container.getElementsByClassName("leaflet-zoom-animated").length;
    }, _tryAnimatedZoom:function(t, e, i) {
      if (this._animatingZoom) {
        return!0;
      }
      if (i = i || {}, !this._zoomAnimated || (i.animate === !1 || (this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold))) {
        return!1;
      }
      var n = this.getZoomScale(e), o = this._getCenterOffset(t)._divideBy(1 - 1 / n), s = this._getCenterLayerPoint()._add(o);
      return i.animate === !0 || this.getSize().contains(o) ? (this.fire("movestart").fire("zoomstart"), this._animateZoom(t, e, s, n, null, !0), !0) : !1;
    }, _animateZoom:function(t, e, i, n, s, a) {
      this._animatingZoom = !0, o.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim"), this._animateToCenter = t, this._animateToZoom = e, o.Draggable && (o.Draggable._disabled = !0), this.fire("zoomanim", {center:t, zoom:e, origin:i, scale:n, delta:s, backwards:a});
    }, _onZoomTransitionEnd:function() {
      this._animatingZoom = !1, o.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim"), this._resetView(this._animateToCenter, this._animateToZoom, !0, !0), o.Draggable && (o.Draggable._disabled = !1);
    }} : {}), o.TileLayer.include({_animateZoom:function(t) {
      this._animating || (this._animating = !0, this._prepareBgBuffer());
      var e = this._bgBuffer, i = o.DomUtil.TRANSFORM, n = t.delta ? o.DomUtil.getTranslateString(t.delta) : e.style[i], s = o.DomUtil.getScaleString(t.scale, t.origin);
      e.style[i] = t.backwards ? s + " " + n : n + " " + s;
    }, _endZoomAnim:function() {
      var t = this._tileContainer, e = this._bgBuffer;
      t.style.visibility = "", t.parentNode.appendChild(t), o.Util.falseFn(e.offsetWidth), this._animating = !1;
    }, _clearBgBuffer:function() {
      var t = this._map;
      !t || (t._animatingZoom || (t.touchZoom._zooming || (this._bgBuffer.innerHTML = "", this._bgBuffer.style[o.DomUtil.TRANSFORM] = "")));
    }, _prepareBgBuffer:function() {
      var t = this._tileContainer, e = this._bgBuffer, i = this._getLoadedTilesPercentage(e), n = this._getLoadedTilesPercentage(t);
      return e && (i > 0.5 && 0.5 > n) ? (t.style.visibility = "hidden", void this._stopLoadingImages(t)) : (e.style.visibility = "hidden", e.style[o.DomUtil.TRANSFORM] = "", this._tileContainer = e, e = this._bgBuffer = t, this._stopLoadingImages(e), void clearTimeout(this._clearBgBufferTimer));
    }, _getLoadedTilesPercentage:function(t) {
      var e, i, n = t.getElementsByTagName("img"), o = 0;
      for (e = 0, i = n.length;i > e;e++) {
        n[e].complete && o++;
      }
      return o / i;
    }, _stopLoadingImages:function(t) {
      var e, i, n, s = Array.prototype.slice.call(t.getElementsByTagName("img"));
      for (e = 0, i = s.length;i > e;e++) {
        n = s[e], n.complete || (n.onload = o.Util.falseFn, n.onerror = o.Util.falseFn, n.src = o.Util.emptyImageUrl, n.parentNode.removeChild(n));
      }
    }}), o.Map.include({_defaultLocateOptions:{watch:!1, setView:!1, maxZoom:1 / 0, timeout:1E4, maximumAge:0, enableHighAccuracy:!1}, locate:function(t) {
      if (t = this._locateOptions = o.extend(this._defaultLocateOptions, t), !navigator.geolocation) {
        return this._handleGeolocationError({code:0, message:"Geolocation not supported."}), this;
      }
      var e = o.bind(this._handleGeolocationResponse, this), i = o.bind(this._handleGeolocationError, this);
      return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this;
    }, stopLocate:function() {
      return navigator.geolocation && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
    }, _handleGeolocationError:function(t) {
      var e = t.code, i = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout");
      this._locateOptions.setView && (!this._loaded && this.fitWorld()), this.fire("locationerror", {code:e, message:"Geolocation error: " + i + "."});
    }, _handleGeolocationResponse:function(t) {
      var e = t.coords.latitude, i = t.coords.longitude, n = new o.LatLng(e, i), s = 180 * t.coords.accuracy / 40075017, a = s / Math.cos(o.LatLng.DEG_TO_RAD * e), r = o.latLngBounds([e - s, i - a], [e + s, i + a]), h = this._locateOptions;
      if (h.setView) {
        var l = Math.min(this.getBoundsZoom(r), h.maxZoom);
        this.setView(n, l);
      }
      var u = {latlng:n, bounds:r, timestamp:t.timestamp};
      for (var c in t.coords) {
        "number" == typeof t.coords[c] && (u[c] = t.coords[c]);
      }
      this.fire("locationfound", u);
    }});
  }(window, document);
}
;function InputStream(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
  this.convBuf = new ArrayBuffer(8);
  this.convUint8 = new Uint8Array(this.convBuf);
  this.convUint16 = new Uint16Array(this.convBuf);
  this.convInt32 = new Int32Array(this.convBuf);
  this.convUint32 = new Uint32Array(this.convBuf);
  this.convFloat32 = new Float32Array(this.convBuf);
  this.convFloat64 = new Float64Array(this.convBuf);
}
InputStream.prototype.seek = function(off) {
  this.offset = off;
};
InputStream.prototype.getBytes = function(len) {
  var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
  this.offset += len;
  return ret;
};
InputStream.prototype.getVarints = function() {
  var b;
  var value = 0;
  var shiftBy = 0;
  do {
    b = this.buffer[this.offset++];
    value |= (b & 127) << shiftBy;
    shiftBy += 7;
  } while (b & 128);
  return value;
};
InputStream.prototype.getUint8 = function() {
  return this.buffer[this.offset++];
};
InputStream.prototype.getUint16 = function() {
  this.convUint8[0] = this.buffer[this.offset++];
  this.convUint8[1] = this.buffer[this.offset++];
  return this.convUint16[0];
};
InputStream.prototype.getInt16 = function() {
  var tmp = this.getUint16();
  if (tmp > 32767) {
    tmp = tmp | 4294901760;
  }
  return tmp;
};
InputStream.prototype.getInt32 = function() {
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convInt32[0];
};
InputStream.prototype.getUint32 = function() {
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convUint32[0];
};
InputStream.prototype.getFloat32 = function() {
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convFloat32[0];
};
InputStream.prototype.getFloat64 = function() {
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  for (var i = 0;i < 8;i++) {
    dst[i] = src[off + i];
  }
  this.offset += 8;
  return this.convFloat64[0];
};
InputStream.prototype.getString = function(len) {
  var src = this.buffer;
  var dst = "";
  for (var i = this.offset, iEnd = this.offset + len;i < iEnd;i++) {
    dst += String.fromCharCode(src[i]);
  }
  this.offset += len;
  return decodeURIComponent(escape(dst));
};
InputStream.prototype.reset = function(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
};
VBUtils = {deduceUVRepetition:function(mesh) {
  for (var p in mesh.vblayout) {
    if (p.indexOf("uv") != 0) {
      continue;
    }
    var baseOffset = mesh.vblayout[p].offset;
    var floatStride = mesh.vbstride;
    var vbf = mesh.vb;
    var vcount = mesh.vb.length / floatStride;
    for (var i = 0, offset = baseOffset;i < vcount;i++, offset += floatStride) {
      var u = vbf[offset];
      var v = vbf[offset + 1];
      if (u > 2 || (u < 0 || (v > 2 || v < 0))) {
        mesh.vblayout[p].isPattern = true;
        break;
      }
    }
  }
}, computeBounds3D:function(mesh) {
  var minx = Infinity, miny = Infinity, minz = Infinity;
  var maxx = -Infinity, maxy = -Infinity, maxz = -Infinity;
  var i, offset, x, y, z;
  var floatStride = mesh.vbstride;
  var baseOffset = mesh.vblayout.position.offset;
  var vbf = mesh.vb;
  var vcount = mesh.vb.length / floatStride;
  for (i = 0, offset = baseOffset;i < vcount;i++, offset += floatStride) {
    x = vbf[offset];
    y = vbf[offset + 1];
    z = vbf[offset + 2];
    if (minx > x) {
      minx = x;
    }
    if (miny > y) {
      miny = y;
    }
    if (minz > z) {
      minz = z;
    }
    if (maxx < x) {
      maxx = x;
    }
    if (maxy < y) {
      maxy = y;
    }
    if (maxz < z) {
      maxz = z;
    }
  }
  var bb = mesh.boundingBox = new THREE.Box3;
  bb.min.set(minx, miny, minz);
  bb.max.set(maxx, maxy, maxz);
  var cx = 0.5 * (minx + maxx), cy = 0.5 * (miny + maxy), cz = 0.5 * (minz + maxz);
  var bs = mesh.boundingSphere = new THREE.Sphere;
  bs.center.set(cx, cy, cz);
  var maxRadiusSq = 0;
  for (i = 0, offset = baseOffset;i < vcount;i++, offset += floatStride) {
    x = vbf[offset];
    y = vbf[offset + 1];
    z = vbf[offset + 2];
    var dx = x - cx;
    var dy = y - cy;
    var dz = z - cz;
    var distsq = dx * dx + dy * dy + dz * dz;
    if (distsq > maxRadiusSq) {
      maxRadiusSq = distsq;
    }
  }
  bs.radius = Math.sqrt(maxRadiusSq);
}, computeBounds2D:function(mesh) {
  if (!mesh.boundingBox) {
    var minx = Infinity, miny = Infinity;
    var maxx = -Infinity, maxy = -Infinity;
    var i, x, y, offset;
    var floatStride = mesh.vbstride;
    var baseOffset = mesh.vblayout.position.offset;
    var vbf = mesh.vb;
    var vcount = mesh.vb.length / floatStride;
    for (i = 0, offset = baseOffset;i < vcount;i++, offset += floatStride) {
      x = vbf[offset];
      y = vbf[offset + 1];
      if (minx > x) {
        minx = x;
      }
      if (miny > y) {
        miny = y;
      }
      if (maxx < x) {
        maxx = x;
      }
      if (maxy < y) {
        maxy = y;
      }
    }
    var bb = mesh.boundingBox = new THREE.Box3;
    var sz = Math.max(maxx - minx, maxy - miny);
    bb.min.set(minx, miny, -sz * 0.001);
    bb.max.set(maxx, maxy, sz * 0.001);
  }
  var bs = mesh.boundingSphere = new THREE.Sphere;
  bs.center.copy(mesh.boundingBox.center());
  bs.radius = 0.5 * mesh.boundingBox.size().length();
}};
var VBB_LINE_SEGMENT = 16, VBB_ARC_CIRCULAR = 32, VBB_ARC_ELLIPTICAL = 48, VBB_TEX_QUAD = 64, VBB_SEG_START_RIGHT = 1, VBB_SEG_START_LEFT = 2, VBB_SEG_END_RIGHT = 3, VBB_SEG_END_LEFT = 4;
var TAU = Math.PI * 2;
function VertexBufferBuilder() {
  this.stride = 8;
  this.vb = new ArrayBuffer(this.stride * 4 * 65536);
  this.vbf = new Float32Array(this.vb);
  this.vbi = new Int32Array(this.vb);
  this.vcount = 0;
  this.ib = new Uint16Array(65536);
  this.icount = 0;
  this.minx = this.miny = Infinity;
  this.maxx = this.maxy = -Infinity;
}
VertexBufferBuilder.prototype.expandStride = function() {
  var expandBy = 4;
  var stride = this.stride;
  if (stride > 8) {
    return;
  }
  var nstride = this.stride + expandBy;
  var nvb = new ArrayBuffer(nstride * (this.vb.byteLength / stride));
  var src = new Uint8Array(this.vb);
  var dst = new Uint8Array(nvb);
  for (var i = 0, iEnd = this.vcount;i < iEnd;i++) {
    var os = i * stride * 4;
    var od = i * nstride * 4;
    for (var j = 0;j < stride * 4;j++) {
      dst[od + j] = src[os + j];
    }
  }
  this.vb = nvb;
  this.vbf = new Float32Array(nvb);
  this.vbi = new Int32Array(nvb);
  this.stride = nstride;
};
VertexBufferBuilder.prototype.addVertex = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer) {
  var vi = this.vcount;
  var offset = vi * this.stride;
  var vbf = this.vbf;
  vbf[offset] = x;
  vbf[offset + 1] = y;
  vbf[offset + 2] = angle;
  vbf[offset + 3] = distanceAlong;
  vbf[offset + 4] = lineWidthHalf;
  this.vbi[offset + 5] = color;
  this.vbi[offset + 6] = dbId;
  this.vbi[offset + 7] = 0 | layer << 16;
  this.vcount++;
  return vi;
};
VertexBufferBuilder.prototype.addToBounds = function(x, y) {
  if (x < this.minx) {
    this.minx = x;
  }
  if (x > this.maxx) {
    this.maxx = x;
  }
  if (y < this.miny) {
    this.miny = y;
  }
  if (y > this.maxy) {
    this.maxy = y;
  }
};
VertexBufferBuilder.prototype.addVertexLine = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer, vertexId, geomType) {
  var vi = this.vcount;
  var offset = vi * this.stride;
  var vbf = this.vbf;
  if (geomType === undefined) {
    geomType = VBB_LINE_SEGMENT;
  }
  vbf[offset] = x;
  vbf[offset + 1] = y;
  vbf[offset + 2] = angle;
  vbf[offset + 3] = distanceAlong;
  vbf[offset + 4] = lineWidthHalf;
  this.vbi[offset + 5] = color;
  this.vbi[offset + 6] = dbId;
  this.vbi[offset + 7] = geomType | vertexId | layer << 16;
  this.vcount++;
  return vi;
};
VertexBufferBuilder.prototype.addVertexArc = function(x, y, startAngle, endAngle, major, minor, tilt, lineWidthHalf, color, dbId, layer, vertexId) {
  var vi = this.vcount;
  var offset = vi * this.stride;
  var vbf = this.vbf;
  var type = major == minor ? VBB_ARC_CIRCULAR : VBB_ARC_ELLIPTICAL;
  vbf[offset] = x;
  vbf[offset + 1] = y;
  vbf[offset + 2] = startAngle;
  vbf[offset + 3] = endAngle;
  vbf[offset + 4] = lineWidthHalf;
  this.vbi[offset + 5] = color;
  this.vbi[offset + 6] = dbId;
  this.vbi[offset + 7] = type | vertexId | layer << 16;
  vbf[offset + 8] = major;
  vbf[offset + 9] = minor;
  vbf[offset + 10] = tilt;
  vbf[offset + 11] = 0;
  this.vcount++;
  return vi;
};
VertexBufferBuilder.prototype.addVertexPolytriangle = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer) {
  this.addVertex(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer);
  this.addToBounds(x, y);
};
VertexBufferBuilder.prototype.setVertexColor = function(i, color) {
  var offset = i * this.stride;
  this.vbi[offset + 5] = color;
};
VertexBufferBuilder.prototype.addTriangle = function(i0, i1, i2) {
  var ib = this.ib;
  var ii = this.icount;
  if (ii + 3 >= ib.length) {
    var ibnew = new Uint16Array(ib.length * 2);
    for (var i = 0;i < ii;i++) {
      ibnew[i] = ib[i];
    }
    this.ib = ib = ibnew;
  }
  ib[ii] = i0;
  ib[ii + 1] = i1;
  ib[ii + 2] = i2;
  this.icount += 3;
};
VertexBufferBuilder.prototype.addSegment = function(x1, y1, x2, y2, lineWidth, color, dbId, layer) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  var theta = 0;
  if (dx || dy) {
    theta = Math.atan2(dy, dx);
  }
  var segLen = Math.sqrt(dx * dx + dy * dy);
  lineWidth *= 0.5;
  var v0 = this.addVertexLine(x1, y1, theta, segLen, lineWidth, color, dbId, layer, VBB_SEG_START_RIGHT);
  var v1 = this.addVertexLine(x1, y1, theta, segLen, lineWidth, color, dbId, layer, VBB_SEG_END_RIGHT);
  var v2 = this.addVertexLine(x1, y1, theta, segLen, lineWidth, color, dbId, layer, VBB_SEG_END_LEFT);
  var v3 = this.addVertexLine(x1, y1, theta, segLen, lineWidth, color, dbId, layer, VBB_SEG_START_LEFT);
  this.addTriangle(v0, v1, v2);
  this.addTriangle(v0, v2, v3);
  this.addToBounds(x1, y1);
  this.addToBounds(x2, y2);
};
VertexBufferBuilder.prototype.addCircularArc = function(cx, cy, start, end, radius, lineWidth, color, dbId, layer) {
  this.expandStride();
  var range = Math.abs(start - end);
  if (range > 1E-4 && Math.abs(range - TAU) > 1E-4) {
    var sx = cx + radius * Math.cos(start);
    var sy = cy + radius * Math.sin(start);
    this.addSegment(sx, sy, sx, sy, lineWidth, color, dbId, layer);
    var ex = cx + radius * Math.cos(end);
    var ey = cy + radius * Math.sin(end);
    this.addSegment(ex, ey, ex, ey, lineWidth, color, dbId, layer);
  } else {
    this.addToBounds(cx - radius, cy - radius);
    this.addToBounds(cx + radius, cy + radius);
  }
  lineWidth *= 0.5;
  var v0 = this.addVertexArc(cx, cy, start, end, radius, radius, 0, lineWidth, color, dbId, layer, VBB_SEG_START_RIGHT);
  var v1 = this.addVertexArc(cx, cy, start, end, radius, radius, 0, lineWidth, color, dbId, layer, VBB_SEG_END_RIGHT);
  var v2 = this.addVertexArc(cx, cy, start, end, radius, radius, 0, lineWidth, color, dbId, layer, VBB_SEG_END_LEFT);
  var v3 = this.addVertexArc(cx, cy, start, end, radius, radius, 0, lineWidth, color, dbId, layer, VBB_SEG_START_LEFT);
  this.addTriangle(v0, v1, v2);
  this.addTriangle(v0, v2, v3);
};
VertexBufferBuilder.prototype.addEllipticalArc = function(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer) {
  this.expandStride();
  var range = Math.abs(start - end);
  if (Math.abs(range - TAU) > 1E-4) {
    var sx = cx + major * Math.cos(start);
    var sy = cy + minor * Math.sin(start);
    this.addSegment(sx, sy, sx, sy, lineWidth, color, dbId, layer);
    var ex = cx + major * Math.cos(end);
    var ey = cy + minor * Math.sin(end);
    this.addSegment(ex, ey, ex, ey, lineWidth, color, dbId, layer);
  } else {
    this.addToBounds(cx - major, cy - minor);
    this.addToBounds(cx + major, cy + minor);
  }
  lineWidth *= 0.5;
  var v0 = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer, VBB_SEG_START_RIGHT);
  var v1 = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer, VBB_SEG_END_RIGHT);
  var v2 = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer, VBB_SEG_END_LEFT);
  var v3 = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer, VBB_SEG_START_LEFT);
  this.addTriangle(v0, v1, v2);
  this.addTriangle(v0, v2, v3);
  if (0) {
    var range = Math.abs(start - end);
    if (Math.abs(range - TAU) > 1E-4) {
      var sx = cx + major * Math.cos(start);
      var sy = cy + minor * Math.sin(start);
      this.addSegment(sx, sy, sx, sy, 2 * lineWidth, 4278255615, dbId, layer);
      var ex = cx + major * Math.cos(end);
      var ey = cy + minor * Math.sin(end);
      this.addSegment(ex, ey, ex, ey, 2 * lineWidth, 4278255615, dbId, layer);
    }
  }
};
VertexBufferBuilder.prototype.addTexturedQuad = function(x, y, w, h, dbId, layer) {
  var hh = h * 0.5;
  var v0 = this.addVertexLine(x, y + hh, 0, w, -hh, 4278255615, dbId, layer, VBB_SEG_START_RIGHT, VBB_TEX_QUAD);
  var v1 = this.addVertexLine(x, y + hh, 0, w, -hh, 4278255615, dbId, layer, VBB_SEG_END_RIGHT, VBB_TEX_QUAD);
  var v2 = this.addVertexLine(x, y + hh, 0, w, -hh, 4278255615, dbId, layer, VBB_SEG_END_LEFT, VBB_TEX_QUAD);
  var v3 = this.addVertexLine(x, y + hh, 0, w, -hh, 4278255615, dbId, layer, VBB_SEG_START_LEFT, VBB_TEX_QUAD);
  this.addTriangle(v0, v1, v2);
  this.addTriangle(v0, v2, v3);
  this.addToBounds(x, y);
  this.addToBounds(x + w, y + h);
};
VertexBufferBuilder.prototype.isFull = function(addCount) {
  if (!addCount) {
    addCount = 3;
  }
  return this.vcount + addCount >= 32767;
};
VertexBufferBuilder.prototype.toMesh = function() {
  var mesh = {};
  mesh.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
  mesh.vbstride = this.stride;
  mesh.indices = new Uint16Array(this.ib.buffer.slice(0, this.icount * 2));
  mesh.vblayout = {"position":{offset:0, itemSize:3, bytesPerItem:4}, "uv":{offset:3, itemSize:2, bytesPerItem:4}, "color4b":{offset:5, itemSize:4, bytesPerItem:1, normalize:true}, "dbId4b":{offset:6, itemSize:4, bytesPerItem:1, normalize:true}, "flags4b":{offset:7, itemSize:4, bytesPerItem:1, normalize:false}};
  if (this.stride > 8) {
    mesh.vblayout.extraParams = {offset:8, itemSize:4, bytesPerItem:4, normalize:false};
  }
  var bb = mesh.boundingBox = new THREE.Box3;
  var sz = Math.max(this.maxx - this.minx, this.maxy - this.miny);
  bb.min.set(this.minx, this.miny, -sz * 0.001);
  bb.max.set(this.maxx, this.maxy, sz * 0.001);
  VBUtils.computeBounds2D(mesh);
  return mesh;
};
function readOpenCTM_RAW(stream, mesh) {
  var readOpenCTMString = function() {
    return stream.getString(stream.getInt32());
  };
  var name = stream.getString(4);
  if (name != "INDX") {
    return null;
  }
  var vcount = mesh.vertexCount;
  var tcount = mesh.triangleCount;
  var meshindices = mesh.indices = new Uint16Array(tcount * 3);
  for (var i = 0, iEnd = tcount * 3;i < iEnd;i++) {
    meshindices[i] = stream.getInt32();
  }
  name = stream.getString(4);
  if (name != "VERT") {
    return null;
  }
  var stride = mesh.vbstride;
  var vbf = mesh.vb;
  for (var i = 0, offset = mesh.vblayout["position"].offset;i < vcount;i++, offset += stride) {
    vbf[offset] = stream.getFloat32();
    vbf[offset + 1] = stream.getFloat32();
    vbf[offset + 2] = stream.getFloat32();
  }
  if (mesh.flags & 1) {
    name = stream.getString(4);
    if (name != "NORM") {
      return null;
    }
    for (var i = 0, offset = mesh.vblayout["normal"].offset;i < vcount;i++, offset += stride) {
      vbf[offset] = stream.getFloat32();
      vbf[offset + 1] = stream.getFloat32();
      vbf[offset + 2] = stream.getFloat32();
    }
  }
  for (var t = 0;t < mesh.texMapCount;t++) {
    name = stream.getString(4);
    if (name != "TEXC") {
      return null;
    }
    var uv = {name:readOpenCTMString(), file:readOpenCTMString()};
    mesh.uvs.push(uv);
    var uvname = "uv";
    if (t) {
      uvname += (t + 1).toString();
    }
    for (var i = 0, offset = mesh.vblayout[uvname].offset;i < vcount;i++, offset += stride) {
      vbf[offset] = stream.getFloat32();
      vbf[offset + 1] = stream.getFloat32();
    }
  }
  for (var t = 0;t < mesh.attribMapCount;t++) {
    name = stream.getString(4);
    if (name != "ATTR") {
      return null;
    }
    var attr = {name:readOpenCTMString()};
    if (attr.name.indexOf("Color") != -1) {
      for (var i = 0, offset = mesh.vblayout["color"].offset;i < vcount;i++, offset += stride) {
        vbf[offset] = stream.getFloat32();
        vbf[offset + 1] = stream.getFloat32();
        vbf[offset + 2] = stream.getFloat32();
        stream.getFloat32();
      }
    } else {
      mesh.attrs.push(attr);
      stream.getBytes(vcount * 16);
    }
  }
}
var readOpenCTM = function(stream) {
  var readOpenCTMString = function() {
    return stream.getString(stream.getInt32());
  };
  var fourcc = stream.getString(4);
  if (fourcc != "OCTM") {
    return null;
  }
  var version = stream.getInt32();
  if (version != 5) {
    return null;
  }
  var method = stream.getString(3);
  stream.getUint8();
  var mesh = {stream:null, vertices:null, indices:null, normals:null, colors:null, uvs:[], attrs:[]};
  mesh.vertexCount = stream.getInt32();
  mesh.triangleCount = stream.getInt32();
  mesh.texMapCount = stream.getInt32();
  mesh.attribMapCount = stream.getInt32();
  mesh.flags = stream.getInt32();
  mesh.comment = readOpenCTMString();
  mesh.vbstride = 3;
  if (mesh.flags & 1) {
    mesh.vbstride += 3;
  }
  mesh.vbstride += 2 * (mesh.texMapCount || 0);
  if (mesh.attribMapCount > 0) {
    mesh.vbstride += 3;
  }
  mesh.vblayout = {};
  var offset = 0;
  mesh.vblayout["position"] = {offset:offset, itemSize:3};
  offset += 3;
  if (mesh.flags & 1) {
    mesh.vblayout["normal"] = {offset:offset, itemSize:3};
    offset += 3;
  }
  if (mesh.texMapCount) {
    for (var i = 0;i < mesh.texMapCount;i++) {
      var uvname = "uv";
      if (i) {
        uvname += (i + 1).toString();
      }
      mesh.vblayout[uvname] = {offset:offset, itemSize:2};
      offset += 2;
    }
  }
  if (mesh.attribMapCount) {
    mesh.vblayout["color"] = {offset:offset, itemSize:3};
  }
  mesh.vb = new Float32Array(mesh.vertexCount * mesh.vbstride);
  if (method == "RAW") {
    readOpenCTM_RAW(stream, mesh);
    VBUtils.deduceUVRepetition(mesh);
    VBUtils.computeBounds3D(mesh);
    return mesh;
  } else {
    if (method == "MG2") {
      readOpenCTM_MG2(stream, mesh);
      VBUtils.deduceUVRepetition(mesh);
      VBUtils.computeBounds3D(mesh);
      return mesh;
    } else {
      return null;
    }
  }
};
var readLines = function(pfr, tse) {
  var mesh = {isLines:true, vertices:null, indices:null, colors:null, normals:null, uvs:[], attrs:[]};
  var indexCount;
  var polyLineBoundCount;
  if (tse.version > 1) {
    mesh.vertexCount = pfr.readU16();
    indexCount = pfr.readU16();
    polyLineBoundCount = pfr.readU16();
  } else {
    mesh.vertexCount = pfr.readU32V();
    indexCount = pfr.readU32V();
    polyLineBoundCount = pfr.readU32V();
  }
  var hasColor = pfr.stream.getUint8() != 0;
  mesh.vbstride = 3;
  if (hasColor) {
    mesh.vbstride += 3;
  }
  mesh.vblayout = {};
  var offset = 0;
  mesh.vblayout["position"] = {offset:offset, itemSize:3};
  offset += 3;
  if (hasColor) {
    mesh.vblayout["color"] = {offset:offset, itemSize:3};
  }
  mesh.vb = new Float32Array(mesh.vertexCount * mesh.vbstride);
  var vbf = mesh.vb;
  var stride = mesh.vbstride;
  var stream = pfr.stream;
  for (var i = 0, offset = mesh.vblayout["position"].offset, iEnd = mesh.vertexCount;i < iEnd;i++, offset += stride) {
    vbf[offset] = stream.getFloat32();
    vbf[offset + 1] = stream.getFloat32();
    vbf[offset + 2] = stream.getFloat32();
  }
  if (hasColor) {
    for (var c = 0, offset = mesh.vblayout["color"].offset, cEnd = mesh.vertexCount;c < cEnd;c++, offset += stride) {
      vbf[offset] = stream.getFloat32();
      vbf[offset + 1] = stream.getFloat32();
      vbf[offset + 2] = stream.getFloat32();
      stream.getFloat32();
    }
  }
  var forceCopy = function(b) {
    return b.buffer.slice(b.byteOffset, b.byteOffset + b.length);
  };
  var indices;
  var polyLineBoundBuffer;
  if (tse.version > 1) {
    indices = new Uint16Array(forceCopy(stream.getBytes(indexCount * 2)));
    polyLineBoundBuffer = new Uint16Array(forceCopy(stream.getBytes(polyLineBoundCount * 2)));
  } else {
    indices = new Int32Array(forceCopy(stream.getBytes(indexCount * 4)));
    polyLineBoundBuffer = new Int32Array(forceCopy(stream.getBytes(polyLineBoundCount * 4)));
  }
  var indexPairs = polyLineBoundBuffer[polyLineBoundCount - 1] - polyLineBoundCount + 1;
  mesh.indices = new Uint16Array(2 * indexPairs);
  var meshIndex = 0;
  for (var i = 0;i + 1 < polyLineBoundCount;i++) {
    for (var j = polyLineBoundBuffer[i];j + 1 < polyLineBoundBuffer[i + 1];j++) {
      mesh.indices[meshIndex++] = indices[j];
      mesh.indices[meshIndex++] = indices[j + 1];
    }
  }
  VBUtils.computeBounds3D(mesh);
  return mesh;
};
function readGeometry(pfr, entry, format) {
  var tse = pfr.seekToEntry(entry);
  if (!tse) {
    return null;
  }
  if (tse.entryType == "Autodesk.CloudPlatform.OpenCTM") {
    return readOpenCTM(pfr.stream);
  } else {
    if (tse.entryType == "Autodesk.CloudPlatform.Lines") {
      return readLines(pfr, tse);
    }
  }
  return null;
}
;function convertMaterials(svf) {
  var parseMaterialColor = function(props, name) {
    var ret = new THREE.Color;
    if (!props || !props["colors"]) {
      return ret.setRGB(1, 0, 0);
    }
    var cobj = props["colors"][name];
    if (!cobj) {
      return ret.setRGB(0, 0, 0);
    }
    var vals = cobj["values"];
    if (!vals || !vals.length) {
      return ret.setRGB(1, 0, 0);
    }
    var rgb = vals[0];
    return ret.setRGB(rgb["r"], rgb["g"], rgb["b"]);
  };
  var parseMaterialScalar = function(props, name) {
    if (!props || !props["scalars"]) {
      return 0;
    }
    var vobj = props["scalars"][name];
    if (!vobj) {
      return undefined;
    }
    return vobj["values"][0];
  };
  var parseMaterialBoolean = function(props, name) {
    if (!props || !props["booleans"]) {
      return 0;
    }
    var vobj = props["booleans"];
    if (!vobj) {
      return undefined;
    }
    return vobj[name];
  };
  var prmats = svf.materials["materials"];
  svf.simplemats = {};
  for (var p in prmats) {
    var matObj = prmats[p];
    var userAssets = matObj["userassets"];
    var innerMats = matObj["materials"];
    var innerMat = innerMats[userAssets[0]];
    if (innerMat && innerMat["definition"] == "SimplePhong") {
      var props = innerMat["properties"];
      var tm = {};
      tm.ambient = parseMaterialColor(props, "generic_ambient");
      tm.color = parseMaterialColor(props, "generic_diffuse");
      tm.specular = parseMaterialColor(props, "generic_specular");
      tm.emissive = parseMaterialColor(props, "generic_emissive");
      var shiny = parseMaterialScalar(props, "generic_glossiness");
      if (!shiny) {
        shiny = 30;
      }
      tm.shininess = shiny;
      var transparency = parseMaterialScalar(props, "generic_transparency");
      if (!transparency) {
        transparency = 0;
      }
      tm.opacity = 1 - transparency;
      var reflectivity = parseMaterialScalar(props, "generic_reflectivity_at_0deg");
      if (!reflectivity) {
        reflectivity = 0;
      }
      tm.reflectivity = reflectivity;
      var isMetal = parseMaterialBoolean(props, "generic_is_metal");
      if (isMetal !== undefined) {
        tm.metal = isMetal;
      }
      var backfaceCulling = parseMaterialBoolean(props, "generic_backface_cull");
      if (backfaceCulling !== undefined) {
        tm.doubleSided = !backfaceCulling;
      }
      tm.transparent = innerMat["transparent"];
      var textures = innerMat["textures"];
      for (var texType in textures) {
        var texDef = textures[texType];
        var connection = texDef["connections"][0];
        var innerTex = innerMats[connection];
        var texProps = innerTex["properties"];
        var uri = texProps["uris"]["unifiedbitmap_Bitmap"]["values"][0];
        var texField = null;
        if (uri) {
          if (texType == "generic_diffuse") {
            texField = "map";
            if (!tm.color || tm.color.r == 0 && (tm.color.g == 0 && tm.color.b == 0)) {
              tm.color = new THREE.Color(1, 1, 1);
            }
          } else {
            if (texType == "generic_bump") {
              var isNormal = parseMaterialBoolean(props, "generic_bump_is_normal");
              if (isNormal) {
                texField = "normalMap";
              } else {
                texField = "bumpMap";
              }
              tm.bumpScale = parseMaterialScalar(props, "generic_bump_amount");
            } else {
              if (texType == "generic_specular") {
                texField = "specularMap";
              } else {
                if (texType == "generic_reflection") {
                } else {
                  if (texType == "generic_alpha") {
                    texField = "opacityMap";
                  }
                }
              }
            }
          }
        }
        if (texField) {
          tm["uri_" + texField] = uri;
          var tmp = parseMaterialScalar(texProps, "texture_UScale");
          if (tmp) {
            tm["uscale_" + texField] = tmp;
          }
          tmp = parseMaterialScalar(texProps, "texture_VScale");
          if (tmp) {
            tm["vscale_" + texField] = tmp;
          }
        }
      }
      svf.simplemats[p] = tm;
    } else {
    }
  }
}
;function readLightDefinition(pfr, entry) {
  var tse = pfr.seekToEntry(entry);
  if (!tse) {
    return null;
  }
  if (tse.version > 1) {
    return null;
  }
  var s = pfr.stream;
  var light = {position:pfr.readVector3f(), dir:pfr.readVector3f(), r:s.getFloat32(), g:s.getFloat32(), b:s.getFloat32(), intensity:s.getFloat32(), spotAngle:s.getFloat32(), size:s.getFloat32(), type:s.getUint8()};
  return light;
}
;function readCameraDefinition(pfr, inst) {
  var entry = inst.definition;
  var tse = pfr.seekToEntry(entry);
  if (!tse) {
    return null;
  }
  if (tse.version > 2) {
    return null;
  }
  var s = pfr.stream;
  var cam = {isPerspective:!s.getUint8(), position:pfr.readVector3f(), target:pfr.readVector3f(), up:pfr.readVector3f(), aspect:s.getFloat32(), fov:THREE.Math.radToDeg(s.getFloat32())};
  if (tse.version < 2) {
    s.getFloat32();
    s.getFloat32();
  }
  cam.orthoScale = s.getFloat32();
  cam.inst = inst;
  return cam;
}
;function FragList() {
  this.length = 0;
  this.numLoaded = 0;
  this.boxes = null;
  this.transforms = null;
  this.materials = null;
  this.packIds = null;
  this.entityIndexes = null;
  this.fragId2dbId = null;
  this.mesh2frag = null;
}
function readGeometryMetadata(pfr, geoms) {
  var numGeoms = pfr.getEntryCounts();
  var stream = pfr.stream;
  geoms.length = numGeoms;
  var fragTypes = geoms.fragTypes = new Uint8Array(numGeoms);
  var primCounts = geoms.primCounts = new Uint16Array(numGeoms);
  var packIds = geoms.packIds = new Int32Array(numGeoms);
  var entityIndexes = geoms.entityIndexes = new Int32Array(numGeoms);
  for (var g = 0, gEnd = numGeoms;g < gEnd;g++) {
    var tse = pfr.seekToEntry(g);
    if (!tse) {
      return;
    }
    fragTypes[g] = stream.getUint8();
    stream.seek(stream.offset + 24);
    primCounts[g] = stream.getUint16();
    packIds[g] = parseInt(pfr.readString());
    entityIndexes[g] = pfr.readU32V();
  }
}
function readFragments(pfr, frags) {
  var numFrags = pfr.getEntryCounts();
  var stream = pfr.stream;
  frags.length = numFrags;
  frags.numLoaded = 0;
  var fragBoxes = frags.boxes = new Float32Array(6 * numFrags);
  var transforms = frags.transforms = new Float32Array(16 * numFrags);
  var materials = frags.materials = new Int32Array(numFrags);
  var packIds = frags.packIds = new Int32Array(numFrags);
  var entityIndexes = frags.entityIndexes = new Int32Array(numFrags);
  var geomDataIndexes = frags.geomDataIndexes = new Int32Array(numFrags);
  var fragId2dbId = frags.fragId2dbId = new Int32Array(numFrags);
  function readBoundingBox(entry) {
    var offset = entry * 6;
    for (var i = 0;i < 6;i++) {
      fragBoxes[offset++] = stream.getFloat32();
    }
  }
  function readBoundingBoxOffset(entry, transforms, index) {
    var offset = entry * 6;
    for (var i = 0;i < 6;i++) {
      fragBoxes[offset++] = stream.getFloat32() + transforms[index + i % 3];
    }
  }
  for (var entry = 0, eEnd = frags.length;entry < eEnd;entry++) {
    var tse = pfr.seekToEntry(entry);
    if (!tse) {
      return;
    }
    if (tse.version > 5) {
      return;
    }
    var isVisible = true;
    if (tse.version > 4) {
      var flags = pfr.readU8();
      isVisible = (flags & 1) != 0;
    }
    materials[entry] = pfr.readU32V();
    if (tse.version > 2) {
      geomDataIndexes[entry] = pfr.readU32V();
    } else {
      packIds[entry] = parseInt(pfr.readString());
      entityIndexes[entry] = pfr.readU32V();
    }
    pfr.readTransform(entry, transforms, 16 * entry);
    if (tse.version > 3) {
      readBoundingBoxOffset(entry, transforms, 16 * entry + 12);
    } else {
      readBoundingBox(entry);
    }
    if (tse.version > 1) {
      fragId2dbId[entry] = pfr.readU32V();
    }
  }
}
function filterFragments(frags, ids) {
  frags.length = ids.length;
  frags.numLoaded = 0;
  var numFrags = frags.length;
  var bb = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
  var fragBoxes = new Float32Array(6 * numFrags);
  var transforms = new Float32Array(16 * numFrags);
  var materials = new Int32Array(numFrags);
  var packIds = new Int32Array(numFrags);
  var entityIndexes = new Int32Array(numFrags);
  var mesh2frag = {};
  for (var i = 0;i < ids.length;++i) {
    var index = ids[i];
    var idxOld = index * 6;
    var idxNew = i * 6;
    for (var j = 0;j < 6;++j) {
      fragBoxes[idxNew++] = frags.boxes[idxOld++];
    }
    idxOld = index * 16;
    idxNew = i * 16;
    for (var j = 0;j < 16;++j) {
      transforms[idxNew++] = frags.transforms[idxOld++];
    }
    materials[i] = frags.materials[index];
    packIds[i] = frags.packIds[index];
    entityIndexes[i] = frags.entityIndexes[index];
    var meshID = frags.packIds[index] + ":" + frags.entityIndexes[index];
    var meshRefs = mesh2frag[meshID];
    if (meshRefs == undefined) {
      mesh2frag[meshID] = i;
    } else {
      if (!Array.isArray(meshRefs)) {
        mesh2frag[meshID] = [meshRefs, i];
      } else {
        meshRefs.push(i);
      }
    }
    var bbIndex = i * 6;
    for (var j = 0;j < 3;++j) {
      if (fragBoxes[bbIndex + j] < bb[j]) {
        bb[j] = fragBoxes[bbIndex + j];
      }
    }
    for (var j = 3;j < 6;++j) {
      if (fragBoxes[bbIndex + j] > bb[j]) {
        bb[j] = fragBoxes[bbIndex + j];
      }
    }
  }
  frags.boxes = fragBoxes;
  frags.transforms = transforms;
  frags.materials = materials;
  frags.packIds = packIds;
  frags.entityIndexes = entityIndexes;
  frags.mesh2frag = mesh2frag;
  return bb;
}
;function readInstance(pfr, entry) {
  var tse = pfr.seekToEntry(entry);
  if (!tse) {
    return null;
  }
  if (tse.version > 2) {
    return null;
  }
  var isVisible = true;
  if (tse.version > 1) {
    var flags = pfr.readU8();
    isVisible = (flags & 1) != 0;
  }
  return{definition:pfr.stream.getUint32(), transform:pfr.readTransform(), instanceNodePath:pfr.readPathID()};
}
;function Package() {
  this.manifest = null;
  this.materials = null;
  this.simplemats = null;
  this.metadata = null;
  this.fragments = null;
  this.geompacks = [];
  this.instances = [];
  this.cameras = [];
  this.lights = [];
  this.propertydb = {attrs:[], avs:[], ids:[], values:[], offsets:[]};
  this.bbox = null;
  this.pendingRequests = 0;
}
Package.prototype.loadAsyncResource = function(loadContext, resourcePath, contents, callback) {
  if (contents) {
    callback(contents);
    return;
  }
  var svf = this;
  this.pendingRequests++;
  function xhrCB(e) {
    svf.pendingRequests--;
    if (this.response) {
      var data = new Uint8Array(this.response);
      if (data[0] == 31 && data[1] == 139) {
        var gunzip = new Zlib.Gunzip(data);
        data = gunzip.decompress();
      }
      callback(data);
    }
    if (svf.pendingRequests == 0) {
      svf.postLoad(loadContext);
    }
  }
  var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
  xhr.get(loadContext.basePath + resourcePath, loadContext.headers, "arraybuffer", xhrCB, "", loadContext.queryParams);
};
Package.prototype.load = function(loadContext, zipPack) {
  var svf = this;
  var unzip = new Zlib.Unzip(zipPack);
  var manifestJson = unzip.decompress("manifest.json");
  if (!manifestJson) {
    return false;
  }
  var jdr = new InputStream(manifestJson);
  var manifest = JSON.parse(jdr.getString(manifestJson.byteLength));
  var metadataJson = unzip.decompress("metadata.json");
  var jdr = new InputStream(metadataJson);
  if (metadataJson.byteLength > 3 && metadataJson[3] !== 0) {
    this.metadata = JSON.parse(jdr.getString(metadataJson.byteLength)).metadata;
    if (this.metadata) {
      var bbox = this.metadata["world bounding box"];
      var min = {x:bbox.minXYZ[0], y:bbox.minXYZ[1], z:bbox.minXYZ[2]};
      var max = {x:bbox.maxXYZ[0], y:bbox.maxXYZ[1], z:bbox.maxXYZ[2]};
      this.bbox = new THREE.Box3(min, max);
    }
  }
  var manifestVersion = manifest["manifestversion"];
  this.manifest = manifest;
  var typesetsList = manifest["typesets"];
  var typesets = {};
  for (var i = 0;i < typesetsList.length;i++) {
    var ts = typesetsList[i];
    typesets[ts["id"]] = ts["types"];
  }
  var assets = manifest["assets"];
  for (var i = 0;i < assets.length;i++) {
    var asset = assets[i];
    var type = asset["type"];
    if (type.indexOf("Autodesk.CloudPlatform.") == 0) {
      type = type.substr(23);
    }
    var uri = asset["URI"];
    var typeset = asset["typeset"] ? typesets[asset["typeset"]] : null;
    if (uri.indexOf("embed:/") != 0) {
      if (type == "PackFile") {
        var typeclass = typeset ? typeset[0]["class"] : null;
        if (typeclass == "Autodesk.CloudPlatform.Geometry") {
          this.geompacks.push({id:asset["id"], uri:uri});
        }
      } else {
        if (type == "PropertyAttributes") {
          this.propertydb.attrs.push(uri);
        } else {
          if (type == "PropertyAVs") {
            this.propertydb.avs.push(uri);
          } else {
            if (type == "PropertyIDs") {
              this.propertydb.ids.push(uri);
            } else {
              if (type == "PropertyOffsets") {
                this.propertydb.offsets.push(uri);
              } else {
                if (type == "PropertyValues") {
                  this.propertydb.values.push(uri);
                }
              }
            }
          }
        }
      }
    }
    var path = asset["URI"];
    var contents;
    if (path.indexOf("embed:/") == 0) {
      path = path.substr(7);
      contents = unzip.decompress(path);
    }
    if (type == "ProteinMaterials") {
      if (path.indexOf("Protein") == -1) {
        this.loadAsyncResource(loadContext, path, contents, function(data) {
          var jdr = new InputStream(data);
          var byteLength = data.byteLength;
          if (0 < byteLength) {
            svf.materials = JSON.parse(jdr.getString(byteLength));
            convertMaterials(svf);
          } else {
            svf.materials = null;
          }
        });
      } else {
        this.loadAsyncResource(loadContext, path, contents, function(data) {
          var jdr = new InputStream(data);
          var byteLength = data.byteLength;
          if (0 < byteLength) {
            svf.proteinMaterials = JSON.parse(jdr.getString(byteLength));
          } else {
            svf.proteinMaterials = null;
          }
        });
      }
    } else {
      if (type == "FragmentList") {
        this.loadAsyncResource(loadContext, path, contents, function(data) {
          var pfr = new PackFileReader(data);
          var frags = svf.fragments = new FragList;
          readFragments(pfr, frags);
        });
      } else {
        if (type == "GeometryMetadataList") {
          this.loadAsyncResource(loadContext, path, contents, function(data) {
            var pfr = new PackFileReader(data);
            svf.geomMetadata = {};
            readGeometryMetadata(pfr, svf.geomMetadata);
          });
        } else {
          if (type == "PackFile") {
            if (path.indexOf("CameraDefinitions.bin") != -1) {
              this.loadAsyncResource(loadContext, path, contents, function(data) {
                svf.camDefPack = new PackFileReader(data);
              });
            } else {
              if (path.indexOf("CameraList.bin") != -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                  svf.camInstPack = new PackFileReader(data);
                });
              } else {
                if (path.indexOf("LightDefinitions.bin") != -1) {
                  this.loadAsyncResource(loadContext, path, contents, function(data) {
                    svf.lightDefPack = new PackFileReader(data);
                  });
                } else {
                  if (path.indexOf("LightList.bin") != -1) {
                    this.loadAsyncResource(loadContext, path, contents, function(data) {
                      svf.lightInstPack = new PackFileReader(data);
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (this.pendingRequests == 0) {
    this.postLoad(loadContext);
  }
};
Package.prototype.postLoad = function(loadContext) {
  if (this.camDefPack && this.camInstPack) {
    for (var k = 0, kEnd = this.camInstPack.getEntryCounts();k < kEnd;k++) {
      var inst = readInstance(this.camInstPack, k);
      this.cameras.push(readCameraDefinition(this.camDefPack, inst));
    }
    delete this.camDefPack;
    delete this.camInstPack;
  }
  if (this.lightDefPack && this.lightInstPack) {
    for (var k = 0, kEnd = this.lightInstPack.getEntryCounts();k < kEnd;k++) {
      var inst = readInstance(this.lightInstPack, k);
      this.lights.push(readLightDefinition(this.lightDefPack, inst.definition));
    }
    delete this.lightInstPack;
    delete this.lightDefPack;
  }
  var frags = this.fragments;
  if (this.geomMetadata) {
    var gm = this.geomMetadata;
    for (var i = 0, iEnd = frags.length;i < iEnd;i++) {
      var geomIndex = frags.geomDataIndexes[i];
      frags.entityIndexes[i] = gm.entityIndexes[geomIndex];
      frags.packIds[i] = gm.packIds[geomIndex];
    }
    delete this.geomMetadata;
  }
  var mesh2frag = frags.mesh2frag = {};
  var packIds = frags.packIds;
  var entityIndexes = frags.entityIndexes;
  for (var i = 0, iEnd = frags.length;i < iEnd;i++) {
    var meshid = packIds[i] + ":" + entityIndexes[i];
    var meshRefs = mesh2frag[meshid];
    if (meshRefs === undefined) {
      mesh2frag[meshid] = i;
    } else {
      if (!Array.isArray(meshRefs)) {
        mesh2frag[meshid] = [meshRefs, i];
      } else {
        meshRefs.push(i);
      }
    }
  }
  if (!this.bbox) {
    var totalbox = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
    var fragBoxes = frags.boxes;
    for (var f = 0, fEnd = frags.length;f < fEnd;f++) {
      var bboff = f * 6;
      var i;
      for (i = 0;i < 3;i++) {
        if (fragBoxes[bboff + i] < totalbox[i]) {
          totalbox[i] = fragBoxes[bboff + i];
        }
      }
      for (i = 3;i < 6;i++) {
        if (fragBoxes[bboff + i] > totalbox[i]) {
          totalbox[i] = fragBoxes[bboff + i];
        }
      }
    }
    this.bbox = new THREE.Box3(new THREE.Vector3(totalbox[0], totalbox[1], totalbox[2]), new THREE.Vector3(totalbox[3], totalbox[4], totalbox[5]));
  }
  var ids = loadContext.objectIds;
  if (ids != null) {
    var packIds = [];
    var fragIndexes = [];
    for (var i = 0;i < ids.length;++i) {
      for (var j = 0;j < this.fragments.length;++j) {
        if (this.fragments.fragId2dbId[j] == ids[i]) {
          packIds.push(this.fragments.packIds[j]);
          fragIndexes.push(j);
        }
      }
    }
    var end = 1, n = packIds.length;
    for (var i = 1;i < n;) {
      while (i < n && packIds[i] == packIds[i - 1]) {
        ++i;
      }
      if (n == i) {
        break;
      }
      packIds[end++] = packIds[i++];
    }
    packIds.splice(end - 1, n - end);
    var packs = [];
    for (var i = 0;i < this.geompacks.length;++i) {
      for (var j = 0;j < packIds.length;++j) {
        if (parseInt(this.geompacks[i].id) == packIds[j]) {
          packs.push(this.geompacks[i]);
        }
      }
    }
    this.geompacks = packs;
    var bb = filterFragments(this.fragments, fragIndexes);
    this.bbox = new THREE.Box3(new THREE.Vector3(bb[0], bb[1], bb[2]), new THREE.Vector3(bb[3], bb[4], bb[5]));
  }
  loadContext.loadDoneCB(true);
};
function PackFileReader(data) {
  if (data[0] == 31 && data[1] == 139) {
    var gunzip = new Zlib.Gunzip(data);
    data = gunzip.decompress();
  }
  this.tempQuat = new THREE.Quaternion;
  this.tempTrans = new THREE.Vector3;
  this.tempScale = new THREE.Vector3;
  this.tempMat = new THREE.Matrix4;
  var stream = this.stream = new InputStream(data);
  var len = stream.getInt32();
  this.type = stream.getString(len);
  this.version = stream.getInt32();
  this.types = null;
  this.entryOffsets = [];
  stream.seek(stream.byteLength - 8);
  var tocOffset = stream.getUint32();
  this.typesOffset = stream.getUint32();
  stream.seek(this.typesOffset);
  var typesCount = this.readU32V();
  this.types = [];
  for (var i = 0;i < typesCount;++i) {
    this.types.push({"entryClass":this.readString(), "entryType":this.readString(), "version":this.readU32V()});
  }
  stream.seek(tocOffset);
  var entryCount = this.readU32V();
  var dso = this.entryOffsets;
  for (var i = 0;i < entryCount;++i) {
    dso.push(stream.getUint32());
  }
  stream.seek(0);
}
PackFileReader.prototype.readVarint = function() {
  var b;
  var value = 0;
  var shiftBy = 0;
  do {
    b = this.stream.getUint8();
    value |= (b & 127) << shiftBy;
    shiftBy += 7;
  } while (b & 128);
  return value;
};
PackFileReader.prototype.readU32V = PackFileReader.prototype.readVarint;
PackFileReader.prototype.readU16 = function() {
  return this.stream.getUint16();
};
PackFileReader.prototype.readU8 = function() {
  return this.stream.getUint8();
};
PackFileReader.prototype.readString = function() {
  return this.stream.getString(this.readU32V());
};
PackFileReader.prototype.readVector3f = function() {
  var s = this.stream;
  return new THREE.Vector3(s.getFloat32(), s.getFloat32(), s.getFloat32());
};
PackFileReader.prototype.readTransform = function(entityIndex, buffer, offset) {
  var stream = this.stream;
  var t = this.tempTrans;
  var q = this.tempQuat;
  var s = this.tempScale;
  var m = this.tempMat;
  function readQuaternionf(q) {
    q.set(stream.getFloat32(), stream.getFloat32(), stream.getFloat32(), stream.getFloat32());
  }
  function readVector3d(v) {
    v.set(stream.getFloat64(), stream.getFloat64(), stream.getFloat64());
  }
  function readMatrix3f() {
    m.identity();
    for (var i = 0;i < 3;++i) {
      for (var j = 0;j < 3;++j) {
        m.elements[4 * i + j] = stream.getFloat32();
      }
    }
  }
  var transformType = stream.getUint8();
  var xform = null;
  switch(transformType) {
    case 4:
      m.identity();
      break;
    case 0:
      readVector3d(t);
      m.makeTranslation(t.x, t.y, t.z);
      break;
    case 1:
      readQuaternionf(q);
      readVector3d(t);
      m.compose(t, q, s.set(1, 1, 1));
      break;
    case 2:
      var scale = stream.getFloat32();
      readQuaternionf(q);
      readVector3d(t);
      m.compose(t, q, s.set(scale, scale, scale));
      break;
    case 3:
      readMatrix3f();
      readVector3d(t);
      m.setPosition(t);
      break;
    default:
      break;
  }
  if (entityIndex !== undefined) {
    var src = m.elements;
    for (var i = 0;i < 16;i++) {
      buffer[offset++] = src[i];
    }
  } else {
    return(new THREE.Matrix4).copy(m);
  }
};
PackFileReader.prototype.getEntryCounts = function() {
  return this.entryOffsets.length;
};
PackFileReader.prototype.seekToEntry = function(entryIndex) {
  var count = this.getEntryCounts();
  if (entryIndex >= count) {
    return null;
  }
  this.stream.seek(this.entryOffsets[entryIndex]);
  var typeIndex = this.stream.getUint32();
  if (typeIndex >= this.types.length) {
    return null;
  }
  return this.types[typeIndex];
};
PackFileReader.prototype.readPathID = function() {
  var s = this.stream;
  if (this.version < 2) {
    var pathLength = s.getUint16();
    if (!pathLength) {
      return null;
    }
    s.getUint16();
    if (pathLength == 1) {
      return "";
    }
    var path = s.getUint16();
    for (var i = 2;i < pathLength;++i) {
      path += "/" + s.getUint16();
    }
  } else {
    var pathLength = this.readU32V();
    if (!pathLength) {
      return null;
    }
    this.readU32V();
    if (pathLength == 1) {
      return "";
    }
    var path = this.readU32V();
    for (var i = 2;i < pathLength;++i) {
      path += "/" + this.readU32V();
    }
  }
  return path;
};
function PropertyDatabase(dbjsons) {
  var _attrs;
  var _offsets;
  var _avs;
  var _valuesBlob;
  var _valuesOffsets;
  var _idsBlob;
  var _idsOffsets;
  var _childAttrId;
  var _parentAttrId;
  var _nameAttrId;
  var _instanceOfAttrId;
  var _viewableInAttrId;
  function blobToJson(blob) {
    var encodedString = "";
    for (var i = 0;i < blob.length;i++) {
      encodedString += String.fromCharCode(blob[i]);
    }
    var decodedString = decodeURIComponent(escape(encodedString));
    return JSON.parse(decodedString);
  }
  function subBlobToJson(blob, startIndex) {
    var i = startIndex;
    var encodedString = "";
    while (i < blob.length - 1) {
      var c = blob[i];
      if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) {
        break;
      }
      if (c == 10 || c == 13) {
        break;
      }
      encodedString += String.fromCharCode(c);
      i++;
    }
    var decodedString = decodeURIComponent(escape(encodedString));
    return JSON.parse(decodedString);
  }
  function subBlobToJsonInt(blob, startIndex) {
    var val = 0;
    var i = startIndex;
    if (blob[i] == 34) {
      i++;
    }
    while (i < blob.length - 1) {
      var c = blob[i];
      if (c == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) {
        break;
      }
      if (c == 10 || (c == 13 || c == 34)) {
        break;
      }
      if (c >= 48 && c <= 57) {
        val += val * 10 + (c - 48);
      }
      i++;
    }
    return val;
  }
  function parseIntArray(blob, wantSentinel) {
    var count = 0;
    for (var i = 0, iEnd = blob.length;i < iEnd;i++) {
      if (blob[i] == 44) {
        count++;
      }
    }
    count++;
    var items = new Uint32Array(count + (wantSentinel ? 1 : 0));
    i = 0;
    var end = blob.length;
    while (blob[i] != 91 && i < end) {
      i++;
    }
    if (i == blob.length) {
      return null;
    }
    i++;
    var seenDigit = false;
    count = 0;
    var curInt = 0;
    while (i < end) {
      var c = blob[i];
      if (c >= 48 && c <= 57) {
        curInt = 10 * curInt + (c - 48);
        seenDigit = true;
      } else {
        if (c == 44 || c == 93) {
          if (seenDigit) {
            items[count++] = curInt;
            seenDigit = false;
            curInt = 0;
          }
        } else {
          seenDigit = false;
          curInt = 0;
        }
      }
      i++;
    }
    return items;
  }
  function findValueOffsets(blob) {
    var count = 0;
    var end = blob.length - 1;
    for (var i = 0;i < end;i++) {
      if (blob[i] == 44 && (blob[i + 1] == 10 || blob[i + 1] == 13)) {
        count++;
      }
    }
    if (!count) {
      return null;
    }
    count++;
    var items = new Uint32Array(count);
    i = 0;
    count = 0;
    while (blob[i] != 91 && i < end) {
      i++;
    }
    i++;
    items[count++] = i;
    var seenEol = false;
    while (i < end) {
      if (blob[i] == 10 || blob[i] == 13) {
        seenEol = true;
      } else {
        if (seenEol) {
          seenEol = false;
          items[count++] = i;
        }
      }
      i++;
    }
    return items;
  }
  for (var p in dbjsons.attrs) {
    _attrs = blobToJson(dbjsons.attrs[p]);
    for (var i = 0;i < _attrs.length;i++) {
      var category = _attrs[i][1];
      if (category == "__parent__") {
        _parentAttrId = i;
      } else {
        if (category == "__child__") {
          _childAttrId = i;
        } else {
          if (category == "__name__") {
            _nameAttrId = i;
          } else {
            if (category == "__instanceof__") {
              _instanceOfAttrId = i;
            } else {
              if (category == "__viewable_in__") {
                _viewableInAttrId = i;
              }
            }
          }
        }
      }
    }
    break;
  }
  for (var p in dbjsons.avs) {
    _avs = parseIntArray(dbjsons.avs[p], 0);
    delete dbjsons.avs;
    break;
  }
  for (var p in dbjsons.offsets) {
    _offsets = parseIntArray(dbjsons.offsets[p], 1);
    _offsets[_offsets.length - 1] = _avs.length / 2;
    delete dbjsons.offsets;
    break;
  }
  for (var p in dbjsons.values) {
    _valuesBlob = dbjsons.values[p];
    _valuesOffsets = findValueOffsets(_valuesBlob);
    break;
  }
  for (var p in dbjsons.ids) {
    _idsBlob = dbjsons.ids[p];
    _idsOffsets = findValueOffsets(_idsBlob);
    break;
  }
  this.getObjectCount = function() {
    return _offsets.length - 1;
  };
  this.getValueAt = function(valId) {
    return subBlobToJson(_valuesBlob, _valuesOffsets[valId]);
  };
  this.getIntValueAt = function(valId) {
    return subBlobToJsonInt(_valuesBlob, _valuesOffsets[valId]);
  };
  this.getIdAt = function(entId) {
    return subBlobToJson(_idsBlob, _idsOffsets[entId]);
  };
  this.getObjectProperties = function(dbId) {
    var result = {"dbId":dbId, "name":"", "properties":[]};
    var parentProps = null;
    var propStart = 2 * _offsets[dbId];
    var propEnd = 2 * _offsets[dbId + 1];
    for (var i = propStart;i < propEnd;i += 2) {
      var attrId = _avs[i];
      if (attrId == _nameAttrId) {
        var val = this.getValueAt(_avs[i + 1]);
        result.name = val;
      } else {
        if (attrId == _instanceOfAttrId) {
          var res = this.getObjectProperties(this.getValueAt(_avs[i + 1]));
          if (res && res.properties) {
            parentProps = res;
          }
        } else {
          if (attrId == _parentAttrId || (attrId == _childAttrId || attrId == _viewableInAttrId)) {
          } else {
            var attr = _attrs[attrId];
            var flags = attr[6] ? attr[6] : 0;
            if (!(flags & 1)) {
              var displayName = attr[5] ? attr[5] : attr[0];
              var val = this.getValueAt(_avs[i + 1]);
              result.properties.push({"displayName":displayName, "displayValue":this.formatValueWithUnits(val, attr[3], attr[2])});
            }
          }
        }
      }
    }
    if (parentProps) {
      var myProps = {};
      var rp = result.properties;
      for (var i = 0;i < rp.length;i++) {
        myProps[rp[i].displayName] = 1;
      }
      if (!result.name) {
        result.name = parentProps.name;
      }
      var pp = parentProps.properties;
      for (var i = 0;i < pp.length;i++) {
        if (!myProps.hasOwnProperty(pp[i].displayName)) {
          rp.push(pp[i]);
        }
      }
    }
    return result;
  };
  this.findRootNodes = function() {
    var idroots = [];
    for (var id = 1, idend = _offsets.length;id < idend;id++) {
      var hasChild = false;
      var hasParent = false;
      var hasName = false;
      var propStart = 2 * _offsets[id];
      var propEnd = 2 * _offsets[id + 1];
      for (var i = propStart;i < propEnd;i += 2) {
        var attrId = _avs[i];
        if (attrId == _parentAttrId) {
          if (this.getIntValueAt(_avs[i + 1])) {
            hasParent = true;
          }
        } else {
          if (attrId == _childAttrId) {
            hasChild = true;
          } else {
            if (attrId == _nameAttrId) {
              hasName = true;
            }
          }
        }
      }
      if (hasChild && (hasName && !hasParent)) {
        idroots.push(id);
      }
    }
    return idroots;
  };
  this.getNodeNameAndChildren = function(node, skipChildren) {
    var id = node.dbId;
    var propStart = 2 * _offsets[id];
    var propEnd = 2 * _offsets[id + 1];
    var children;
    for (var i = propStart;i < propEnd;i += 2) {
      var attrId = _avs[i];
      var val;
      if (attrId == _parentAttrId) {
      } else {
        if (attrId == _childAttrId && !skipChildren) {
          val = this.getValueAt(_avs[i + 1]);
          var child = {dbId:val, parent:node};
          if (!children) {
            children = [child];
          } else {
            children.push(child);
          }
        } else {
          if (attrId == _nameAttrId) {
            val = this.getValueAt(_avs[i + 1]);
            node.name = val;
          } else {
            if (attrId == _instanceOfAttrId) {
              var tmp = {dbId:this.getValueAt(_avs[i + 1]), name:null};
              this.getNodeNameAndChildren(tmp, true);
              if (tmp && (tmp.name && !node.name)) {
                node.name = tmp.name;
              }
            }
          }
        }
      }
    }
    return children;
  };
  this.buildObjectTree = function(node, dbToFrag, depth, maxDepth) {
    if (depth > maxDepth[0]) {
      maxDepth[0] = depth;
    }
    var children = this.getNodeNameAndChildren(node);
    if (children) {
      for (var j = 0;j < children.length;j++) {
        this.buildObjectTree(children[j], dbToFrag, depth + 1, maxDepth);
      }
      for (j = 0;j < children.length;j++) {
        if (children[j].children || children[j].fragIds !== undefined) {
          if (!node.children) {
            node.children = [children[j]];
          } else {
            node.children.push(children[j]);
          }
        }
      }
    } else {
      var frags = dbToFrag[node.dbId];
      if (frags !== undefined) {
        node.fragIds = frags;
      }
    }
  };
  this.bruteForceSearch = function(searchText) {
    searchText = searchText.toLowerCase();
    var result = [];
    var matching_vals = [];
    for (var i = 0, iEnd = _valuesOffsets.length;i < iEnd;i++) {
      var val = this.getValueAt(i);
      if (typeof val == "string") {
        if (val.toLowerCase().indexOf(searchText) != -1) {
          matching_vals.push(i);
        }
      } else {
        if (val.toString().toLowerCase().indexOf(searchText) != -1) {
          matching_vals.push(i);
        }
      }
    }
    for (var id = 1, idend = _offsets.length;id < idend;id++) {
      var propStart = 2 * _offsets[id];
      var propEnd = 2 * _offsets[id + 1];
      for (var i = propStart;i < propEnd;i += 2) {
        if (matching_vals.indexOf(_avs[i + 1]) != -1) {
          result.push(id);
          break;
        }
      }
    }
    return result;
  };
  function modf(x) {
    var intPart = 0 <= x ? Math.floor(x) : Math.ceil(x);
    var fracPart = x - intPart;
    return{intPart:intPart, fracPart:fracPart};
  }
  function formatNumber(x, precision, needMinusSign) {
    var result = "";
    if (x === 0) {
      x = 0;
    }
    if (needMinusSign && x === 0) {
      result += "-";
    }
    if (modf(x).fracPart === 0) {
      result += x;
    } else {
      if (0 < precision) {
        var s = x.toFixed(precision);
        var re = /^\-?([0-9]+)\.0+$/;
        var m = re.exec(s);
        if (m !== null) {
          result += m[1];
        } else {
          result += s;
        }
      } else {
        result += x.toFixed(0);
      }
    }
    return result;
  }
  this.formatValueWithUnits = function(value, units, type) {
    var result;
    if (type == 1) {
      result = value ? "Yes" : "No";
    } else {
      if (units === "ft" || (units === "feet" || units === "foot")) {
        result = this.formatFeet(value * 12);
      } else {
        if (units === "in" || units === "inch") {
          result = this.formatFeet(value);
        } else {
          if (type === 3 && units) {
            units = units.replace("^2", String.fromCharCode(178));
            units = units.replace("^3", String.fromCharCode(179));
            result = formatNumber(value, 2) + " " + units;
          } else {
            if (units) {
              result = value + " " + units;
            } else {
              if (type == 3) {
                result = formatNumber(value, 3);
              } else {
                result = value;
              }
            }
          }
        }
      }
    }
    return result;
  };
  this.formatFeet = function(value) {
    if (isNaN(value)) {
      return "NaN";
    }
    var result = "";
    var radix = 12;
    var denominator = 16;
    var isNegative = value < 0;
    if (value > 0) {
      value += 0.5 / denominator;
    } else {
      value -= 0.5 / denominator;
    }
    var primeValue = modf(value / radix).intPart;
    result += formatNumber(primeValue, 0, isNegative) + "' ";
    var doublePrimeValue = value - primeValue * radix;
    if (doublePrimeValue < 0) {
      doublePrimeValue = -doublePrimeValue;
    }
    var intPart = modf(doublePrimeValue).intPart;
    var numerator = modf((doublePrimeValue - intPart) * denominator).intPart;
    if (numerator === 0 || intPart !== 0) {
      result += formatNumber(intPart, 0);
    }
    if (numerator !== 0) {
      if (intPart < 0 && numerator < 0) {
        numerator = -numerator;
      }
      while (numerator % 2 === 0) {
        numerator /= 2;
        denominator /= 2;
      }
      if (intPart !== 0) {
        result += "-";
      }
      result += formatNumber(numerator, 0) + "/" + formatNumber(denominator, 0);
    }
    result += '"';
    return result;
  };
}
;function Fydo(metadata) {
  this.metadata = metadata;
  this.scaleX = 1;
  this.scaleY = 1;
  this.bbox = new THREE.Box3;
  this.is2d = true;
  this.layersList = [];
  if (metadata) {
    this.paperWidth = parseFloat(metadata.page_dimensions.page_width);
    this.paperHeight = parseFloat(metadata.page_dimensions.page_height);
    this.bbox.min.set(0, 0, 0);
    this.bbox.max.set(this.paperWidth, this.paperHeight, 0);
    for (var l in metadata.layers) {
      var index = parseInt(l);
      var name = metadata.layers[index];
      if (!name) {
        name = "Default Layer";
      }
      this.layersList.push({name:name, index:index});
    }
    if (this.layersList.length) {
      this.layersList.sort(function(a, b) {
        return a.index - b.index;
      });
    }
  }
  if (!this.layersList.length) {
    this.layersList.push({name:"0", index:0});
  }
  this.opCount = 0;
  this.fontFaces = [];
  this.fontFamilies = [];
  this.clip = null;
  this.objectNumber = 0;
  this.imageNumber = 0;
  this.layer = 0;
  this.bgColor = 4294967295;
  this.contrastColor = this.color = this.fillColor = 4278190080;
  this.currentVbb = new VertexBufferBuilder(false);
  this.meshes = [];
  this.numCircles = this.numEllipses = this.numPolylines = this.numLineSegs = 0;
  if (this.metadata) {
    var pw = this.paperWidth;
    var ph = this.paperHeight;
    this.currentVbb.addVertexPolytriangle(0, 0, 0, 0, 0, 4294967295, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw, 0, 0, 0, 0, 4294967295, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw, ph, 0, 0, 0, 4294967295, 0, 0);
    this.currentVbb.addVertexPolytriangle(0, ph, 0, 0, 0, 4294967295, 0, 0);
    this.currentVbb.addTriangle(0, 1, 2);
    this.currentVbb.addTriangle(0, 2, 3);
    var ss = pw * 0.0075;
    this.currentVbb.addVertexPolytriangle(ss, -ss, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw + ss, -ss, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw + ss, 0, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(ss, 0, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addTriangle(4, 5, 6);
    this.currentVbb.addTriangle(4, 6, 7);
    this.currentVbb.addVertexPolytriangle(pw, 0, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw + ss, 0, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw + ss, ph - ss, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addVertexPolytriangle(pw, ph - ss, 0, 0, 0, 4283782485, 0, 0);
    this.currentVbb.addTriangle(8, 9, 10);
    this.currentVbb.addTriangle(8, 10, 11);
    this.currentVbb.addSegment(0, 0, pw, 0, 1E-6, 4278190080, 0, 0);
    this.currentVbb.addSegment(pw, 0, pw, ph, 1E-6, 4278190080, 0, 0);
    this.currentVbb.addSegment(pw, ph, 0, ph, 1E-6, 4278190080, 0, 0);
    this.currentVbb.addSegment(0, ph, 0, 0, 1E-6, 4278190080, 0, 0);
  }
  this.fragments = {};
  this.fragments.mesh2frag = {};
  this.fragments.materials = [];
  this.fragments.length = 0;
  this.error = false;
}
Fydo.prototype.load = function(loadContext, fydoPack) {
  if (fydoPack[0] == 31 && fydoPack[1] == 139) {
    var gunzip = new Zlib.Gunzip(fydoPack);
    fydoPack = gunzip.decompress();
  }
  this.data = fydoPack;
  this.parse();
  loadContext.loadDoneCB(true);
};
Fydo.prototype.loadFrames = function(loadContext, fydoPack) {
  this.data = fydoPack;
  this.parseFrames();
  loadContext.loadDoneCB(true);
};
var FydoOpcode = {kClip:75, kBackColor:66, kColor:67, kFill:70, kLayer:76, kLink:72, kLineCaps:69, kLineJoin:74, kLinePatternDef:68, kLineWeight:87, kMiterLimit:109, kMarkup:77, kObject:79, kResource:82, kFontFace:78, kFontFamily:110, kClipOff:107, kFillOff:102, kLinePatternRef:100, kArc:65, kPolyline:80, kRaster:73, kText:84, kExtended:88, kPolytriangle:83, kUndefined:89};
var F2dDataType = {dt_object:0, dt_void:1, dt_byte:2, dt_int:3, dt_float:4, dt_double:5, dt_varint:6, dt_point_int:7, dt_byte_array:32, dt_int_array:33, dt_float_array:34, dt_double_drray:35, dt_varint_array:36, dt_point_int_array:37, dt_arc:38, dt_circle:39, dt_circular_arc:40, dt_string:63, dt_last_data_type:127};
var F2dSemanticType = {st_object_member:0, st_fill:1, st_fill_off:2, st_clip_off:3, st_layer:4, st_link:5, st_line_weight:6, st_miter_angle:7, st_miter_length:8, st_line_pattern_ref:9, st_back_color:10, st_color:11, st_markup:12, st_object_id:13, st_markup_id:14, st_reset_rel_offset:15, st_begin_object:32, st_clip:33, st_line_caps:34, st_line_join:35, st_line_pattern_def:36, st_sheet:42, st_arc:43, st_polyline:44, st_raster:45, st_text:46, st_polytriangle:47, st_end_object:63, st_last_semantic_type:127};
Fydo.prototype.readColor = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  var semantic_type = s.getVarints();
  var abgr = s.getUint32();
  return abgr;
};
Fydo.prototype.readFontFace = function() {
  var s = this.stream;
  var s0 = s.getUint16();
  var face = {name:s.getString(s0), resources:[]};
  var resourceCount = s.getUint16();
  for (var i = 0;i < resourceCount;i++) {
    s0 = s.getUint16();
    face.resources.push(s.getString(s0));
  }
  face.flags = s.getUint8();
  face.panose = s.getBytes(10);
  this.fontFaces.push(face);
};
Fydo.prototype.readFontFamily = function() {
  var s = this.stream;
  var family = {id:s.getUint16(), names:[]};
  var numStrings = s.getUint16();
  for (var i = 0;i < numStrings;i++) {
    family.names.push(s.getString(s.getUint16()));
  }
  this.fontFamilies.push(family);
};
Fydo.prototype.readClip = function() {
  var s = this.stream;
  var numContours = s.getUint16();
  this.clip = [];
  for (var i = 0;i < numContours;i++) {
    var ptCount = s.getUint16();
    var contour = new Float32Array(ptCount * 2);
    for (var j = 0;j < ptCount;j++) {
      contour[j * 2] = this.tx(s.getInt32());
      contour[j * 2 + 1] = this.ty(s.getInt32());
    }
    this.clip.push(contour);
  }
};
Fydo.prototype.readPolyline = function() {
  var s = this.stream;
  var dbId = this.objectNumber;
  var color = this.color;
  var lineWidth = this.lineWeight;
  var layer = this.layer;
  var pointCount = s.getUint32();
  if (!pointCount) {
    return;
  }
  this.flushBuffer();
  var vbb = this.currentVbb;
  this.numPolylines++;
  this.numLineSegs += pointCount - 1;
  if (this.fill) {
    var vindex = vbb.vcount;
    var x0, y0, x1, y1;
    for (var i = 0;i < pointCount;i++) {
      var x2 = this.tx(s.getInt32());
      var y2 = this.ty(s.getInt32());
      vbb.addVertexPolytriangle(x2, y2, 0, 0, 0, color, dbId, layer);
      if (i >= 2) {
        var e1x = x1 - x0, e1y = y1 - y0, e2x = x2 - x0, e2y = y2 - y0;
        var cross = e1x * e2y - e2x * e1y;
        if (cross > 0) {
          vbb.addTriangle(vindex, vindex + i - 1, vindex + i);
        } else {
          vbb.addTriangle(vindex, vindex + i, vindex + i - 1);
        }
      }
      x0 = x1;
      y0 = y1;
      x1 = x2;
      y1 = y2;
    }
    var traceFilledPolygon = false;
    if (traceFilledPolygon) {
      var stride = vbb.stride;
      var vbf = vbb.vbf;
      var thinWidth = this.lineWeight * 1E-6;
      for (i = 0;i < pointCount;i++) {
        var offset = stride * (vindex + i);
        x0 = vbf[offset];
        y0 = vbf[offset + 1];
        x1 = vbf[offset + stride];
        y1 = vbf[offset + stride + 1];
        vbb.addSegment(x0, y0, x1, y1, thinWidth, color, dbId, layer, i == 0, false, true);
      }
    }
  } else {
    var x0 = this.tx(s.getInt32());
    var y0 = this.ty(s.getInt32());
    for (var i = 1;i < pointCount;i++) {
      var x1 = this.tx(s.getInt32());
      var y1 = this.ty(s.getInt32());
      this.currentVbb.addSegment(x0, y0, x1, y1, lineWidth, color, dbId, layer, i == 1, i == pointCount - 1, true);
      x0 = x1;
      y0 = y1;
    }
  }
};
Fydo.prototype.readArc = function() {
  var s = this.stream;
  var arc = {cx:this.tx(s.getInt32()), cy:this.ty(s.getInt32()), major:this.sx(s.getInt32()), minor:this.sy(s.getInt32()), rotation:s.getFloat32(), start:s.getFloat32() % (Math.PI * 2), end:s.getFloat32() % (Math.PI * 2), cw:s.getUint8(), largeArc:s.getUint8()};
  var isComplete = Math.abs(arc.end - arc.start) < 0.001;
  var isCircular = Math.abs(1 - arc.major / arc.minor) < 0.01;
  if (isCircular) {
    if (isComplete && this.fill) {
      this.flushBuffer();
      this.currentVbb.addSegment(arc.cx, arc.cy, arc.cx, arc.cy, arc.major * 2, this.color, this.objectNumber, this.layer, true, false, true);
    } else {
      this.flushBuffer();
      this.currentVbb.addCircularArc(arc.cx, arc.cy, isComplete ? 0 : arc.start + arc.rotation, isComplete ? Math.PI * 2 : arc.end + arc.rotation, arc.major, this.lineWeight, this.color, this.objectNumber, this.layer);
    }
    this.numCircles++;
  } else {
    this.currentVbb.addEllipticalArc(arc.cx, arc.cy, arc.start, arc.end, arc.major, arc.minor, arc.rotation, this.lineWeight, this.color, this.objectNumber, this.layer);
    this.numEllipses++;
  }
};
Fydo.prototype.readPolytriangle = function() {
  var s = this.stream;
  var i;
  var vcount = s.getUint32();
  this.flushBuffer(vcount);
  var vbb = this.currentVbb;
  var vbase = this.currentVbb.vcount;
  for (i = 0;i < vcount;i++) {
    var x = this.tx(s.getInt32());
    var y = this.ty(s.getInt32());
    vbb.addVertexPolytriangle(x, y, 0, 0, 0, this.color, this.objectNumber, this.layer);
  }
  var icount = s.getUint32();
  for (i = 0;i < icount;i += 3) {
    var i0 = s.getUint16(), i1 = s.getUint16(), i2 = s.getUint16();
    vbb.addTriangle(vbase + i0, vbase + i1, vbase + i2);
  }
  var ccount = s.getUint32();
  for (i = 0;i < ccount;i++) {
    var color = s.getInt32();
    vbb.setVertexColor(vbase + i, color);
  }
};
Fydo.prototype.readRaster = function() {
  var s = this.stream;
  function base64Encode(str) {
    var CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var out = "", i = 0, len = str.length, c1, c2, c3;
    while (i < len) {
      c1 = str[i++] & 255;
      if (i == len) {
        out += CHARS.charAt(c1 >> 2);
        out += CHARS.charAt((c1 & 3) << 4);
        out += "==";
        break;
      }
      c2 = str[i++];
      if (i == len) {
        out += CHARS.charAt(c1 >> 2);
        out += CHARS.charAt((c1 & 3) << 4 | (c2 & 240) >> 4);
        out += CHARS.charAt((c2 & 15) << 2);
        out += "=";
        break;
      }
      c3 = str[i++];
      out += CHARS.charAt(c1 >> 2);
      out += CHARS.charAt((c1 & 3) << 4 | (c2 & 240) >> 4);
      out += CHARS.charAt((c2 & 15) << 2 | (c3 & 192) >> 6);
      out += CHARS.charAt(c3 & 63);
    }
    return out;
  }
  this.flushBuffer(4, true);
  var x = this.tx(s.getInt32()), y = this.ty(s.getInt32()), w = s.getUint32(), h = s.getUint32(), sx = this.tx(s.getFloat32()), sy = this.ty(s.getFloat32());
  var texture = {isPng:s.getUint8(), bits:s.getBytes(s.getUint32()), width:w, height:h};
  if (texture.isPng) {
    texture.dataURI = "data:image/png;base64," + base64Encode(texture.bits);
    texture.bits = null;
  } else {
    texture.dataURI = "data:image/jpg;base64," + base64Encode(texture.bits);
    texture.bits = null;
  }
  this.currentVbb.addTexturedQuad(x, y - h * sy, w * sx, h * sy, this.objectNumber, this.layer);
  this.currentImage = texture;
  this.flushBuffer(0, true);
};
Fydo.prototype.readLinePatternDef = function() {
  var s = this.stream;
  var linePattern = {};
  linePattern.id = s.getUint16();
  var pairs = s.getUint16();
  var def = linePattern.def = [];
  for (var i = 0;i < pairs;i++) {
    def.push(s.getFloat32());
    def.push(s.getFloat32());
  }
  this.linePatterns[linePattern.id] = linePattern;
};
Fydo.prototype.flushBuffer = function(addCount, force) {
  if (!this.currentVbb.vcount) {
    return;
  }
  var flush = force;
  flush = flush || this.currentVbb.isFull(addCount);
  if (flush) {
    var mesh = this.currentVbb.toMesh();
    this.bbox.union(mesh.boundingBox);
    this.meshes.push(mesh);
    mesh.material = {};
    if (this.currentImage) {
      mesh.material.image = this.currentImage;
      mesh.material.image.name = this.imageNumber++;
      this.currentImage = null;
    }
    this.currentVbb = new VertexBufferBuilder;
  }
};
Fydo.prototype.tx = function(x) {
  return this.sx(x);
};
Fydo.prototype.ty = function(y) {
  return this.sy(y);
};
Fydo.prototype.sx = function(x) {
  return x * this.scaleX;
};
Fydo.prototype.sy = function(y) {
  return y * this.scaleY;
};
Fydo.prototype.invertColor = function(c) {
  var a = c >> 24 & 255;
  var b = c >> 16 & 255;
  var g = c >> 8 & 255;
  var r = c & 255;
  b = 255 - b;
  g = 255 - g;
  r = 255 - r;
  return a << 24 | b << 16 | g << 8 | r;
};
Fydo.prototype.mapColor = function(c) {
  return c;
};
Fydo.prototype.parserAssert = function(actualType, expectedType, functionName) {
  if (actualType != expectedType) {
    debug("Expect " + expectedType + "; actual type is " + actualType + "; in function " + functionName);
    this.error = true;
    return true;
  } else {
    return false;
  }
};
Fydo.prototype.parseObject = function() {
  var s = this.stream;
  var semantic_type = s.getVarints();
  switch(semantic_type) {
    case F2dSemanticType.st_sheet:
      this.paperColor = this.readColor();
      break;
    case F2dSemanticType.st_clip:
      this.parseClip();
      break;
    case F2dSemanticType.st_polytriangle:
      this.parsePolyTriangle();
      break;
    case F2dSemanticType.st_end_object:
      break;
    case F2dSemanticType.st_raster:
      this.parseRaster();
      break;
    default:
      this.error = true;
      debug("Unhandled semantic type: " + semantic_type);
      break;
  }
};
Fydo.prototype.parseRaster = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_point_int, "parseRaster")) {
    return;
  }
  this.parsePoint();
  data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_varint, "parseRaster")) {
    return;
  }
  var width = this.parseVarint();
  data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_varint, "parseRaster")) {
    return;
  }
  var height = this.parseVarint();
  data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_varint, "parseRaster")) {
    return;
  }
  var imageId = this.parseVarint();
  this.parseEndOfObject();
};
Fydo.prototype.parsePoint = function() {
  var s = this.stream;
  var sema = s.getVarints();
  var relX = s.getVarints();
  var relY = s.getVarints();
};
Fydo.prototype.parseVarintArray = function() {
  var s = this.stream;
  var sema = s.getVarints();
  debug("Varint array sema type: " + sema);
  var count = s.getVarints();
  for (var i = 0;i < count;++i) {
    s.getVarints();
  }
};
Fydo.prototype.parsePolyTriangle = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_point_int_array, "parsePolyTriangle")) {
    return;
  }
  this.parsePointsArray();
  data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_varint_array, "parsePolyTriangle")) {
    return;
  }
  this.parseVarintArray();
  data_type = s.getVarints();
  if (data_type == F2dDataType.dt_object) {
    var sema = s.getVarints();
    if (this.parserAssert(sema, F2dSemanticType.st_end_object, "parsePolyTriangle")) {
      return;
    }
  } else {
    if (this.parserAssert(data_type, F2dDataType.dt_int_array, "parsePolyTriangle")) {
      return;
    }
    this.parseIntArray();
    this.parseEndOfObject();
  }
};
Fydo.prototype.parseClip = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_int_array, "parseClip")) {
    return;
  }
  this.parseIntArray();
  data_type = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_point_int_array, "parseClip")) {
    return;
  }
  this.parsePointsArray();
  this.parseEndOfObject();
};
Fydo.prototype.parseEndOfObject = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  var sema = s.getVarints();
  if (this.parserAssert(data_type, F2dDataType.dt_object, "parseEndOfObject")) {
    return;
  }
  if (this.parserAssert(sema, F2dSemanticType.st_end_object, "parseEndOfObject")) {
    return;
  }
};
Fydo.prototype.parsePointsArray = function() {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints();
  count = count / 2;
  for (var i = 0;i < count;++i) {
    var relX = s.getVarints();
    var relY = s.getVarints();
  }
};
Fydo.prototype.parseIntArray = function() {
  var s = this.stream;
  var sema = s.getVarints();
  var count = s.getVarints();
  for (var i = 0;i < count;++i) {
    s.getUint32();
  }
};
Fydo.prototype.parseInt = function() {
  var s = this.stream;
  var sema = s.getVarints();
  debug("parseInt sema type : " + sema);
  if (sema = F2dSemanticType.st_color) {
    var color = s.getUint32()
  }
};
Fydo.prototype.parseVoid = function() {
  var s = this.stream;
  var sema = s.getVarints();
};
Fydo.prototype.parseVarint = function() {
  var s = this.stream;
  var semantic_type = s.getVarints();
  var val = s.getVarints();
  return val;
};
Fydo.prototype.parseFloat = function() {
  var s = this.stream;
  var sema = s.getVarints();
  var val = s.getFloat32();
  return val;
};
Fydo.prototype.parseCircularArc = function() {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, "parseCircularArc")) {
    return;
  }
  var relX = s.getVarints();
  var relY = s.getVarints();
  var major = s.getVarints();
  var start = s.getFloat32();
  var end = s.getFloat32();
};
Fydo.prototype.parseCircle = function() {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, "parseCircle")) {
    return;
  }
  var relX = s.getVarints();
  var relY = s.getVarints();
  var major = s.getVarints();
};
Fydo.prototype.parseArc = function() {
  var s = this.stream;
  var sema = s.getVarints();
  if (this.parserAssert(sema, F2dSemanticType.st_arc, "parseArc")) {
    return;
  }
  var relX = s.getVarints();
  var relY = s.getVarints();
  var major = s.getVarints();
  var minor = s.getVarints();
  var rotation = s.getFloat32();
  var start = s.getFloat32();
  var end = s.getFloat32();
};
Fydo.prototype.parseDataType = function() {
  var s = this.stream;
  var data_type = s.getVarints();
  switch(data_type) {
    case F2dDataType.dt_void:
      this.parseVoid();
      break;
    case F2dDataType.dt_int:
      this.parseInt();
      break;
    case F2dDataType.dt_object:
      this.parseObject();
      break;
    case F2dDataType.dt_varint:
      this.parseVarint();
      break;
    case F2dDataType.dt_float:
      this.parseFloat();
      break;
    case F2dDataType.dt_point_int_array:
      this.parsePointsArray();
      break;
    case F2dDataType.dt_circular_arc:
      this.parseCircularArc();
      break;
    case F2dDataType.dt_circle:
      this.parseCircle();
      break;
    case F2dDataType.dt_arc:
      this.parseArc();
      break;
    default:
      this.error = true;
      debug("Data type not supported yet: " + data_type);
      break;
  }
};
Fydo.prototype.parse = function() {
  var stream = this.stream = new InputStream(this.data);
  var header = stream.getString(3);
  if (header != "F2D") {
    debug("Invalid F2D header : " + header);
    return;
  }
  var versionMajor = stream.getString(2);
  if (versionMajor != "01") {
    debug("Only support f2d major version 1; actual version is : " + versionMajor);
    return;
  }
  var dot = stream.getString(1);
  if (dot != ".") {
    debug("Invalid version delimiter.");
    return;
  }
  var versionMinor = stream.getString(2);
  while (stream.offset < stream.byteLength) {
    this.parseDataType();
    if (this.error) {
      break;
    }
    this.opCount++;
  }
  if (0) {
    this.flushBuffer(0, true);
    var s = this.bbox.size();
    var count = 10;
    for (var i = 0;i < count;i++) {
      for (var j = 0;j < count;j++) {
        var cx = (i + 0.5) / count * s.x;
        var cy = (j + 0.5) / count * s.x;
        var ar = (i + 1) / (j + 1);
        var major = 1 * s.x / count;
        var minor = 1 * s.x / count;
        if (ar > 1) {
          minor /= ar;
        } else {
          major *= ar;
        }
        var lineWeight = s.x * 0.001 * (i + 1);
        for (var k = 0;k < 10;k++) {
          this.currentVbb.addEllipticalArc(cx, cy, Math.PI * 2 * (i / count), Math.PI * 2 - 1E-6, major - k * lineWeight, minor - k * lineWeight, 0, lineWeight, 4278190080, 0, 0);
        }
      }
    }
  }
  this.flushBuffer(0, true);
  this.currentVbb = null;
  this.fragments.length = this.meshes.length;
  for (var i = 0;i < this.meshes.length;i++) {
    var meshId = "0:" + i;
    this.fragments.mesh2frag[meshId] = i;
  }
  this.stream = null;
  this.data = null;
};
function FydoProbe() {
  this.data = null;
  this.frameStart = 0;
  this.frameEnd = 0;
  this.stream = null;
  this.opCount = 0;
}
FydoProbe.prototype.load = function(data, offset) {
  this.data = data;
  this.frameStart = offset;
  if (!this.stream) {
    this.stream = new CheckedInputStream(this.data);
    this.stream.seek(14);
  } else {
    this.stream.reset(this.data);
    this.stream.seek(offset);
  }
  this.probe();
  return{frameStart:this.frameStart, frameEnd:this.frameEnd};
};
var FydoProbeOpcode = {kClip:75, kBackColor:66, kColor:67, kFill:70, kLayer:76, kLink:72, kLineCaps:69, kLineJoin:74, kLinePatternDef:68, kLineWeight:87, kMiterLimit:109, kMarkup:77, kObject:79, kResource:82, kFontFace:78, kFontFamily:110, kClipOff:107, kFillOff:102, kLinePatternRef:100, kArc:65, kPolyline:80, kRaster:73, kText:84, kExtended:88, kPolytriangle:83, kUndefined:89};
FydoProbe.prototype.readColor = function() {
  this.stream.getInt32();
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readFontFace = function() {
  var s = this.stream;
  s.getString(s.getUint16());
  var resourceCount = s.getUint16();
  for (var i = 0;i < resourceCount;i++) {
    s.getString(s.getUint16());
  }
  s.getUint8();
  s.getBytes(10);
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readFontFamily = function() {
  var s = this.stream;
  s.getUint16();
  var numStrings = s.getUint16();
  for (var i = 0;i < numStrings;i++) {
    s.getString(s.getUint16());
  }
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readClip = function() {
  var s = this.stream;
  var numContours = s.getUint16();
  for (var i = 0;i < numContours;i++) {
    var ptCount = s.getUint16();
    for (var j = 0;j < ptCount;j++) {
      s.getInt32();
      s.getInt32();
    }
  }
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readPolyline = function() {
  var s = this.stream;
  var pointCount = s.getUint32();
  if (!pointCount) {
    return;
  }
  if (this.fill) {
    for (var i = 0;i < pointCount;i++) {
      s.getInt32();
      s.getInt32();
    }
  } else {
    s.getInt32();
    s.getInt32();
    for (var i = 1;i < pointCount;i++) {
      s.getInt32();
      s.getInt32();
    }
  }
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readArc = function() {
  var s = this.stream;
  s.getInt32();
  s.getInt32();
  s.getInt32();
  s.getInt32();
  s.getFloat32();
  s.getFloat32();
  s.getFloat32();
  s.getUint8();
  s.getUint8();
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readPolytriangle = function() {
  var s = this.stream;
  var i;
  var vcount = s.getUint32();
  for (i = 0;i < vcount;i++) {
    s.getInt32();
    s.getInt32();
  }
  var icount = s.getUint32();
  for (i = 0;i < icount;i += 3) {
    s.getUint16();
    s.getUint16();
    s.getUint16();
  }
  var ccount = s.getUint32();
  for (i = 0;i < ccount;i++) {
    s.getInt32();
  }
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readRaster = function() {
  var s = this.stream;
  s.getInt32();
  s.getInt32();
  s.getUint32();
  s.getUint32();
  s.getFloat32();
  s.getFloat32();
  s.getUint8();
  s.getBytes(s.getUint32());
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.readLinePatternDef = function() {
  var s = this.stream;
  s.getUint16();
  var pairs = s.getUint16();
  for (var i = 0;i < pairs;i++) {
    s.getFloat32();
    s.getFloat32();
  }
  this.frameEnd = this.stream.offset;
};
FydoProbe.prototype.probe = function() {
  var stream = this.stream;
  var error = false;
  try {
    while (true) {
      var opcode = stream.getUint8();
      switch(opcode) {
        case FydoProbeOpcode.kBackColor:
          this.bgColor = this.readColor();
          break;
        case FydoProbeOpcode.kFontFace:
          this.readFontFace();
          break;
        case FydoProbeOpcode.kFontFamily:
          this.readFontFamily();
          break;
        case FydoProbeOpcode.kClip:
          this.readClip();
          break;
        case FydoProbeOpcode.kClipOff:
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kResource:
          stream.getUint16();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kObject:
          stream.getUint32();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kLineCaps:
          stream.getUint8();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kLineWeight:
          stream.getInt16();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kLineJoin:
          stream.getUint8();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kMiterLimit:
          stream.getFloat32();
          stream.getFloat32();
          this.frameEnd = this.stream.offset;
          break;
        case FydoOpcode.kLinePatternDef:
          this.readLinePatternDef();
          break;
        case FydoOpcode.kLinePatternRef:
          stream.getUint16();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kColor:
          this.readColor();
          break;
        case FydoProbeOpcode.kFillOff:
          this.fill = false;
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kFill:
          this.fill = true;
          this.readColor();
          break;
        case FydoProbeOpcode.kLayer:
          stream.getUint16();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kMarkup:
          stream.getUint32();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kLink:
          stream.getUint16();
          this.frameEnd = this.stream.offset;
          break;
        case FydoProbeOpcode.kPolyline:
          this.readPolyline();
          break;
        case FydoProbeOpcode.kArc:
          this.readArc();
          break;
        case FydoProbeOpcode.kRaster:
          this.readRaster();
          break;
        case FydoProbeOpcode.kPolytriangle:
          this.readPolytriangle();
          break;
        default:
          debug("error probing fydo with op code: " + opcode);
          error = true;
          break;
      }
      if (error) {
        debug("bad op code : " + opcode);
        break;
      }
      this.opCount++;
    }
  } catch (e) {
  }
};
function CheckedInputStream(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
  this.convBuf = new ArrayBuffer(8);
  this.convUint8 = new Uint8Array(this.convBuf);
  this.convUint16 = new Uint16Array(this.convBuf);
  this.convInt32 = new Int32Array(this.convBuf);
  this.convUint32 = new Uint32Array(this.convBuf);
  this.convFloat32 = new Float32Array(this.convBuf);
  this.convFloat64 = new Float64Array(this.convBuf);
}
function OutOfBoundsBufferAccessException(offset) {
  this.offset = offset;
  this.message = "try to access an offset that is out of bounds: " + this.offset;
  this.toString = function() {
    return this.message;
  };
}
CheckedInputStream.prototype.boundsCheck = function(offset) {
  if (offset >= this.byteLength) {
    throw new OutOfBoundsBufferAccessException(offset);
  }
};
CheckedInputStream.prototype.seek = function(off) {
  this.boundsCheck(off);
  this.offset = off;
};
CheckedInputStream.prototype.getBytes = function(len) {
  this.boundsCheck(this.offset + len);
  var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
  this.offset += len;
  return ret;
};
CheckedInputStream.prototype.getUint8 = function() {
  this.boundsCheck(this.offset + 1);
  return this.buffer[this.offset++];
};
CheckedInputStream.prototype.getUint16 = function() {
  this.boundsCheck(this.offset + 2);
  this.convUint8[0] = this.buffer[this.offset++];
  this.convUint8[1] = this.buffer[this.offset++];
  return this.convUint16[0];
};
CheckedInputStream.prototype.getInt16 = function() {
  var tmp = this.getUint16();
  if (tmp > 32767) {
    tmp = tmp | 4294901760;
  }
  return tmp;
};
CheckedInputStream.prototype.getInt32 = function() {
  this.boundsCheck(this.offset + 4);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convInt32[0];
};
CheckedInputStream.prototype.getUint32 = function() {
  this.boundsCheck(this.offset + 4);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convUint32[0];
};
CheckedInputStream.prototype.getFloat32 = function() {
  this.boundsCheck(this.offset + 4);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  dst[0] = src[off];
  dst[1] = src[off + 1];
  dst[2] = src[off + 2];
  dst[3] = src[off + 3];
  this.offset += 4;
  return this.convFloat32[0];
};
CheckedInputStream.prototype.getFloat64 = function() {
  this.boundsCheck(this.offset + 8);
  var src = this.buffer;
  var dst = this.convUint8;
  var off = this.offset;
  for (var i = 0;i < 8;i++) {
    dst[i] = src[off + i];
  }
  this.offset += 8;
  return this.convFloat64[0];
};
CheckedInputStream.prototype.getString = function(len) {
  this.boundsCheck(this.offset + len);
  var src = this.buffer;
  var dst = "";
  for (var i = this.offset, iEnd = this.offset + len;i < iEnd;i++) {
    dst += String.fromCharCode(src[i]);
  }
  this.offset += len;
  return decodeURIComponent(escape(dst));
};
CheckedInputStream.prototype.reset = function(buf) {
  this.buffer = buf;
  this.offset = 0;
  this.byteLength = buf.length;
};
AutodeskNamespace("Autodesk.Viewing.Private");
var VIEWER2D_NAVIGATION_MODE = {PAN:1, ZOOM:2};
Autodesk.Viewing.Private.Viewer2DImpl = function(api, config) {
  this.api = api;
  this.config = config;
  this.parent = config.domElement;
  this.navigationMode = null;
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.constructor = Autodesk.Viewing.Private.Viewer2DImpl;
Autodesk.Viewing.Private.Viewer2DImpl.prototype.initialize = function() {
  var selectionCanvas = document.createElement("canvas");
  selectionCanvas.width = 1;
  selectionCanvas.height = 1;
  this.selCtx = selectionCanvas.getContext("2d");
  this.selCtx.globalCompositeOperation = "copy";
  this.selCtx.imageSmoothingEnabled = false;
  this.container = document.createElement("div");
  this.container.style.width = "100%";
  this.container.style.height = "100%";
  this.parent.appendChild(this.container);
  return 0;
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.load = function(sheetUrn) {
  var rolloverColor = [-1, -1, -1, -1];
  var rolloverId = -1;
  var tileSize = this.config.tileSize ? this.config.tileSize : 1024;
  var maxZoom = this.config.maxZoom ? this.config.maxZoom : 5;
  var colorExt = "png";
  var index = sheetUrn.indexOf("urn:");
  if (index != -1) {
    sheetUrn = sheetUrn.substr(0, index) + encodeURIComponent(sheetUrn.substr(index));
  }
  var layerNames = [sheetUrn];
  var layers = [];
  for (var i = 0;i < layerNames.length;i++) {
    var l = L.tileLayer(layerNames[i] + "/{z}/{x}/c{y}." + colorExt, {maxZoom:maxZoom, noWrap:true, continuousWorld:false, detectRetina:true, tileSize:tileSize});
    layers.push(l);
  }
  var map = this.map = L.map(this.container, {center:new L.LatLng(0, 0), zoom:0, zoomControl:false, attributionControl:false, layers:[layers[0]]});
  map.options.crs.scale = function(zoom) {
    return tileSize * Math.pow(2, zoom);
  };
  var baseMaps = {};
  for (var i = 0;i < layerNames.length;i++) {
    baseMaps[layerNames[i]] = layers[3 * i];
  }
  var overlayMaps;
  L.control.layers(baseMaps, overlayMaps).addTo(map);
  var elements = document.getElementsByClassName("leaflet-control-layers");
  for (var i = 0;i < elements.length;i++) {
    elements[i].style.visibility = "hidden";
  }
  map.on("baselayerchange", function(e) {
    console.log(e);
    var toRemove = [];
    for (var p in map._layers) {
      var layer = map._layers[p];
      if (layer != e.layer) {
        toRemove.push(layer);
      }
    }
    for (var i = 0;i < toRemove.length;i++) {
      map.removeLayer(toRemove[i]);
    }
    if (e.layer.idTileLayer) {
      map.addLayer(e.layer.idTileLayer);
      map.addLayer(e.layer.canvasLayer);
    }
  });
  var self = this;
  var isMouseDown = false;
  var mouseDownClientX, mouseDownClientY, mouseDownZoom, mouseDownCenter, pixelsPerZoomStep;
  this.mousemove = function(event) {
    if (!isMouseDown || self.navigationMode !== VIEWER2D_NAVIGATION_MODE.ZOOM) {
      return;
    }
    var deltaX = event.clientX - mouseDownClientX;
    var deltaY = event.clientY - mouseDownClientY;
    deltaY = -deltaY;
    if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
      var delta = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
      var newZoom = Math.round(mouseDownZoom + delta / pixelsPerZoomStep);
      newZoom = Math.max(map.getMinZoom(), Math.min(newZoom, map.getMaxZoom()));
      map.setZoomAround(mouseDownCenter, newZoom, {animate:true});
      event.preventDefault();
      event.stopPropagation();
    }
  };
  map.on("mousedown", function(event) {
    isMouseDown = true;
    if (self.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
      mouseDownClientX = event.originalEvent.clientX;
      mouseDownClientY = event.originalEvent.clientY;
      mouseDownZoom = map.getZoom();
      mouseDownCenter = map.getCenter();
      var mapSize = map.getSize();
      var width = mapSize.x < mapSize.y ? mapSize.x : mapSize.y;
      var zoomRange = map.getMaxZoom() - map.getMinZoom();
      pixelsPerZoomStep = width / (2 * zoomRange);
      map.scrollWheelZoom.disable();
      window.addEventListener("mousemove", self.mousemove, false);
      event.originalEvent.preventDefault();
      event.originalEvent.stopPropagation();
    }
  });
  map.on("mouseup", function(event) {
    isMouseDown = false;
    if (self.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
      map.scrollWheelZoom.enable();
      window.removeEventListener("mousemove", self.mousemove, false);
      event.originalEvent.preventDefault();
      event.originalEvent.stopPropagation();
    }
  });
  this.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
  this.keyup = function(event) {
    var activeElementName = document.activeElement.nodeName;
    if (activeElementName === "INPUT" || activeElementName === "TEXTAREA") {
      return;
    }
    var handled = false;
    if (event.keyCode === 27) {
      self.api.fireEvent({type:Autodesk.Viewing.ESCAPE_EVENT});
      handled = true;
    } else {
      if (event.keyCode === 36 || (event.keyCode === 70 || event.keyCode === 72)) {
        self.goHome();
        handled = true;
      }
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  window.addEventListener("keyup", this.keyup, false);
  map.fitWorld();
  return true;
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.uninitialize = function() {
  window.removeEventListener("mousemove", this.mousemove, false);
  window.removeEventListener("keyup", this.keyup, false);
  this.map.remove();
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.resize = function() {
  this.map.invalidateSize(false);
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.setNavigationMode = function(mode) {
  var changed = false;
  if (this.navigationMode !== mode) {
    this.navigationMode = mode;
    if (this.map) {
      if (mode === VIEWER2D_NAVIGATION_MODE.PAN) {
        this.map.dragging.enable();
        window.removeEventListener("mousemove", this.mousemove, false);
      } else {
        if (mode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
          this.map.dragging.disable();
        }
      }
    }
    this.api.fireEvent({type:Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, value:mode});
    changed = true;
  }
  return changed;
};
Autodesk.Viewing.Private.Viewer2DImpl.prototype.goHome = function() {
  this.map.setView([0, 0], 0, {reset:true});
};
var Xhr = function() {
  var Xhr = function(errorHandler, auth, viewing_url) {
    this.xhr = new XMLHttpRequest;
    this.errorHandler = errorHandler;
    this.success = false;
    this.viewing_url = viewing_url;
    this.auth = auth;
  };
  Xhr.prototype.generateUrl = function(url, queryParams, options) {
    var index = url.indexOf("urn:");
    if (index === 0 && this.viewing_url) {
      var feature = options && options.feature ? options.feature : null;
      if (feature) {
        if (feature == "render") {
          url = url.substr(4);
          url = this.viewing_url + "/" + feature + "/" + encodeURIComponent(url);
        } else {
          url = this.viewing_url + "/" + feature + "/" + encodeURIComponent(url.substr(index));
        }
      } else {
        url = this.viewing_url + "/items/" + encodeURIComponent(url.substr(index));
      }
    }
    if (queryParams) {
      url = url + "?" + queryParams;
    }
    return url;
  };
  Xhr.prototype.addHeaders = function(headers) {
    headers["Access-Control-Allow-Credentials"] = true;
    headers["Access-Control-Allow-Origin"] = "*";
    for (var header in headers) {
      this.xhr.setRequestHeader(header, headers[header]);
    }
  };
  Xhr.prototype.get = function(path, headers, responseType, loadCB, feature, queryParams) {
    var url = this.generateUrl(path, queryParams, {feature:feature});
    try {
      this.xhr.open("GET", url, !!loadCB);
      this.xhr.responseType = responseType;
      this.success = false;
      if (this.auth) {
        this.xhr.withCredentials = true;
      }
      if (loadCB) {
        this.xhr.onload = loadCB;
      }
      this.addHeaders(headers);
      this.xhr.send();
    } catch (e) {
      if (this.errorHandler) {
        this.errorHandler.networkFailure(url, e);
      }
      return null;
    }
    this.errorCheck(url, 200);
    return this.xhr.response;
  };
  Xhr.prototype.post = function(path, headers, body, responseType, loadCB, feature) {
    var url = this.generateUrl(path, null, {feature:feature});
    headers["Content-Type"] = "application/json";
    try {
      this.xhr.open("POST", url, !!loadCB);
      this.xhr.responseType = responseType;
      this.success = false;
      if (this.auth) {
        this.xhr.withCredentials = true;
      }
      if (loadCB) {
        this.xhr.onload = loadCB;
      }
      this.addHeaders(headers);
      this.xhr.send(body);
    } catch (e) {
      if (this.errorHandler) {
        this.errorHandler.networkFailure(url, e);
      }
      return null;
    }
    this.errorCheck(url, 200);
    return this.xhr.response;
  };
  Xhr.prototype.getRange = function(url, headers, responseType, rangeBegin, rangeEnd, loadCB) {
    var url = this.generateUrl(path);
    headers["Range"] = "bytes=" + rangeBegin + "-" + rangeEnd;
    try {
      this.xhr.open("GET", url, !!loadCB);
      this.xhr.responseType = responseType;
      this.success = false;
      if (this.auth) {
        this.xhr.withCredentials = true;
      }
      if (loadCB) {
        this.xhr.onload = loadCB;
      }
      this.addHeaders(headers);
      this.xhr.send();
    } catch (e) {
      if (this.errorHandler) {
        this.errorHandler.networkFailure(url, e);
      }
      return null;
    }
    this.errorCheck(url, 206);
    return this.xhr.response;
  };
  Xhr.prototype.head = function(url) {
    var url = this.generateUrl(path);
    try {
      this.xhr.open("GET", url, false);
      this.success = false;
      if (this.auth) {
        this.xhr.withCredentials = true;
      }
      this.addHeaders([]);
      this.xhr.send();
    } catch (e) {
      if (this.errorHandler) {
        this.errorHandler.networkFailure(url, e);
      }
      return null;
    }
    this.errorCheck(url, 200);
    var responseHeaders = [];
    responseHeaders["Accept-Ranges"] = this.xhr.getResponseHeader("Accept-Ranges");
    responseHeaders["Content-Length"] = this.xhr.getResponseHeader("Content-Length");
    return responseHeaders;
  };
  Xhr.prototype.errorCheck = function(url, expectedStatusCode) {
    if (this.xhr.readyState === 4 && (this.xhr.status && this.xhr.status != expectedStatusCode)) {
      if (this.errorHandler) {
        this.errorHandler.unsuccessfulResponse(url, this.xhr.status, this.xhr.statusText);
      }
    } else {
      this.success = true;
    }
  };
  return Xhr;
}();
var XhrErrorHandler = function() {
  var XhrErrorHandler = function(host) {
    this.host = host;
    this.ignoreFileNotFound = false;
  };
  XhrErrorHandler.prototype.networkFailure = function(url, exc) {
    this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_FAILURE, "Network failure", {"url":url, "exception":exc.toString(), "stack":exc.stack});
  };
  XhrErrorHandler.prototype.unsuccessfulResponse = function(url, httpStatus, httpStatusText) {
    if (httpStatus == 403) {
      this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED, "Access denied to remote resource", {"url":url, "httpStatus":httpStatus, "httpStatusText":httpStatusText});
    } else {
      if (httpStatus == 404) {
        if (!this.ignoreFileNotFound) {
          this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND, "Remote resource not found", {"url":url, "httpStatus":httpStatus, "httpStatusText":httpStatusText});
        }
      } else {
        if (httpStatus >= 500 && httpStatus < 600) {
          this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR, "Server error when accessing resource", {"url":url, "httpStatus":httpStatus, "httpStatusText":httpStatusText});
        } else {
          this.host.raiseError(Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE, "Unhandled response code from server", {"url":url, "httpStatus":httpStatus, "httpStatusText":httpStatusText});
        }
      }
    }
  };
  return XhrErrorHandler;
}();
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.Logger = function(options) {
  this.queue = [];
  this.console = options.console;
  this.viewingservice = options.viewingservice;
  this.webstorage = options.webstorage;
  this.endpoint = options.endpoint + "/logs/";
  this.flushThreshold = options.flushThreshold;
  if (this.viewingservice) {
    this.xhr = new XMLHttpRequest;
  }
  this.lastFlushTime = Date.now();
};
Autodesk.Viewing.Private.Logger.prototype.bindURN = function(urn) {
  this.urn = urn;
};
Autodesk.Viewing.Private.Logger.prototype.flush = function() {
  if (!this.queue.length) {
    return;
  }
  var log = JSON.stringify(this.queue);
  if (this.console) {
    console.log(log);
  }
  if (this.viewingservice) {
    try {
      var xhr = this.xhr;
      xhr.open("POST", this.endpoint + encodeURIComponent(this.urn), true);
      xhr.setRequestHeader("Access-Control-Allow-Credentials", "true");
      xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
      xhr.setRequestHeader("Content-Type", "application/json;charset=utf-8");
      xhr.withCredentials = true;
      xhr.send(log);
    } catch (e) {
    }
  }
  this.queue = [];
  this.lastFlushTime = Date.now();
};
Autodesk.Viewing.Private.Logger.prototype.log = function(entry, forceFlush) {
  this.queue.push(entry);
  if (this.queue.length > this.flushThreshold || forceFlush) {
    this.flush();
  }
};
var propdb = null;
var propdbFailed = false;
function loadAsyncResource(loadContext, resourceName, callback) {
}
function loadPropertyPacks(loadContext, dbId) {
  if (propdb) {
    return true;
  }
  if (propdbFailed) {
    return false;
  }
  var dbfiles = loadContext.propertydb;
  if (!dbfiles) {
    return false;
  }
  var loadedDbFiles = {ids:{}, attrs:{}, offsets:{}, values:{}, avs:{}};
  var success = 0;
  var filename, res;
  filename = dbfiles.attrs.length ? dbfiles.attrs[0] : "objects_attrs.json.gz";
  res = requestFile(loadContext.url + filename, loadContext);
  if (res) {
    loadedDbFiles.attrs[filename] = res;
  }
  success += !!res;
  filename = dbfiles.values.length ? dbfiles.values[0] : "objects_vals.json.gz";
  res = requestFile(loadContext.url + filename, loadContext);
  if (res) {
    loadedDbFiles.values[filename] = res;
  }
  success += !!res;
  filename = dbfiles.avs.length ? dbfiles.avs[0] : "objects_avs.json.gz";
  res = requestFile(loadContext.url + filename, loadContext);
  if (res) {
    loadedDbFiles.avs[filename] = res;
  }
  success += !!res;
  filename = dbfiles.offsets.length ? dbfiles.offsets[0] : "objects_offs.json.gz";
  res = requestFile(loadContext.url + filename, loadContext);
  if (res) {
    loadedDbFiles.offsets[filename] = res;
  }
  success += !!res;
  if (success == 4) {
    propdb = new PropertyDatabase(loadedDbFiles);
    return true;
  }
  filename = "objects_attrs.json";
  res = requestFile(loadContext.url + filename, loadContext);
  loadedDbFiles.attrs[filename] = res;
  success += !!res;
  filename = "objects_vals.json";
  res = requestFile(loadContext.url + filename, loadContext);
  loadedDbFiles.values[filename] = res;
  success += !!res;
  filename = "objects_avs.json";
  res = requestFile(loadContext.url + filename, loadContext);
  loadedDbFiles.avs[filename] = res;
  success += !!res;
  filename = "objects_offs.json";
  res = requestFile(loadContext.url + filename, loadContext);
  loadedDbFiles.offsets[filename] = res;
  success += !!res;
  if (success == 4) {
    propdb = new PropertyDatabase(loadedDbFiles);
    return true;
  }
  propdbFailed = true;
  return false;
}
function doPropertyGet(_this, loadContext) {
  var dbId = loadContext.dbId;
  var result = null;
  if (loadPropertyPacks(loadContext, dbId)) {
    result = propdb.getObjectProperties(dbId);
  }
  _this.postMessage({result:result, dbId:dbId});
}
function computeTreeBBoxes(node, nodeBoxes, fragBoxes) {
  var box_offset = node.dbId * 6;
  nodeBoxes[box_offset] = nodeBoxes[box_offset + 1] = nodeBoxes[box_offset + 2] = Infinity;
  nodeBoxes[box_offset + 3] = nodeBoxes[box_offset + 4] = nodeBoxes[box_offset + 5] = -Infinity;
  var children = node.children;
  if (children) {
    for (var i = 0, iEnd = children.length;i < iEnd;i++) {
      computeTreeBBoxes(children[i], nodeBoxes, fragBoxes);
      var child_box_offset = (children[i].dbId | 0) * 6;
      for (var k = 0;k < 3;k++) {
        if (nodeBoxes[box_offset + k] > nodeBoxes[child_box_offset + k]) {
          nodeBoxes[box_offset + k] = nodeBoxes[child_box_offset + k];
        }
        if (nodeBoxes[box_offset + k + 3] < nodeBoxes[child_box_offset + k + 3]) {
          nodeBoxes[box_offset + k + 3] = nodeBoxes[child_box_offset + k + 3];
        }
      }
    }
  }
  if (node.fragIds !== undefined) {
    if (!Array.isArray(node.fragIds)) {
      var frag_box_offset = (node.fragIds | 0) * 6;
      for (var k = 0;k < 3;k++) {
        if (nodeBoxes[box_offset + k] > fragBoxes[frag_box_offset + k]) {
          nodeBoxes[box_offset + k] = fragBoxes[frag_box_offset + k];
        }
        if (nodeBoxes[box_offset + k + 3] < fragBoxes[frag_box_offset + k + 3]) {
          nodeBoxes[box_offset + k + 3] = fragBoxes[frag_box_offset + k + 3];
        }
      }
    } else {
      if (node.fragIds.length) {
        for (var j = 0;j < node.fragIds.length;j++) {
          frag_box_offset = (node.fragIds[j] | 0) * 6;
          for (var k = 0;k < 3;k++) {
            if (nodeBoxes[box_offset + k] > fragBoxes[frag_box_offset + k]) {
              nodeBoxes[box_offset + k] = fragBoxes[frag_box_offset + k];
            }
            if (nodeBoxes[box_offset + k + 3] < fragBoxes[frag_box_offset + k + 3]) {
              nodeBoxes[box_offset + k + 3] = fragBoxes[frag_box_offset + k + 3];
            }
          }
        }
      }
    }
  }
}
function buildDbIdToFragMap(fragToDbId) {
  var ret = {};
  for (var i = 0, iEnd = fragToDbId.length;i < iEnd;i++) {
    var dbId = fragToDbId[i];
    var frags = ret[dbId];
    if (frags === undefined) {
      ret[dbId] = i;
    } else {
      if (!Array.isArray(frags)) {
        ret[dbId] = [frags, i];
      } else {
        frags.push(i);
      }
    }
  }
  return ret;
}
function doObjectTreeParse(_this, loadContext) {
  if (!loadPropertyPacks(loadContext, null)) {
    _this.postMessage({instanceTree:null, maxTreeDepth:0});
    return;
  }
  var dbToFrag = buildDbIdToFragMap(loadContext.fragToDbId);
  var idroots = propdb.findRootNodes();
  var root;
  var maxDepth = [0];
  if (idroots.length == 1) {
    root = {dbId:idroots[0]};
    propdb.buildObjectTree(root, dbToFrag, 0, maxDepth);
  } else {
    root = {dbId:0, children:[]};
    for (var i = 0;i < idroots.length;i++) {
      var child = {dbId:idroots[i]};
      root.children.push(child);
      propdb.buildObjectTree(child, dbToFrag, 0, maxDepth);
    }
  }
  _this.postMessage({instanceTree:root, maxTreeDepth:maxDepth[0]});
  if (loadContext.fragBoxes) {
    var nodeBoxes = new Float32Array(6 * propdb.getObjectCount());
    computeTreeBBoxes(root, nodeBoxes, loadContext.fragBoxes);
    _this.postMessage({instanceBoxes:nodeBoxes});
  }
}
function doPropertySearch(_this, loadContext) {
  var result = [];
  if (loadPropertyPacks(loadContext, null)) {
    result = propdb.bruteForceSearch(loadContext.searchText);
  }
  _this.postMessage(result);
}
;function doGeomLoad(_this, loadContext) {
  var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
  var arrayBuffer = xhr.get(loadContext.url, loadContext.headers, "arraybuffer", null, "", loadContext.queryParams);
  if (xhr.success) {
    _this.postMessage({url:loadContext.url, workerId:loadContext.workerId, progress:0.5});
    try {
      var pfr = new PackFileReader(new Uint8Array(arrayBuffer));
    } catch (exc) {
      _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading pack file", {"url":loadContext.url, "exception":exc.toString(), "stack":exc.stack});
      _this.postMessage(null);
      return;
    }
    var raisedError = false;
    var raisedException = false;
    var msg = {"packId":loadContext.packId, "meshIndex":0, "mesh":null, "workerId":loadContext.workerId, "progress":0};
    for (var i = 0, iEnd = pfr.getEntryCounts();i < iEnd;i++) {
      try {
        var mesh = readGeometry(pfr, i, null);
      } catch (exc) {
        if (!raisedException) {
          _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading geometry", {"url":loadContext.url, "exception":exc.toString(), "stack":exc.stack});
          raisedException = true;
          raisedError = true;
        }
        var mesh = null;
      }
      msg.meshIndex = i;
      msg.mesh = mesh;
      msg.progress = 0.5 + 0.5 * ((i + 1) / iEnd);
      if (mesh) {
        if (_isIE11) {
          _this.postMessage(msg);
          continue;
        }
        var transferList = [];
        transferList.push(mesh.vb.buffer);
        _this.postMessage(msg, transferList);
      } else {
        if (!raisedError) {
          _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unable to load geometry", {"url":loadContext.url});
          raisedError = true;
        }
        _this.postMessage(msg);
      }
    }
  } else {
    _this.postMessage(null);
  }
}
;function doLoadSvf(_this, loadContext) {
  loadContext.basePath = "";
  var lastSlash = loadContext.url.lastIndexOf("/");
  if (lastSlash != -1) {
    loadContext.basePath = loadContext.url.substr(0, lastSlash + 1);
  }
  var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
  var arrayBuffer = xhr.get(loadContext.url, loadContext.headers, "arraybuffer", null, "", loadContext.queryParams);
  if (xhr.success) {
    _this.postMessage({progress:0.5});
    var svf = new Package;
    function loadDoneCallback(success) {
      if (success) {
        var msg = {"svf":svf};
        _this.postMessage(msg);
      } else {
        _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading SVF", {"url":loadContext.url});
        _this.postMessage(null);
      }
    }
    loadContext.loadDoneCB = loadDoneCallback;
    try {
      svf.load(loadContext, new Uint8Array(arrayBuffer));
    } catch (exc) {
      _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while loading SVF", {"url":loadContext.url, "exception":exc.toString(), "stack":exc.stack});
      _this.postMessage(null);
      return;
    }
  } else {
    _this.postMessage(null);
  }
}
;var ENABLE_OCTM_MG2 = false;
var IS_WORKER = typeof self !== "undefined" && typeof window === "undefined";
if (IS_WORKER) {
  var IS_CONCAT_BUILD;
  var fydo = null;
  if (!IS_CONCAT_BUILD) {
    importScripts("../AutodeskNamespace.js");
    importScripts("../compatibility.js");
    importScripts("../render/adsk_three.js");
    importScripts("../zlib/gunzip.min.js");
    importScripts("../zlib/unzip.min.js");
    if (ENABLE_OCTM_MG2) {
      importScripts("../zlib/inflate.min.js");
      importScripts("../lmvtk/octm_mg2.js");
    }
    importScripts("../lmvtk/InputStream.js");
    importScripts("../lmvtk/VbUtils.js");
    importScripts("../lmvtk/VertexBufferBuilder.js");
    importScripts("../lmvtk/PackReader.js");
    importScripts("../lmvtk/Geoms.js");
    importScripts("../lmvtk/Materials.js");
    importScripts("../lmvtk/Lights.js");
    importScripts("../lmvtk/Cameras.js");
    importScripts("../lmvtk/Fragments.js");
    importScripts("../lmvtk/Instances.js");
    importScripts("../lmvtk/Package.js");
    importScripts("../lmvtk/PackReader.js");
    importScripts("../lmvtk/Propdb.js");
    importScripts("../lmvtk/Fydo.js");
    importScripts("../lmvtk/FydoProbe.js");
    importScripts("../lmvtk/CheckedInputStream.js");
    importScripts("../net/Xhr.js");
    importScripts("GeomWorker.js");
    importScripts("SvfWorker.js");
    importScripts("PropWorker.js");
    importScripts("FydoParseWorker.js");
    importScripts("FydoStreamWorker.js");
    importScripts("CloudRenderingWorker.js");
    importScripts("../../api/Viewer.js");
    importScripts("../../api/ErrorCodes.js");
  }
  self.addEventListener("message", function(e) {
    var loadContext = e.data;
    loadContext.errorHandler = new XhrErrorHandler(self);
    var op = e.data.operation;
    if (op == "LOAD_GEOMETRY") {
      doGeomLoad(self, loadContext);
    } else {
      if (op == "LOAD_SVF") {
        doLoadSvf(self, loadContext);
      } else {
        if (op == "GET_PROPERTIES") {
          doPropertyGet(self, loadContext);
        } else {
          if (op == "SEARCH_PROPERTIES") {
            doPropertySearch(self, loadContext);
          } else {
            if (op == "GET_OBJECT_TREE") {
              doObjectTreeParse(self, loadContext);
            } else {
              if (op == "PARSE_FYDO") {
                doParseFydo(self, loadContext);
              } else {
                if (op == "PARSE_FYDO_FRAME") {
                  doParseFydoFrame(self, loadContext);
                } else {
                  if (op == "STREAM_FYDO") {
                    doStreamFydo(self, loadContext);
                  } else {
                    if (op == "CLOUD_RENDERING") {
                      doCloudRendering(self, loadContext);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }, false);
  self.raiseError = function(code, msg, args) {
    self.postMessage({"error":{"code":code, "msg":msg, "args":args}});
  };
  function requestFile(url, loadContext) {
    loadContext.errorHandler.ignoreFileNotFound = true;
    var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
    if (url.indexOf(".gz", url.length - 3) !== -1) {
      var gzbuf = xhr.get(url, loadContext.headers, "arraybuffer", null, "", loadContext.queryParams);
      if (xhr.success) {
        try {
          var rawbuf = new Uint8Array(gzbuf);
          if (rawbuf[0] == 31 && rawbuf[1] == 139) {
            rawbuf = (new Zlib.Gunzip(rawbuf)).decompress();
          }
          return rawbuf;
        } catch (e) {
          self.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Malformed data received when requesting file", {"url":url, "exception":e.toString(), "stack":e.stack});
          return null;
        }
      } else {
        return null;
      }
    } else {
      var json = xhr.get(url, loadContext.headers, "arraybuffer", null, "", loadContext.queryParams);
      if (xhr.success) {
        return new Uint8Array(json);
      } else {
        return null;
      }
    }
  }
  function debug(msg) {
    self.postMessage({debug:1, message:msg});
  }
}
;function doLoadFydo(_this, loadContext) {
  loadContext.basePath = "";
  var lastSlash = loadContext.url.lastIndexOf("/");
  if (lastSlash != -1) {
    loadContext.basePath = loadContext.url.substr(0, lastSlash + 1);
  }
  var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
  var arrayBuffer = xhr.get(loadContext.url, loadContext.headers, "arraybuffer", null, "", loadContext.queryParams);
  if (xhr.success) {
    _this.postMessage({progress:0.5});
    var fydo = new Fydo;
    function loadDoneCallback(success) {
      if (success) {
        var msg = {"fydo":fydo};
        _this.postMessage(msg);
      } else {
        _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading FYDO", {"url":loadContext.url});
        _this.postMessage(null);
      }
    }
    loadContext.loadDoneCB = loadDoneCallback;
    try {
      fydo.load(loadContext, new Uint8Array(arrayBuffer));
    } catch (exc) {
      debug("Error in fydo parsing worker : " + exc.toString() + " ; with stack trace: " + exc.stack.toString());
      _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while loading FYDO", {"url":loadContext.url, "exception":exc.toString(), "stack":exc.stack});
      _this.postMessage(null);
      return;
    }
  } else {
    _this.postMessage(null);
  }
}
function doParseFydo(_this, loadContext) {
  if (loadContext.data) {
    _this.postMessage({progress:0.5});
    var fydo = new Fydo(loadContext.metadata);
    function loadDoneCallback(success) {
      if (success) {
        var msg = {"fydo":fydo};
        _this.postMessage(msg);
      } else {
        _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading FYDO", {});
        _this.postMessage(null);
      }
    }
    loadContext.loadDoneCB = loadDoneCallback;
    try {
      fydo.load(loadContext, new Uint8Array(loadContext.data));
    } catch (exc) {
      _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while loading FYDO", {"exception":exc.toString(), "stack":exc.stack});
      _this.postMessage(null);
      return;
    }
  } else {
    _this.postMessage(null);
  }
}
function doParseFydoFrame(_this, loadContext) {
  if (loadContext.data) {
    _this.postMessage({progress:0.5});
    if (!fydo) {
      fydo = new Fydo(loadContext.metadata);
      debug("Initialize Global Fydo Object.");
    }
    function loadDoneCallback(success) {
      if (success) {
        var msg = {"fydoframe":fydo};
        _this.postMessage(msg);
      } else {
        _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading FYDO", {});
        _this.postMessage(null);
      }
    }
    loadContext.loadDoneCB = loadDoneCallback;
    try {
      fydo.loadFrames(loadContext, new Uint8Array(loadContext.data));
    } catch (exc) {
      _this.raiseError(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while loading FYDO", {"exception":exc.toString(), "stack":exc.stack});
      _this.postMessage(null);
      return;
    }
  } else {
    _this.postMessage(null);
  }
}
;function doStreamFydo(worker, loadContext) {
  var url = loadContext.url;
  loadContext.basePath = "";
  var lastSlash = loadContext.url.lastIndexOf("/");
  if (lastSlash != -1) {
    loadContext.basePath = loadContext.url.substr(0, lastSlash + 1);
  }
  var xhr = new Xhr(null, loadContext.auth, loadContext.viewing_url);
  var bubble = xhr.get(loadContext.basePath + "bubble.json", loadContext.headers, "json", null, "", loadContext.queryParams);
  var metadata = xhr.get(loadContext.basePath + "metadata.json", loadContext.headers, "json", null, "", loadContext.queryParams);
  try {
    var xhr = new XMLHttpRequest;
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    var probe = new FydoProbe;
    var counter = 0;
    xhr.onreadystatechange = function(probe, counter) {
      return function() {
        try {
          if (xhr.readyState == 4) {
            debug("total op code count yield from probing: " + probe.opCount);
            debug("fydo frame ends at offset: " + probe.frameEnd);
            var textBuffer = xhr.responseText;
            var arrayBuffer = textToArrayBuffer(textBuffer);
            var msg = {"type":"FYDOBLOB", "metadata":metadata, "buffer":arrayBuffer};
            var transferList = [];
            transferList.push(arrayBuffer);
            worker.postMessage(msg, transferList);
          }
          if (xhr.readyState > 2) {
            return;
            var offset = probe.frameEnd;
            var textBuffer = xhr.responseText;
            var arrayBuffer = textToArrayBuffer(textBuffer);
            if (!counter) {
              ++counter;
            }
            var view = new Uint8Array(arrayBuffer);
            var marker = probe.load(view, offset);
            var frames = arrayBuffer.slice(marker.frameStart, marker.frameEnd);
            var msg = {"type":"FYDOSTREAM", "frames":frames, "metadata":bubble, "frameStart":marker.frameStart, "frameEnd":marker.frameEnd};
            worker.postMessage(msg);
          }
        } catch (e) {
          debug(e.message);
        }
      };
    }(probe, counter);
    xhr.open("GET", url, true);
    xhr.send();
  } catch (e) {
    debug(e.message);
  }
}
function textToArrayBuffer(textBuffer) {
  var arrayBuffer = new ArrayBuffer(textBuffer.length);
  var ui8a = new Uint8Array(arrayBuffer, 0);
  for (var i = 0;i < textBuffer.length;i++) {
    ui8a[i] = textBuffer.charCodeAt(i) & 255;
  }
  return arrayBuffer;
}
function concatenateArrayBuffer(buffer1, buffer2) {
  var buffer = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  buffer.set(new Uint8Array(buffer1), 0);
  buffer.set(new Uint8Array(buffer2), buffer1.byteLength);
  return buffer.buffer;
}
;var defaultCloudRenderConfig = {"ConsumerServiceKey":"Viewing", "ProductVersion":"2014", "UserInfo":{"UserID":"", "EmailFlag":"true"}, "Scenes":[{"SceneInfo":{"SourceFileInfo":{"Type":"S3", "AccessLevel":"Public"}, "FileUri":"", "SceneId":"FireflyJSDefaultSceneId"}, "Renderings":[{"ImageInfo":{"Actions":["Render", "ToneMap"], "ProductionVersion":"SparkViewer", "ImageParams":{"RenderResolutionY":1500, "RenderResolutionX":2E3, "RenderImageFormat":"PNG"}, "Render":{"RenderQuality":"standard", "RenderCameraName":"", 
"RenderingType":"image", "ExposureType":"Advanced"}, "ToneMap":{"Type":"canon", "ExposureValue":8, "Highlights":0.25, "Midtones":1, "Shadows":0.2, "Whitepoint":6500, "Saturation":1}, "CameraOverride":{"Units":"MILLIMETER", "FocalDistance":0, "Aperture":0, "View":{"Eye":[-4026.55, 2722.32, -527.835], "At":[0.834734, -0.454954, -0.310218], "Up":[0.233914, -0.0868021, 0.968375]}, "Projection":{"isOrthographic":false, "Extent":1, "ImageShift":[0, 0], "NativeAspect":1}}}}]}]};
function doCloudRendering(worker, loadContext) {
  var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
  var renderConfig = defaultCloudRenderConfig;
  var camera = loadContext.camera;
  var canvas = loadContext.canvas;
  var eyeDir = new THREE.Vector3;
  eyeDir.x = camera.target.x - camera.position.x;
  eyeDir.y = camera.target.y - camera.position.y;
  eyeDir.z = camera.target.z - camera.position.z;
  eyeDir.normalize();
  var xDir = new THREE.Vector3;
  xDir.crossVectors(eyeDir, camera.up);
  xDir.normalize();
  debug("Transform: " + xDir.x + " " + xDir.y + " " + xDir.z + " " + 0 + " " + camera.up.x + " " + camera.up.y + " " + camera.up.z + " " + 0 + " " + eyeDir.x + " " + eyeDir.y + " " + eyeDir.z + " " + 0 + " " + camera.position.x + " " + camera.position.y + " " + camera.position.z + " " + 1);
  renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.Eye = [camera.position.x, camera.position.y, camera.position.z];
  renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.At = [eyeDir.x, eyeDir.y, eyeDir.z];
  renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.Up = [camera.up.x, camera.up.y, camera.up.z];
  renderConfig.Scenes[0].Renderings[0].ImageInfo.ImageParams.RenderResolutionY = canvas.height;
  renderConfig.Scenes[0].Renderings[0].ImageInfo.ImageParams.RenderResolutionY = canvas.width;
  var rads = THREE.Math.degToRad(camera.fov);
  if (rads <= 0) {
    rads = 1E-4;
  }
  renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.Projection.Extent = rads;
  debug("fov in radius = " + rads);
  debug("CameraOverrides: " + JSON.stringify(renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride));
  loadContext.headers["x-ads-mode"] = "verbatim";
  var response = xhr.post(loadContext.url, loadContext.headers, JSON.stringify(renderConfig), "text", null, "render");
  debug(response);
  var jobId = JSON.parse(response)[0].JobId;
  debug("rendering job kicked off with render job id: " + jobId);
  var msg = {"progress":"progress"};
  worker.postMessage(msg);
  var query = setInterval(function() {
    var response = xhr.get(loadContext.url, loadContext.headers, "text", null, "render", loadContext.queryParams ? loadContext.queryParams + "&jobid=" + jobId : "jobid=" + jobId);
    debug("from rendering worker : " + response);
    var result = JSON.parse(response).renderings[0];
    var jobStatus = result.JobInfo.JobStatus;
    if (jobStatus == "Complete") {
      debug("rendering job :" + jobId + " finished.");
      var renderings = {"thumbnail":result.Storage.Output.Thumbnail, "preview":result.Storage.Output.Preview, "image":result.Storage.Output.Image, "renderResolutionX":result.ImageParams.RenderResolutionX, "renderResolutionY":result.ImageParams.RenderResolutionY};
      var msg = {"renderings":renderings};
      worker.postMessage(msg);
      clearInterval(query);
    } else {
      if (jobStatus == "Error") {
        var msg = {"error":"error"};
        worker.postMessage(msg);
        clearInterval(query);
      }
    }
  }, 10 * 1E3);
}
;var Autocam = Autocam || function(camera, navApi, cameraChangedCallback, pivotDisplayCallback) {
  var cam = this;
  var cube = null;
  var dropDownMenu = null;
  var cubeContainer = null;
  var _changing = false;
  this.camera = camera;
  this.renderer = "WEBGL";
  this.startState = {};
  this.navApi = navApi;
  var startTime = Date.now();
  var deltaTime;
  var setHomeDeferred = false;
  function changed(worldUpChanged) {
    _changing = true;
    camera.target.copy(cam.center);
    camera.pivot.copy(cam.pivot);
    if (camera.worldup) {
      camera.worldup.copy(cam.sceneUpDirection);
    } else {
      camera.up.copy(cam.sceneUpDirection);
    }
    if (cameraChangedCallback) {
      cameraChangedCallback(worldUpChanged);
    }
    _changing = false;
  }
  this.showPivot = function(state) {
    if (pivotDisplayCallback) {
      pivotDisplayCallback(state);
    }
  };
  this.setViewCubeContainer = function(div) {
    cubeContainer = div;
  };
  this.setWorldUpVector = function(newUp) {
    if (_changing) {
      return;
    }
    if (newUp && (newUp.lengthSq() > 0 && !newUp.normalize().equals(this.sceneUpDirection))) {
      this.sceneUpDirection.copy(newUp);
      this.sceneFrontDirection.copy(this.getWorldFrontVector());
      this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
      if (cube) {
        requestAnimationFrame(cube.render);
      }
    }
  };
  this.getWorldUpVector = function() {
    return this.sceneUpDirection.clone();
  };
  this.getWorldRightVector = function() {
    var vec = this.sceneUpDirection.clone();
    if (Math.abs(vec.z) <= Math.abs(vec.y)) {
      vec.set(vec.y, -vec.x, 0);
    } else {
      if (vec.z >= 0) {
        vec.set(vec.z, 0, -vec.x);
      } else {
        vec.set(-vec.z, 0, vec.x);
      }
    }
    return vec.normalize();
  };
  this.getWorldFrontVector = function() {
    var up = this.getWorldUpVector();
    return up.cross(this.getWorldRightVector()).normalize();
  };
  this.goToView = function(viewVector) {
    var destination = {position:viewVector.position.clone(), up:viewVector.up.clone(), center:viewVector.center.clone(), pivot:viewVector.pivot.clone(), fov:viewVector.fov, worldUp:viewVector.worldUp.clone()};
    cam.elapsedTime = 0;
    this.animateTransition(destination);
  };
  this.setCurrentViewAsHome = function(focusFirst) {
    if (focusFirst) {
      this.navApi.setRequestFitToView(true);
      setHomeDeferred = true;
    } else {
      this.homeVector = {position:camera.position.clone(), up:camera.up.clone(), center:this.center.clone(), pivot:this.pivot.clone(), fov:camera.fov, worldUp:this.sceneUpDirection.clone()};
    }
  };
  this.setHomeViewFrom = function(camera) {
    var pivot = camera.pivot ? camera.pivot : this.center;
    var center = camera.target ? camera.target : this.pivot;
    var worldup = camera.worldup ? camera.worldup : this.sceneUpDirection;
    this.homeVector = {position:camera.position.clone(), up:camera.up.clone(), center:center.clone(), pivot:pivot.clone(), fov:camera.fov, worldUp:worldup.clone()};
    this.originalHomeVector = {position:camera.position.clone(), up:camera.up.clone(), center:center.clone(), pivot:pivot.clone(), fov:camera.fov, worldUp:worldup.clone(), worldFront:this.sceneFrontDirection.clone()};
  };
  this.goHome = function() {
    if (!this.navApi.getIsLocked()) {
      this.navApi.setPivotSetFlag(false);
      this.goToView(this.homeVector);
    }
  };
  this.resetHome = function() {
    this.homeVector.position.copy(this.originalHomeVector.position);
    this.homeVector.up.copy(this.originalHomeVector.up);
    this.homeVector.center.copy(this.originalHomeVector.center);
    this.homeVector.pivot.copy(this.originalHomeVector.pivot);
    this.homeVector.fov = this.originalHomeVector.fov;
    this.homeVector.worldUp.copy(this.originalHomeVector.worldUp);
    this.goHome();
  };
  this.getView = function() {
    return this.center.clone().sub(camera.position);
  };
  (function animate() {
    requestAnimationFrame(animate);
    var now = Date.now();
    deltaTime = now - startTime;
    startTime = now;
  })();
  this.ortho = false;
  this.center = camera.target ? camera.target.clone() : new THREE.Vector3(0, 0, 0);
  this.pivot = camera.pivot ? camera.pivot.clone() : this.center.clone();
  this.sceneUpDirection = camera.up.clone();
  this.sceneFrontDirection = this.getWorldFrontVector();
  this.dir = this.getView();
  var left = camera.up.clone().cross(this.dir).normalize();
  camera.up.copy(this.dir).cross(left).normalize();
  this.saveCenter = this.center.clone();
  this.savePivot = this.pivot.clone();
  this.saveEye = camera.position.clone();
  this.saveUp = camera.up.clone();
  var prevEye, prevCenter, prevUp, prevPivot;
  this.cubeFront = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
  this.setHomeViewFrom(camera);
  var rotInitial = new THREE.Quaternion;
  var rotFinal = new THREE.Quaternion;
  var rotTwist = new THREE.Quaternion;
  var rotSpin = new THREE.Quaternion;
  var distInitial;
  var distFinal;
  this.userPanSpeed = 0.5;
  this.userLookSpeed = 2;
  this.userHeightSpeed = 5;
  this.walkMultiplier = 1;
  this.userZoomSpeed = 1.015;
  this.orbitMultiplier = 5;
  this.currentlyAnimating = false;
  camera.keepSceneUpright = true;
  this.preserveOrbitUpDirection = true;
  this.alignOrbitUpDirection = true;
  this.constrainOrbitHorizontal = false;
  this.constrainOrbitVertical = false;
  this.doCustomOrbit = false;
  this.snapOrbitDeadZone = 0.045;
  this.snapOrbitThresholdH = this.snapOrbitThresholdV = THREE.Math.degToRad(15);
  this.snapOrbitAccelerationAX = this.snapOrbitAccelerationAY = 1.5;
  this.snapOrbitAccelerationBX = this.snapOrbitAccelerationBY = 2;
  this.snapOrbitAccelerationPointX = this.snapOrbitAccelerationPointY = 0.5;
  this.alignDirTable = new Array(26);
  this.alignDirTable[0] = new THREE.Vector3(-1, 0, 0);
  this.alignDirTable[1] = new THREE.Vector3(1, 0, 0);
  this.alignDirTable[2] = new THREE.Vector3(0, -1, 0);
  this.alignDirTable[3] = new THREE.Vector3(0, 1, 0);
  this.alignDirTable[4] = new THREE.Vector3(0, 0, -1);
  this.alignDirTable[5] = new THREE.Vector3(0, 0, 1);
  this.alignDirTable[6] = new THREE.Vector3(-1, -1, 0);
  this.alignDirTable[7] = new THREE.Vector3(-1, 1, 0);
  this.alignDirTable[8] = new THREE.Vector3(1, -1, 0);
  this.alignDirTable[9] = new THREE.Vector3(1, 1, 0);
  this.alignDirTable[10] = new THREE.Vector3(0, -1, -1);
  this.alignDirTable[11] = new THREE.Vector3(0, -1, 1);
  this.alignDirTable[12] = new THREE.Vector3(0, 1, -1);
  this.alignDirTable[13] = new THREE.Vector3(0, 1, 1);
  this.alignDirTable[14] = new THREE.Vector3(-1, 0, -1);
  this.alignDirTable[15] = new THREE.Vector3(1, 0, -1);
  this.alignDirTable[16] = new THREE.Vector3(-1, 0, 1);
  this.alignDirTable[17] = new THREE.Vector3(1, 0, 1);
  this.alignDirTable[18] = new THREE.Vector3(-1, -1, -1);
  this.alignDirTable[19] = new THREE.Vector3(-1, -1, 1);
  this.alignDirTable[20] = new THREE.Vector3(-1, 1, -1);
  this.alignDirTable[21] = new THREE.Vector3(-1, 1, 1);
  this.alignDirTable[22] = new THREE.Vector3(1, -1, -1);
  this.alignDirTable[23] = new THREE.Vector3(1, -1, 1);
  this.alignDirTable[24] = new THREE.Vector3(1, 1, -1);
  this.alignDirTable[25] = new THREE.Vector3(1, 1, 1);
  this.combined = false;
  this.useSnap = false;
  this.lockDeltaX = 0;
  this.lockedX = false;
  this.lastSnapRotateX = 0;
  this.lockDeltaY = 0;
  this.lockedY = false;
  this.lastSnapRotateY = 0;
  this.lastSnapDir = new THREE.Vector3(0, 0, 0);
  this.topLimit = false;
  this.bottomLimit = false;
  this.minSceneBound = 0;
  this.maxSceneBound = 0;
  var shotParams = {destinationPercent:1, duration:1, zoomToFitScene:true, useOffAxis:false};
  var camParamsInitial, camParamsFinal;
  this.zoomDelta = new THREE.Vector2;
  var unitAmount = 0;
  var m_resetBiasX, m_resetBiasY, m_bias;
  var boundingBoxMin = new THREE.Vector3;
  var boundingBoxMax = new THREE.Vector3;
  this.rewindParams = {history:[], startTime:undefined, thumbnailSize:56, thumbnailGapSize:12, maxHistorySize:25, snappingEnabled:true, timelineIndex:0, timelineIndexSlide:0, open:false, openLocation:new THREE.Vector2(0, 0), openBracket:new THREE.Vector2(0, 0), openBracketA:new THREE.Vector2(0, 0), openBracketB:new THREE.Vector2(0, 0), openLocationOrigin:new THREE.Vector2(0, 0), locationOffset:new THREE.Vector2(0, 0), snapOffset:new THREE.Vector2(0, 0), slideOffset:new THREE.Vector2(0, 0), snapped:true, 
  resetWeights:false, recordEnabled:false, elementIsRecording:false};
  this.viewCubeMenuOpen = false;
  this.menuSize = new THREE.Vector2(0, 0);
  this.menuOrigin = new THREE.Vector2(0, 0);
  camera.lookAt(this.center);
  this.setCube = function(viewcube) {
    cube = viewcube;
  };
  this.loadObject = function(model, scale, position) {
    loader = new THREE.JSONLoader;
    loader.load(model, function(geometry, materials) {
      var faceMaterial = new THREE.MeshPhongMaterial(materials);
      mesh = new THREE.Mesh(geometry, faceMaterial);
      mesh.scale = scale;
      mesh.position = position;
      mesh.geometry.computeBoundingBox();
      var bBox = mesh.geometry.boundingBox.clone();
      boundingBoxMax.set(bBox.max.x, bBox.max.y, bBox.max.z);
      boundingBoxMin.set(bBox.min.x, bBox.min.y, bBox.min.z);
      boundingBoxMax.multiply(scale);
      boundingBoxMin.multiply(scale);
      scene.add(mesh);
      objects.push(mesh);
    });
  };
  this.setCameraUp = function(up) {
    var view = this.dir.clone();
    var right = view.cross(up).normalize();
    if (right.lengthSq() === 0) {
      view.copy(this.dir);
      if (up.z > up.y) {
        view.y -= 1E-4;
      } else {
        view.z += 1E-4;
      }
      right = view.cross(up).normalize();
    }
    camera.up.copy(right).cross(this.dir).normalize();
  };
  this.sync = function(clientCamera) {
    camera.position.copy(clientCamera.position);
    camera.fov = clientCamera.fov;
    if (clientCamera.target) {
      this.center.copy(clientCamera.target);
    }
    if (clientCamera.pivot) {
      this.pivot.copy(clientCamera.pivot);
    }
    this.dir.copy(this.center).sub(camera.position);
    this.setCameraUp(clientCamera.up);
    var worldUp = clientCamera.worldup ? clientCamera.worldup : clientCamera.up;
    if (worldUp.distanceToSquared(this.sceneUpDirection) > 1E-4) {
      this.setWorldUpVector(worldUp);
    }
    if (setHomeDeferred && !this.navApi.getTransitionActive()) {
      setHomeDeferred = false;
      this.setCurrentViewAsHome(false);
    }
    if (cube) {
      requestAnimationFrame(cube.render);
    }
  };
  this.refresh = function() {
    if (cube) {
      cube.refreshCube();
    }
  };
  THREE.Box2.prototype.setCenter = function(center) {
    var halfSize = new THREE.Vector2(Math.abs(this.max.x - this.min.x) / 2, Math.abs(this.max.y - this.min.y) / 2);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  };
  THREE.Box2.prototype.getIcon2DCoords = function(Pscreen, PIcon2D) {
    var zero = this.center;
    PIcon2D.set((Pscreen.x - zero.x) / (this.size().x / 2), (Pscreen.y - zero.y) / (this.size().y / 2));
  };
  THREE.Matrix3.prototype.makeRotationFromQuaternion = function(q) {
    var te = this.elements;
    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[3] = xy - wz;
    te[6] = xz + wy;
    te[1] = xy + wz;
    te[4] = 1 - (xx + zz);
    te[7] = yz - wx;
    te[2] = xz - wy;
    te[5] = yz + wx;
    te[8] = 1 - (xx + yy);
    return this;
  };
  THREE.Quaternion.prototype.setFromRotationMatrix3 = function(m) {
    var te = m.elements, m11 = te[0], m12 = te[3], m13 = te[6], m21 = te[1], m22 = te[4], m23 = te[7], m31 = te[2], m32 = te[5], m33 = te[8], trace = m11 + m22 + m33, s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      this.w = 0.25 / s;
      this.x = (m32 - m23) * s;
      this.y = (m13 - m31) * s;
      this.z = (m21 - m12) * s;
    } else {
      if (m11 > m22 && m11 > m33) {
        s = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this.w = (m32 - m23) / s;
        this.x = 0.25 * s;
        this.y = (m12 + m21) / s;
        this.z = (m13 + m31) / s;
      } else {
        if (m22 > m33) {
          s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this.w = (m13 - m31) / s;
          this.x = (m12 + m21) / s;
          this.y = 0.25 * s;
          this.z = (m23 + m32) / s;
        } else {
          s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this.w = (m21 - m12) / s;
          this.x = (m13 + m31) / s;
          this.y = (m23 + m32) / s;
          this.z = 0.25 * s;
        }
      }
    }
    return this;
  };
  THREE.Quaternion.prototype.rotate = function(vector) {
    var kRot = (new THREE.Matrix4).makeRotationFromQuaternion(this);
    var e = kRot.elements;
    var viewRot = (new THREE.Matrix3).set(e[0], e[1], e[2], e[4], e[5], e[6], e[8], e[9], e[10]);
    return vector.applyMatrix3(viewRot);
  };
  THREE.Vector3.prototype.findAngleWith = function(b, axis) {
    var angle = 0;
    var cosAngle = this.clone().normalize().clone().dot(b.clone().normalize());
    var axisCheck = this.clone().cross(b).clone().normalize();
    if (axisCheck.clone().length() < Number.MIN_VALUE) {
      if (cosAngle > 0) {
        angle = 0;
      } else {
        angle = 180;
      }
    } else {
      var cosCheck = axisCheck.clone().dot(axis.clone().normalize());
      axis = cosCheck > 0 ? axisCheck : -axisCheck;
      var cosAngleNextQuadrant = (new THREE.Quaternion).setFromAxisAngle(axis, 90 * THREE.Math.degToRad);
      cosAngleNextQuadrant = cosAngleNextQuadrant.clone().rotate(b).clone().normalize().clone().dot(this);
      angle = Math.acos(cosAngle) * THREE.Math.radToDeg;
      if (Math.abs(angle - 90) < Number.MIN_VALUE) {
        angle = 90;
      }
      if (angle < 90 && cosAngle * cosAngleNextQuadrant > 0 || (angle > 90 && cosAngle * cosAngleNextQuadrant < 0 || angle == 90 && cosAngleNextQuadrant > 0)) {
        angle = -1 * angle;
      }
    }
    angle = THREE.Math.degToRad(angle);
    return angle;
  };
  if (!("contains" in String.prototype)) {
    String.prototype.contains = function(str, startIndex) {
      return-1 !== String.prototype.indexOf.call(this, str, startIndex);
    };
  }
  Math.linearClamp = function(x, a, b) {
    if (x <= a) {
      return 0;
    }
    if (x >= b) {
      return 1;
    }
    return(x - a) / (b - a);
  };
  Math.easeClamp = function(x, a, b) {
    if (x <= a) {
      return 0;
    }
    if (x >= b) {
      return 1;
    }
    var t = (x - a) / (b - a);
    return 0.5 * (Math.sin((t - 0.5) * Math.PI) + 1);
  };
  Math.linearInterp = function(t, a, b) {
    return a * (1 - t) + b * t;
  };
  Math.equalityClamp = function(x, a, b) {
    if (x <= a) {
      return a;
    }
    if (x >= b) {
      return b;
    }
    return x;
  };
  Math.round2 = function(x) {
    return Math.round(x * 100) / 100;
  };
  Math.round1 = function(x) {
    return Math.round(x * 10) / 10;
  };
  this.animateTransition = function(destination) {
    if (!destination) {
      return;
    }
    var worldUpChanged = false;
    var unitTime = 0;
    if (cam.elapsedTime >= shotParams.duration) {
      unitTime = 1;
      cam.center.copy(destination.center);
      camera.position.copy(destination.position);
      camera.up.copy(destination.up);
      camera.fov = destination.fov;
      cam.pivot.copy(destination.pivot);
      worldUpChanged = !destination.worldUp.equals(this.sceneUpDirection);
      if (worldUpChanged) {
        this.setWorldUpVector(destination.worldUp);
      }
      this.currentlyAnimating = false;
      changed(worldUpChanged);
      this.showPivot(false);
      if (cube) {
        requestAnimationFrame(cube.render);
      }
      this.addHistoryElement();
      this.navApi.setTransitionActive(false);
      return;
    }
    this.currentlyAnimating = true;
    this.showPivot(true);
    this.navApi.setTransitionActive(true);
    var tMax = shotParams.destinationPercent;
    unitTime = Math.easeClamp(cam.elapsedTime / shotParams.duration, 0, tMax);
    oneMinusTime = 1 - unitTime;
    cam.elapsedTime += deltaTime / 500;
    var center = cam.center.clone().multiplyScalar(oneMinusTime).add(destination.center.clone().multiplyScalar(unitTime));
    var position = camera.position.clone().multiplyScalar(oneMinusTime).add(destination.position.clone().multiplyScalar(unitTime));
    var up = camera.up.clone().multiplyScalar(oneMinusTime).add(destination.up.clone().multiplyScalar(unitTime));
    var pivot = camera.pivot.clone().multiplyScalar(oneMinusTime).add(destination.pivot.clone().multiplyScalar(unitTime));
    var worldUp = this.sceneUpDirection.clone().multiplyScalar(oneMinusTime).add(destination.worldUp.clone().multiplyScalar(unitTime));
    var fov = camera.fov * oneMinusTime + destination.fov * unitTime;
    cam.center.copy(center);
    camera.position.copy(position);
    camera.up.copy(up);
    camera.fov = fov;
    cam.pivot.copy(pivot);
    worldUpChanged = worldUp.distanceToSquared(this.sceneUpDirection) > 1E-4;
    if (worldUpChanged) {
      this.setWorldUpVector(worldUp);
    }
    camera.lookAt(cam.center);
    changed(worldUpChanged);
    if (cube) {
      requestAnimationFrame(cube.render);
    }
    requestAnimationFrame(function() {
      cam.animateTransition(destination);
    });
  };
  this.sphericallyInterpolateTransition = function(completionCallback) {
    var center, position, up;
    var unitTime = 0;
    this.currentlyAnimating = true;
    this.navApi.setTransitionActive(true);
    if (cam.elapsedTime >= shotParams.duration) {
      unitTime = 1;
      this.currentlyAnimating = false;
    } else {
      var tMax = shotParams.destinationPercent;
      unitTime = Math.easeClamp(cam.elapsedTime / shotParams.duration, 0, tMax);
      cam.elapsedTime += deltaTime / 500;
    }
    if (unitTime === 1) {
      position = camParamsFinal.position;
      center = camParamsFinal.center;
      up = camParamsFinal.up;
    } else {
      var M = new THREE.Matrix3;
      var rot = rotInitial.clone();
      rot.slerp(rotFinal, unitTime);
      M.makeRotationFromQuaternion(rot);
      var dist = Math.linearInterp(unitTime, distInitial, distFinal);
      var e = M.elements;
      center = camParamsInitial.center.clone().multiplyScalar(1 - unitTime).add(camParamsFinal.center.clone().multiplyScalar(unitTime));
      position = center.clone().sub((new THREE.Vector3(e[0], e[1], e[2])).multiplyScalar(dist));
      up = new THREE.Vector3(e[3], e[4], e[5]);
    }
    cam.center.copy(center);
    camera.position.copy(position);
    camera.up.copy(up);
    if (!cam.navApi.getUsePivotAlways()) {
      cam.pivot.copy(center);
    }
    camera.lookAt(cam.center);
    changed(false);
    if (cube) {
      requestAnimationFrame(cube.render);
    }
    if (this.currentlyAnimating === true) {
      this.showPivot(true);
      requestAnimationFrame(function() {
        cam.sphericallyInterpolateTransition(completionCallback);
      });
    } else {
      this.navApi.setTransitionActive(false);
      this.showPivot(false);
      this.addHistoryElement();
      if (completionCallback) {
        completionCallback();
      }
    }
  };
  this.getOrientation = function() {
    if (!cube) {
      return;
    }
    var camX = Math.round1(camera.up.x);
    var camY = Math.round1(camera.up.y);
    var camZ = Math.round1(camera.up.z);
    var sceneFront = this.sceneFrontDirection.clone();
    var sceneUp = this.sceneUpDirection.clone();
    var sceneRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
    sceneFront.x = Math.round1(sceneFront.x);
    sceneFront.y = Math.round1(sceneFront.y);
    sceneFront.z = Math.round1(sceneFront.z);
    sceneUp.x = Math.round1(sceneUp.x);
    sceneUp.y = Math.round1(sceneUp.y);
    sceneUp.z = Math.round1(sceneUp.z);
    sceneRight.x = Math.round1(sceneRight.x);
    sceneRight.y = Math.round1(sceneRight.y);
    sceneRight.z = Math.round1(sceneRight.z);
    var sceneLeft = sceneRight.clone().multiplyScalar(-1);
    var sceneDown = sceneUp.clone().multiplyScalar(-1);
    var sceneBack = sceneFront.clone().multiplyScalar(-1);
    switch(cube.currentFace) {
      case "front":
        if (sceneUp.x == camX && (sceneUp.y == camY && sceneUp.z == camZ)) {
          return "up";
        } else {
          if (sceneDown.x == camX && (sceneDown.y == camY && sceneDown.z == camZ)) {
            return "down";
          } else {
            if (sceneRight.x == camX && (sceneRight.y == camY && sceneRight.z == camZ)) {
              return "right";
            } else {
              if (sceneLeft.x == camX && (sceneLeft.y == camY && sceneLeft.z == camZ)) {
                return "left";
              }
            }
          }
        }
        break;
      case "right":
        if (sceneUp.x == camX && (sceneUp.y == camY && sceneUp.z == camZ)) {
          return "up";
        } else {
          if (sceneDown.x == camX && (sceneDown.y == camY && sceneDown.z == camZ)) {
            return "down";
          } else {
            if (sceneBack.x == camX && (sceneBack.y == camY && sceneBack.z == camZ)) {
              return "left";
            } else {
              if (sceneFront.x == camX && (sceneFront.y == camY && sceneFront.z == camZ)) {
                return "right";
              }
            }
          }
        }
        break;
      case "left":
        if (sceneUp.x == camX && (sceneUp.y == camY && sceneUp.z == camZ)) {
          return "up";
        } else {
          if (sceneDown.x == camX && (sceneDown.y == camY && sceneDown.z == camZ)) {
            return "down";
          } else {
            if (sceneFront.x == camX && (sceneFront.y == camY && sceneFront.z == camZ)) {
              return "left";
            } else {
              if (sceneBack.x == camX && (sceneBack.y == camY && sceneBack.z == camZ)) {
                return "right";
              }
            }
          }
        }
        break;
      case "back":
        if (sceneUp.x == camX && (sceneUp.y == camY && sceneUp.z == camZ)) {
          return "up";
        } else {
          if (sceneDown.x == camX && (sceneDown.y == camY && sceneDown.z == camZ)) {
            return "down";
          } else {
            if (sceneLeft.x == camX && (sceneLeft.y == camY && sceneLeft.z == camZ)) {
              return "right";
            } else {
              if (sceneRight.x == camX && (sceneRight.y == camY && sceneRight.z == camZ)) {
                return "left";
              }
            }
          }
        }
        break;
      case "top":
        if (sceneBack.x == camX && (sceneBack.y == camY && sceneBack.z == camZ)) {
          return "down";
        } else {
          if (sceneFront.x == camX && (sceneFront.y == camY && sceneFront.z == camZ)) {
            return "up";
          } else {
            if (sceneRight.x == camX && (sceneRight.y == camY && sceneRight.z == camZ)) {
              return "right";
            } else {
              if (sceneLeft.x == camX && (sceneLeft.y == camY && sceneLeft.z == camZ)) {
                return "left";
              }
            }
          }
        }
        break;
      case "bottom":
        if (sceneFront.x == camX && (sceneFront.y == camY && sceneFront.z == camZ)) {
          return "down";
        } else {
          if (sceneBack.x == camX && (sceneBack.y == camY && sceneBack.z == camZ)) {
            return "up";
          } else {
            if (sceneRight.x == camX && (sceneRight.y == camY && sceneRight.z == camZ)) {
              return "right";
            } else {
              if (sceneLeft.x == camX && (sceneLeft.y == camY && sceneLeft.z == camZ)) {
                return "left";
              }
            }
          }
        }
        break;
    }
    return;
  };
  this.resetOrientation = function() {
    this.sceneUpDirection.copy(this.originalHomeVector.worldUp);
    this.sceneFrontDirection.copy(this.originalHomeVector.worldFront);
    this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
    this.setCameraUp(this.sceneUpDirection);
    changed(true);
  };
  this.setCurrentViewAsFront = function() {
    if (cube) {
      cube.currentFace = "front";
    }
    this.sceneUpDirection.copy(camera.up.clone());
    this.sceneFrontDirection.copy(this.getView()).normalize();
    this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
    changed(true);
  };
  this.setCurrentViewAsTop = function() {
    if (cube) {
      cube.currentFace = "front";
    }
    this.sceneUpDirection.copy(this.getView()).multiplyScalar(-1).normalize();
    this.sceneFrontDirection.copy(camera.up);
    this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
    changed(true);
  };
  this.calculateCubeTransform = function(faceString) {
    var worldUp = this.sceneUpDirection.clone();
    var worldFront = this.sceneFrontDirection.clone();
    var worldRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
    camParamsInitial = camera.clone();
    camParamsInitial.center = cam.center.clone();
    camParamsInitial.pivot = cam.pivot.clone();
    camParamsFinal = camera.clone();
    camParamsFinal.center = cam.center.clone();
    camParamsFinal.pivot = cam.pivot.clone();
    var offset = new THREE.Vector3(0, 0, 0);
    if (faceString.contains("back")) {
      offset = offset.add(worldFront);
    }
    if (faceString.contains("front")) {
      offset = offset.sub(worldFront);
    }
    if (faceString.contains("top")) {
      offset = offset.add(worldUp);
    }
    if (faceString.contains("bottom")) {
      offset = offset.sub(worldUp);
    }
    if (faceString.contains("right")) {
      offset = offset.add(worldRight);
    }
    if (faceString.contains("left")) {
      offset = offset.sub(worldRight);
    }
    var upDir = worldUp;
    var test = offset.clone().normalize();
    if (1 - Math.abs(test.dot(worldUp)) < Number.MIN_VALUE) {
      var viewDir = this.getView().normalize();
      var optUpDir = [worldFront.clone(), worldFront.clone().multiplyScalar(-1), worldRight.clone(), worldRight.clone().multiplyScalar(-1)];
      var sign = test.dot(worldUp) > 0 ? +1 : -1;
      var testDir = viewDir.clone().add(camera.up.clone().multiplyScalar(sign)).normalize();
      var optValue = -2;
      for (var i = 0;i < 4;i++) {
        var value = testDir.dot(optUpDir[i]);
        if (value > optValue) {
          optValue = value;
          upDir = optUpDir[i].multiplyScalar(sign);
        }
      }
    }
    distFinal = distInitial = this.getView().length();
    camParamsFinal.position = camParamsFinal.center.clone().add(offset.normalize().multiplyScalar(distFinal));
    camParamsFinal.up = upDir;
    var D = camParamsInitial.center.clone().sub(camParamsInitial.position).normalize();
    var R = D.clone().cross(camParamsInitial.up).normalize();
    var U = R.clone().cross(D).normalize();
    var M = new THREE.Matrix3(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
    rotInitial.setFromRotationMatrix3(M);
    D = camParamsFinal.center.clone().sub(camParamsFinal.position).normalize();
    R = D.clone().cross(camParamsFinal.up).normalize();
    U = R.clone().cross(D).normalize();
    M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
    rotTwist.setFromAxisAngle(D, 0);
    rotSpin.setFromAxisAngle(U, 0);
    rotFinal.setFromRotationMatrix3(M);
    rotFinal.multiply(rotTwist).multiply(rotSpin).normalize();
  };
  this.centerShot = function(fromWheelMenu) {
    if (!camParamsInitial || fromWheelMenu) {
      cam.elapsedTime = 0;
      camParamsInitial = camParamsFinal = camera.clone();
      camParamsInitial.center = cam.center;
    }
    var pWorld = cam.pivot.clone();
    var P = pWorld.clone().sub(camParamsInitial.position);
    var D = camParamsInitial.center.clone().sub(camParamsInitial.position).normalize();
    var U = camParamsInitial.up.clone();
    var R = D.clone().cross(U).normalize();
    U = R.clone().cross(D).normalize();
    var PprojR = R.clone().multiplyScalar(R.dot(P));
    var PprojU = U.clone().multiplyScalar(U.dot(P));
    var PprojRU = PprojR.clone().add(PprojU);
    camParamsFinal.position = camParamsInitial.position.clone().add(PprojRU);
    camParamsFinal.center = pWorld;
    camParamsFinal.pivot = pWorld;
    var unitTime = 0;
    if (cam.elapsedTime >= shotParams.duration) {
      unitTime = 1;
    } else {
      var tMax = shotParams.destinationPercent;
      unitTime = Math.easeClamp(cam.elapsedTime / shotParams.duration, 0, tMax);
      cam.elapsedTime += deltaTime / 2E3;
    }
    var position = camera.position.clone().multiplyScalar(1 - unitTime).add(camParamsFinal.position.clone().multiplyScalar(unitTime));
    var center = cam.center.clone().multiplyScalar(1 - unitTime).add(camParamsFinal.center.clone().multiplyScalar(unitTime));
    var pivot = cam.pivot.clone().multiplyScalar(1 - unitTime).add(camParamsFinal.pivot.clone().multiplyScalar(unitTime));
    camera.position.copy(position);
    cam.center.copy(center);
    cam.pivot.copy(pivot);
    camera.lookAt(cam.center);
    changed(false);
    if (unitTime === 1) {
      this.addHistoryElement();
    } else {
      requestAnimationFrame(function() {
        cam.centerShot(false);
      });
    }
  };
  this.levelShot = function() {
    var view = this.getView();
    var dist = view.length();
    var worldUp = this.sceneUpDirection.clone();
    var vUp = camera.up.clone().normalize();
    var vView = view.normalize();
    var dotView = vView.dot(worldUp);
    if (1 - Math.abs(dotView) > Number.MIN_VALUE) {
      var vRight = vView.clone().cross(worldUp);
      vView = worldUp.clone().cross(vRight);
      vView.normalize();
    } else {
      vView = vUp.clone();
    }
    vView.multiplyScalar(dist);
    var destination = {center:vView.add(camera.position), up:worldUp, position:camera.position, pivot:cam.center.clone().add(vView), fov:camera.fov, worldUp:worldUp};
    cam.elapsedTime = 0;
    cam.animateTransition(destination);
  };
  this.fitToWindow = function() {
    var viewDir = this.getView();
    var upDir = camera.up.clone();
    viewDir.normalize();
    upDir.normalize();
    camParamsFinal = camera.clone();
    camParamsFinal.center = cam.center;
    upDir = getUpDirection(upDir, viewDir);
    upDir.normalize();
    camParamsFinal.up = upDir;
    var rightDir = viewDir.clone().cross(upDir);
    rightDir.normalize();
    var boxMin = boundingBoxMin.clone();
    var boxMax = boundingBoxMax.clone();
    var boxPoints = [boxMin, boxMax];
    var boxMidpoint = new THREE.Vector3(boxMax.x - boxMin.x, boxMax.y - boxMin.y, boxMax.z - boxMin.z);
    boxPoints[2] = new THREE.Vector3(boxMax.x, boxMin.y, boxMax.z);
    boxPoints[3] = new THREE.Vector3(boxMax.x, boxMin.y, boxMin.z);
    boxPoints[4] = new THREE.Vector3(boxMax.x, boxMax.y, boxMin.z);
    boxPoints[5] = new THREE.Vector3(boxMin.x, boxMax.y, boxMax.z);
    boxPoints[6] = new THREE.Vector3(boxMin.x, boxMax.y, boxMin.z);
    boxPoints[7] = new THREE.Vector3(boxMin.x, boxMin.y, boxMax.z);
    for (var j = 0;j < 8;j++) {
      var testVector = boxPoints[j].clone().sub(camera.position);
      boxPoints[j].setX(testVector.clone().dot(rightDir));
      boxPoints[j].setY(testVector.clone().dot(upDir));
      boxPoints[j].setZ(testVector.clone().dot(viewDir));
    }
    var fovTop = THREE.Math.degToRad(camera.topFov);
    var fovBottom = THREE.Math.degToRad(camera.bottomFov);
    var fovLeft = THREE.Math.degToRad(camera.leftFov);
    var fovRight = THREE.Math.degToRad(camera.rightFov);
    var BLeft, BRight, BTop, BBottom;
    BLeft = fovLeft >= 0 ? Number.MAX_VALUE : Number.MIN_VALUE;
    BRight = fovRight >= 0 ? Number.MAX_VALUE : Number.MIN_VALUE;
    BTop = fovTop >= 0 ? Number.MAX_VALUE : Number.MIN_VALUE;
    BBottom = fovBottom >= 0 ? Number.MAX_VALUE : Number.MIN_VALUE;
    var slopeRight = 1 / Math.tan(fovRight);
    var slopeLeft = -1 / Math.tan(fovLeft);
    var slopeTop = 1 / Math.tan(fovTop);
    var slopeBottom = -1 / Math.tan(fovBottom);
    for (var i = 0;i < 8;i++) {
      var testCorner = boxPoints[i].clone();
      var b = testCorner.z - slopeLeft * testCorner.x;
      BLeft = fovLeft >= 0 ? Math.min(BLeft, b) : Math.max(BLeft, b);
      b = testCorner.z - slopeRight * testCorner.x;
      BRight = fovRight >= 0 ? Math.min(BRight, b) : Math.max(BRight, b);
      b = testCorner.z - slopeTop * testCorner.y;
      BTop = fovTop >= 0 ? Math.min(BTop, b) : Math.max(BTop, b);
      b = testCorner.z - slopeBottom * testCorner.y;
      BBottom = fovBottom >= 0 ? Math.min(BBottom, b) : Math.max(BBottom, b);
    }
    var eyeX = (BRight - BLeft) / (slopeLeft - slopeRight);
    var eyeZH = slopeLeft * eyeX + BLeft;
    var eyeY = (BBottom - BTop) / (slopeTop - slopeBottom);
    var eyeZV = slopeTop * eyeY + BTop;
    var eyeZ = 0;
    if (eyeZH <= eyeZV) {
      var medianAngleV = (fovTop - fovBottom) / 2;
      if (Math.abs(medianAngleV) > Number.MIN_VALUE) {
        var medianSlopeV = 1 / Math.tan(medianAngleV);
        eyeY = eyeY - eyeZV / medianSlopeV + eyeZH / medianSlopeV;
      }
      eyeZ = eyeZH;
    } else {
      var medianAngleH = (fovRight - fovLeft) / 2;
      if (Math.abs(medianAngleH) > Number.MIN_VALUE) {
        var medianSlopeH = 1 / Math.tan(medianAngleH);
        eyeX = eyeX - eyeZH / medianSlopeH + eyeZV / medianSlopeH;
      }
      eyeZ = eyeZV;
    }
    var eyeOffset = new THREE.Vector3(eyeX, eyeY, eyeZ);
    var interim1 = rightDir.clone().multiplyScalar(eyeOffset.x);
    var interim2 = upDir.clone().multiplyScalar(eyeOffset.y);
    var interim3 = viewDir.clone().multiplyScalar(eyeOffset.z);
    eyeOffset = interim1.clone().add(interim2.clone().add(interim3));
    camParamsFinal.position.add(eyeOffset);
    var interim = boxMidpoint.clone().sub(camParamsFinal.position).dot(viewDir);
    camParamsFinal.center = camParamsFinal.position.clone().add(viewDir.multiplyScalar(interim));
    camParamsFinal.pivot = boxMidpoint.clone();
    var destination = {center:camParamsFinal.center, up:camParamsFinal.up, position:camParamsFinal.position, pivot:camParamsFinal.pivot, fov:camera.fov, worldUp:cam.sceneUpDirection.clone()};
    cam.elapsedTime = 0;
    cam.animateTransition(destination);
  };
  function getUpDirection(upDir, viewDir) {
    var upp = upDir.clone();
    if (Math.abs(upp.clone().dot(viewDir)) < Number.MIN_VALUE) {
      upp.normalize();
      return upp;
    }
    upp = getProjectionOnPlane(upDir, viewDir);
    if (upp.length() < Number.MIN_VALUE) {
      upp = getEmpiricalUpDirection(viewDir);
    }
    upp.normalize();
    return upp;
  }
  function getProjectionOnPlane(vector, normal) {
    normal.normalize();
    var projToNormal = vector.clone().dot(normal);
    var projection = normal.clone().multiplyScalar(projToNormal);
    projection = vector.clone().sub(projection);
    return projection;
  }
  function getEmpiricalUpDirection(normal) {
    var zeros = new THREE.Vector3(0, 0, 0);
    var directions = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 1, 1), new THREE.Vector3(1, 0, 1), new THREE.Vector3(1, 1, 0), new THREE.Vector3(1, 1, 1)];
    for (var i = 0;i < 7;i++) {
      if (Math.abs(directions[i].dot(normal)) < Number.MIN_VALUE) {
        zeros = directions[i];
        break;
      }
    }
    return zeros;
  }
  function convertCoordsToWindow(pixelX, pixelY) {
    var delta = new THREE.Vector2(0, 0);
    delta.x = pixelX / window.innerWidth;
    delta.y = pixelY / window.innerHeight;
    return delta;
  }
  function getScreenRay(mouse) {
    mouse.y = Math.abs(mouse.y - window.innerHeight);
    var rayOrigin, rayDirection;
    var eye = camera.position;
    var center = cam.center;
    var eyeToCenter = center.clone().sub(eye);
    var up = camera.up;
    var right = eyeToCenter.clone().cross(up);
    var dist = eyeToCenter.clone().length();
    var frustumLeft = dist * Math.tan(THREE.Math.degToRad(camera.leftFov));
    var frustumRight = dist * Math.tan(THREE.Math.degToRad(camera.rightFov));
    var frustumTop = dist * Math.tan(THREE.Math.degToRad(camera.topFov));
    var frustumBottom = dist * Math.tan(THREE.Math.degToRad(camera.bottomFov));
    var frustumWidth = frustumLeft + frustumRight;
    var frustumHeight = frustumTop + frustumBottom;
    var rightLength = mouse.x * frustumWidth / window.innerWidth;
    var centerToRightLength = rightLength - frustumLeft;
    var upLength = mouse.y * frustumHeight / window.innerHeight;
    var centerToUpLength = upLength - frustumBottom;
    up = up.clone().normalize().clone().multiplyScalar(centerToUpLength);
    right = right.clone().normalize().clone().multiplyScalar(centerToRightLength);
    if (cam.ortho) {
      rayOrigin = eye.clone().add(right).clone().add(up);
      rayDirection = eyeToCenter;
    } else {
      rayOrigin = eye;
      rayDirection = eyeToCenter.clone().add(up).clone().add(right);
    }
    return{"rayO":rayOrigin, "rayD":rayDirection};
  }
  this.updatePivotPosition = function(mouse) {
    var raycaster;
    var intersects;
    var projector = new THREE.Projector;
    var direction = new THREE.Vector3(mouse.x / window.innerWidth * 2 - 1, -(mouse.y / window.innerHeight) * 2 + 1, 0.5);
    projector.unprojectVector(direction, camera);
    raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
    intersects = raycaster.intersectObjects(objects);
    if (cam.mode == "zoom") {
      if (intersects[0] !== undefined) {
        var point = intersects[0].point;
        cam.pivot = point;
      } else {
        var result = getScreenRay(mouse);
        cam.pivot = result.rayO.clone().add(result.rayD);
      }
    } else {
      if (intersects[0] !== undefined) {
        wheel.cursorImage("pivot");
        var point = intersects[0].point;
        if (!cam.isMouseDown) {
          cam.pivot = point;
        }
      } else {
        wheel.cursorImage("SWInvalidArea");
      }
    }
  };
  function getNextRotation(rotationType, snapAngle, lastDelta) {
    var threshold, accelerationA, accelerationB, shiftZone;
    threshold = accelerationA = accelerationB = shiftZone = 0;
    var next = 0;
    var lockedAxis = null;
    var lockDelta = null;
    var deadZone = cam.snapOrbitDeadZone;
    var orbitMultiplier = cam.orbitMultiplier;
    if (rotationType == "h") {
      threshold = cam.snapOrbitThresholdH;
      accelerationA = cam.snapOrbitAccelerationAX;
      accelerationB = cam.snapOrbitAccelerationBX;
      shiftZone = 1 - cam.snapOrbitAccelerationPointX;
      lockDelta = cam.lockDeltaX;
      lockedAxis = cam.lockedX;
    } else {
      threshold = cam.snapOrbitThresholdV;
      accelerationA = cam.snapOrbitAccelerationAY;
      accelerationB = cam.snapOrbitAccelerationBY;
      shiftZone = 1 - cam.snapOrbitAccelerationPointY;
      lockDelta = cam.lockDeltaY;
      lockedAxis = cam.lockedY;
    }
    if (!lockedAxis) {
      if (Math.abs(snapAngle) > threshold) {
        next = lastDelta * orbitMultiplier;
      } else {
        if (Math.abs(snapAngle) > shiftZone * threshold) {
          if (lastDelta * snapAngle > 0) {
            next = lastDelta * orbitMultiplier * accelerationA;
          } else {
            next = lastDelta * orbitMultiplier * 1 / accelerationA;
          }
        } else {
          if (lastDelta * snapAngle > 0) {
            next = lastDelta * orbitMultiplier * accelerationB;
          } else {
            next = lastDelta * orbitMultiplier * 1 / accelerationB;
          }
        }
      }
      if (next * snapAngle > 0 && Math.abs(next) > Math.abs(snapAngle)) {
        this.lockDeltaX = this.lockDeltaY = 0;
        lockedAxis = true;
        next = snapAngle;
      }
    } else {
      lockDelta += lastDelta;
      if (lockDelta < -deadZone) {
        next = (lockDelta + deadZone) * orbitMultiplier * 1 / accelerationB;
        lockedAxis = false;
      } else {
        if (lockDelta > deadZone) {
          next = (lockDelta - deadZone) * orbitMultiplier * 1 / accelerationB;
          lockedAxis = false;
        }
      }
    }
    return next;
  }
  function getClosestAlignDir(Dv, searchPrincipal) {
    var maxAngle = -Number.MAX_VALUE;
    var maxIndex = 0;
    for (var i = 0;i < (searchPrincipal ? 6 : 26);i++) {
      var Di = cam.alignDirTable[i].clone().multiplyScalar(-1);
      Di.normalize();
      var angle = Di.dot(Dv);
      if (angle > maxAngle) {
        maxAngle = angle;
        maxIndex = i;
      }
    }
    return cam.alignDirTable[maxIndex];
  }
  function snapToClosestView(up, snapAngleh, snapAnglev) {
    if (!cam.useSnap) {
      return;
    }
    if (cam.preserveOrbitUpDirection) {
      var lastViewDir = cam.saveCenter.clone().sub(cam.saveEye).clone().normalize();
      var snapDir = getClosestAlignDir(lastViewDir, false).clone().multiplyScalar(-1).clone().normalize();
      if (Math.abs(Math.abs(lastViewDir.clone().dot(up)) - 1) < Number.MIN_VALUE) {
        snapAnglev = 0;
        var snapUp = getClosestAlignDir(cam.saveUp, true).clone().multiplyScalar(-1).clone().normalize();
        snapAngleh = cam.saveUp.findAngleWith(snapUp, up);
      } else {
        var lastViewDirProj = lastViewDir.clone().sub(up).multiplyScalar(up.clone().dot(lastViewDir));
        var snapDirProj = snapDir.clone().sub(up).multiplyScalar(up.clone().dot(snapDir));
        snapAngleh = lastViewDirProj.clone().findAngleWith(snapDirProj, up);
        var testRotate = (new THREE.Quaternion).setFromAxisAngle(up, snapAngleh);
        var transitionDir = testRotate.clone().rotate(lastViewDir);
        var transitionRight = testRotate.clone().rotate(lastViewDir.clone().cross(cam.saveUp));
        snapAnglev = transitionDir.clone().findAngleWith(snapDir, transitionRight);
      }
      if (snapDir != cam.lastSnapDir) {
        if (Math.abs(snapDir.clone().dot(up) - cam.lastSnapDir.clone().dot(up)) > Number.MIN_VALUE) {
          cam.lockedY = false;
        }
        cam.lastSnapDir = snapDir;
      }
    } else {
    }
  }
  function IsCombined() {
    return cam.combined;
  }
  function isInDeadZone(currentCursor, startCursor) {
    var deadZone = 30;
    var res = false;
    var w = window.innerWidth;
    var x = currentCursor.x % w;
    var h = window.innerHeight;
    var y = currentCursor.y % h;
    var diffX = x > 0 ? x - startCursor.x : w + x - startCursor.x;
    var diffY = y > 0 ? y - startCursor.y : h + y - startCursor.y;
    if (Math.abs(diffX) < deadZone && Math.abs(diffY) < deadZone) {
      res = true;
    }
    return res;
  }
  function GetXYAndWrapCounts(currentCursor, startCursor, wrapCount) {
    wrapCount.x = (currentCursor.x - startCursor.x) / window.innerWidth;
    currentCursor.x = startCursor.x + (currentCursor.x - startCursor.x) % window.innerWidth;
    wrapCount.y = (currentCursor.y - startCursor.y) / window.innerHeight;
    currentCursor.y = startCursor.y + (currentCursor.y - startCursor.y) % window.innerHeight;
  }
  function setBias(set, currentCursor, startCursor) {
    if (m_bias && set) {
      return;
    } else {
      if (set) {
        var deadZone = 30;
        var wrapCount = new THREE.Vector2;
        var x = currentCursor.x;
        var y = currentCursor.y;
        GetXYAndWrapCounts(currentCursor, startCursor, wrapCount);
        m_resetBiasX = window.innerWidth * wrapCount.x;
        m_resetBiasY = window.innerHeight * wrapCount.y;
        if (x < startCursor.x) {
          x = x - 2 * deadZone;
        } else {
          x = x + 2 * deadZone;
        }
        if (y < startCursor.y) {
          y = y - 2 * deadZone;
        } else {
          y = y + 2 * deadZone;
        }
      }
    }
    m_bias = set;
  }
  function checkBoundaryConditions(amount, cursorOffset, m_amount) {
    if (cursorOffset == 0) {
      return 0;
    }
    var deltaAmount = amount;
    var eye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount + deltaAmount));
    var prevEye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount));
    var eyeHeight = 0;
    var epsilon = (cam.maxSceneBound - cam.minSceneBound) / 1E3;
    if (cam.topLimit && cursorOffset > 0) {
      eyeHeight = cam.maxSceneBound - epsilon;
      cam.topLimit = false;
    } else {
      if (cam.bottomLimit && cursorOffset < 0) {
        eyeHeight = cam.minSceneBound + epsilon;
        cam.bottomLimit = false;
      } else {
        eyeHeight = eye.dot(worldUp);
      }
    }
    var prevEyeHeight = prevEye.dot(worldUp);
    if (eyeHeight < cam.minSceneBound) {
      if (prevEyeHeight < cam.minSceneBound) {
        cam.bottomLimit = true;
        deltaAmount = 0;
      }
    } else {
      if (eyeHeight > cam.maxSceneBound) {
        if (prevEyeHeight > cam.maxSceneBound) {
          cam.topLimit = true;
          deltaAmount = 0;
        }
      }
    }
    return deltaAmount;
  }
  function getMoveAmountFromCursorOffset(offset) {
    var derivedOffset = Math.pow(offset, 2);
    if (offset < 0) {
      derivedOffset = -derivedOffset;
    }
    var delta = convertCoordsToWindow(0, derivedOffset);
    var sceneHeight = cam.maxSceneBound - cam.minSceneBound;
    var p = sceneHeight * 0.01;
    delta.y *= p;
    var deltaAmount = cam.userHeightSpeed * delta.y;
    deltaAmount = checkBoundaryConditions(deltaAmount, offset, cam.m_amount);
    return deltaAmount;
  }
  this.onDrawHeight = function(mouse, pX, pY, dragged, path) {
    var sliderHeight = 86;
    var upDir = new THREE.Vector3(0, 1, 0);
    var h = camera.position.clone().dot(upDir);
    var unitHeight = Math.linearClamp(h, cam.minSceneBound, cam.maxSceneBound);
    var height = unitHeight - 0.5;
    if (cubeContainer) {
      cubeContainer.find("img#updownImageA").remove();
      cubeContainer.prepend('<img src="' + path + 'SWheighthandleA.png" id="updownImageA" style="position:fixed; z-index:9999; top:' + (pY - sliderHeight * height) + "px; left:" + pX + 'px;"/>');
      if (!dragged) {
        cubeContainer.prepend('<img src="' + path + 'SWheighthandleI.png" id="updownImageI" style="position:fixed; z-index:9998; top:' + (pY - sliderHeight * height) + "px; left:" + pX + 'px;"/>');
      }
    }
  };
  this.drawDropdownMenu = function(menuOptions, menuEnables, mousex, mousey, container, position) {
    var itemID = 0;
    if (!dropDownMenu) {
      var menuHeight = 0;
      var menuWidth = 230;
      dropDownMenu = document.createElement("ul");
      dropDownMenu.className = "dropDownMenu";
      for (var i = 0;i < menuOptions.length;i++) {
        var listItem = document.createElement("li");
        if (menuOptions[i] == null) {
          listItem.style.height = "1px";
          menuHeight += 1;
          listItem.style.backgroundColor = "#E0E0E0";
        } else {
          listItem.id = "menuItem" + itemID;
          itemID++;
          menuHeight += 25;
          listItem.className = menuEnables[i] ? "dropDownMenuItem" : "dropDownMenuItemDisabled";
          listItem.innerHTML = menuOptions[i];
        }
        dropDownMenu.appendChild(listItem);
      }
      this.menuSize.x = menuWidth;
      this.menuSize.y = menuHeight;
      dropDownMenu.style.height = menuHeight + "px";
    }
    var top = mousey - 15;
    var left = mousex + 1;
    if (left + this.menuSize.x > window.innerWidth) {
      left = mousex - this.menuSize.x - 1;
    }
    if (top + this.menuSize.y > window.innerHeight) {
      top = window.innerHeight - this.menuSize.y;
    }
    top -= position.y;
    left -= position.x;
    dropDownMenu.style.top = top + "px";
    dropDownMenu.style.left = left + "px";
    this.menuOrigin.x = left;
    this.menuOrigin.y = top;
    container.appendChild(dropDownMenu);
  };
  this.removeDropdownMenu = function(container) {
    container.removeChild(dropDownMenu);
  };
  this.startInteraction = function(x, y) {
    this.startCursor = new THREE.Vector2(x, y);
    this.startState = {saveCenter:this.center.clone(), saveEye:this.camera.position.clone(), savePivot:this.pivot.clone(), saveUp:this.camera.up.clone()};
    this.lockDeltaX = 0;
    this.lockedX = false;
    this.lastSnapRotateX = 0;
    this.lockDeltaY = 0;
    this.lockedY = false;
    this.lastSnapRotateY = 0;
    this.lastSnapDir = new THREE.Vector3(0, 0, 0);
  };
  this.orbit = function(currentCursor, startCursor, distance, startState) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    var mode = "wheel";
    if (startState) {
      mode = "cube";
    }
    if (mode == "cube") {
      this.saveCenter.copy(startState.saveCenter);
      this.saveEye.copy(startState.saveEye);
      this.savePivot.copy(startState.savePivot);
      this.saveUp.copy(startState.saveUp);
      this.useSnap = true;
      this.doCustomOrbit = true;
    } else {
      this.saveCenter.copy(this.center);
      this.savePivot.copy(this.pivot);
      this.saveEye.copy(camera.position);
      this.saveUp.copy(camera.up);
      this.useSnap = false;
      this.doCustomOrbit = false;
    }
    if (IsCombined() && prevCenter == undefined) {
      prevCenter = this.saveCenter.clone();
      prevEye = this.saveEye.clone();
      prevPivot = this.savePivot.clone();
      prevUp = this.saveUp.clone();
    }
    if (this.preserveOrbitUpDirection) {
      var delta = convertCoordsToWindow(currentCursor.x - startCursor.x, currentCursor.y - startCursor.y);
      var lastDelta = convertCoordsToWindow(distance.x, distance.y);
      var worldUp = this.sceneUpDirection.clone();
      var worldFront = this.sceneFrontDirection.clone();
      var worldRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
      var pivot = IsCombined() ? prevPivot : this.savePivot;
      var eye = IsCombined() ? prevEye : this.saveEye;
      var center = IsCombined() ? prevCenter : this.saveCenter;
      var camUp = IsCombined() ? prevUp : this.saveUp;
      var initViewDir = pivot.clone().sub(eye).normalize();
      var initViewDirV = center.clone().sub(eye).normalize();
      var initRightDir = initViewDirV.clone().cross(camUp);
      var fTargetDist = eye.clone().sub(pivot).length();
      var fTargetDistV = eye.clone().sub(center).length();
      var vLookUpdate = initViewDir.clone().multiplyScalar(-1);
      var vLookUpdateV = initViewDirV.clone().multiplyScalar(-1);
      var vRightUpdate = initRightDir;
      var vUpUpdate = camUp.clone();
      var snapAngleh = 0;
      var snapAnglev = 0;
      if (!this.constrainOrbitHorizontal) {
        var worldUpDotCamUp = worldUp.dot(this.saveUp);
        var kFlipTolerance = 0.009;
        if (worldUpDotCamUp < -kFlipTolerance) {
          delta.x = -delta.x;
          lastDelta.x = -lastDelta.x;
        }
        var dHorzAngle = 0;
        if (IsCombined()) {
          dHorzAngle = lastDelta.x * this.orbitMultiplier;
        } else {
          dHorzAngle = this.useSnap ? this.lastSnapRotateX + getNextRotation("h", snapAngleh, -lastDelta.x) : delta.x * this.orbitMultiplier;
        }
        this.lastSnapRotateX = dHorzAngle;
        var quatH = (new THREE.Quaternion).setFromAxisAngle(worldUp, -dHorzAngle);
        vLookUpdate.applyQuaternion(quatH);
        vLookUpdateV.applyQuaternion(quatH);
        vRightUpdate.applyQuaternion(quatH);
        vUpUpdate.applyQuaternion(quatH);
      }
      if (!this.constrainOrbitVertical) {
        var vRightProjF = worldFront.clone().multiplyScalar(worldFront.dot(vRightUpdate));
        var vRightProjR = worldRight.clone().multiplyScalar(worldRight.dot(vRightUpdate));
        var vRightProj = vRightProjF.clone().add(vRightProjR);
        vRightProj.clone().normalize();
        var dVertAngle = 0;
        if (IsCombined()) {
          dVertAngle = lastDelta.y * this.orbitMultiplier;
        } else {
          var next = getNextRotation("v", snapAnglev, lastDelta.y);
          dVertAngle = this.useSnap ? this.lastSnapRotateY + next : delta.y * this.orbitMultiplier;
        }
        var quatV = (new THREE.Quaternion).setFromAxisAngle(vRightProj, -dVertAngle);
        if (!this.navApi.getOrbitPastWorldPoles()) {
          var vUpUpdateTemp = vUpUpdate.clone();
          vUpUpdateTemp.applyQuaternion(quatV).normalize();
          var wDotC = worldUp.dot(vUpUpdateTemp);
          if (wDotC < 0) {
            var vLookUpdateVtemp = vLookUpdateV.clone();
            vLookUpdateVtemp.applyQuaternion(quatV).normalize();
            var dVertAngle2 = vLookUpdateVtemp.angleTo(worldUp);
            if (Math.abs(dVertAngle2) > Math.PI * 0.5) {
              dVertAngle2 -= dVertAngle2 > 0 ? Math.PI : -Math.PI;
            }
            dVertAngle -= dVertAngle2;
            quatV.setFromAxisAngle(vRightProj, -dVertAngle);
            vLookUpdate.applyQuaternion(quatV).normalize();
            vLookUpdateV.applyQuaternion(quatV).normalize();
            vUpUpdate.applyQuaternion(quatV).normalize();
          } else {
            vLookUpdate.applyQuaternion(quatV).normalize();
            vLookUpdateV.applyQuaternion(quatV).normalize();
            vUpUpdate.applyQuaternion(quatV).normalize();
          }
        } else {
          vLookUpdate.applyQuaternion(quatV).normalize();
          vLookUpdateV.applyQuaternion(quatV).normalize();
          vUpUpdate.applyQuaternion(quatV).normalize();
        }
        this.lastSnapRotateY = dVertAngle;
      }
      var vNewEye = vLookUpdate.multiplyScalar(fTargetDist).add(pivot);
      camera.position.copy(vNewEye);
      camera.up.copy(vUpUpdate);
      this.center.copy(vNewEye);
      this.center.sub(vLookUpdateV.multiplyScalar(fTargetDistV));
      if (IsCombined()) {
        prevCenter.copy(this.center);
        prevEye.copy(camera.position);
        prevPivot.copy(this.pivot);
        prevUp.copy(camera.up);
      }
    } else {
    }
    camera.lookAt(this.center);
    changed(false);
  };
  this.look = function(distance) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    var delta = convertCoordsToWindow(distance.x, distance.y);
    var multiplier = this.userLookSpeed;
    var eyeToCenter = this.getView();
    var camUp = camera.up;
    var camRight = eyeToCenter.clone().cross(camUp);
    var angle = delta.clone().multiplyScalar(multiplier);
    var qRotY = (new THREE.Quaternion).setFromAxisAngle(camRight.normalize(), angle.y);
    eyeToCenter = qRotY.clone().rotate(eyeToCenter);
    camUp = qRotY.clone().rotate(camUp);
    camUp.normalize();
    var worldUp = this.sceneUpDirection.clone();
    var vertAxis = camera.keepSceneUpright ? worldUp : camUp;
    var qRotX = (new THREE.Quaternion).setFromAxisAngle(vertAxis, -angle.x);
    eyeToCenter = qRotX.clone().rotate(eyeToCenter);
    camUp = qRotX.clone().rotate(camUp);
    this.center = camera.position.clone().add(eyeToCenter);
    camera.up = camUp;
    camera.lookAt(this.center);
    changed(false);
  };
  this.pan = function(distance) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    distance = convertCoordsToWindow(distance.x, distance.y);
    var W = this.getView();
    var U = camera.up.clone().cross(W);
    var V = W.clone().cross(U);
    U.normalize();
    V.normalize();
    W.normalize();
    var Pscreen = this.pivot.clone().sub(camera.position);
    var screenW = W.clone().dot(Pscreen);
    var screenU = screenW * (Math.tan(THREE.Math.degToRad(camera.leftFov)) + Math.tan(THREE.Math.degToRad(camera.rightFov)));
    var screenV = screenW * (Math.tan(THREE.Math.degToRad(camera.topFov)) + Math.tan(THREE.Math.degToRad(camera.bottomFov)));
    var offsetU = distance.x * Math.abs(screenU);
    var offsetV = distance.y * Math.abs(screenV);
    var offset = new THREE.Vector3;
    var u = U.clone().multiplyScalar(offsetU);
    var v = V.clone().multiplyScalar(offsetV);
    offset = u.clone().add(v).clone().multiplyScalar(this.userPanSpeed);
    camera.position.add(offset);
    this.center.add(offset);
    camera.lookAt(this.center);
    changed(false);
  };
  this.zoom = function(zoomDelta) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    var zoomMin = 0.05;
    var zoomBase = this.userZoomSpeed;
    var distMax = Number.MAX_VALUE;
    var deltaXY = zoomDelta.x + zoomDelta.y;
    var dist = Math.pow(zoomBase, deltaXY);
    var zoomPosition = this.pivot.clone().sub(this.pivot.clone().sub(this.saveEye).clone().multiplyScalar(dist));
    var zoomCenter = zoomPosition.clone().add(cam.D.clone().multiplyScalar(cam.D.clone().dot(this.pivot.clone().sub(zoomPosition).clone())));
    if (dist >= distMax) {
      return;
    }
    if (deltaXY > 0) {
      var snapSize = 0;
      var dist2 = Math.pow(zoomBase, deltaXY - snapSize);
      if (deltaXY < snapSize) {
        unitAmount = 0;
        return;
      } else {
        camera.position = zoomPosition;
        this.center = zoomCenter;
        var EprojD = zoomPosition.clone().sub(this.saveEye).dot(cam.D);
        if (EprojD > distMax) {
          camera.position = this.saveEye.sub(cam.D).clone().multiplyScalar(distMax);
          unitAmount = distMax > 0 ? -1 : 0;
        } else {
          unitAmount = -(EprojD / distMax);
        }
      }
    } else {
      camera.position = zoomPosition;
      this.center = zoomCenter;
    }
    camera.lookAt(this.center);
    changed(false);
  };
  this.walk = function(currentCursor, startCursor, movementX, movementY, deltaTime) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    var worldUp = this.sceneUpDirection.clone();
    var worldFront = this.sceneFrontDirection.clone();
    var worldRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection);
    var flyPlanarMotion = true;
    var flyUpDownSensitivity = 0.01;
    if (isInDeadZone(currentCursor, startCursor)) {
      wheel.cursorImage("SWWalk");
      setBias(true, currentCursor, startCursor);
      x = startCursor.x;
      y = startCursor.y;
    } else {
      setBias(false, currentCursor, startCursor);
    }
    x = currentCursor.x;
    y = currentCursor.y;
    var delta = convertCoordsToWindow(x - startCursor.x, y - startCursor.y);
    var fInitialMoveX = -delta.x;
    var fInitialMoveY = -delta.y;
    var fSignX = fInitialMoveX < 0 ? -1 : 1;
    var fSignY = fInitialMoveY < 0 ? -1 : 1;
    var fMoveX = Math.abs(fInitialMoveX);
    var fMoveY = Math.abs(fInitialMoveY);
    var deadzoneRadius = new THREE.Vector2(30, 30);
    deadzoneRadius = convertCoordsToWindow(deadzoneRadius.x, deadzoneRadius.y);
    fMoveX = isInDeadZone(currentCursor, startCursor) ? 0 : Math.abs(fInitialMoveX) - deadzoneRadius.x;
    fMoveY = isInDeadZone(currentCursor, startCursor) ? 0 : Math.abs(fInitialMoveY) - deadzoneRadius.y;
    var rampRadius = 0.25;
    fMoveX /= rampRadius;
    fMoveY /= rampRadius;
    fMoveX = fMoveX < 1 ? Math.easeClamp(fMoveX, 0, 1) : Math.pow(fMoveX, 1);
    fMoveY = fMoveY < 1 ? Math.easeClamp(fMoveY, 0, 1) : Math.pow(fMoveY, 1);
    var fDeltaX = fMoveX > 0 ? fMoveX * fSignX : 0;
    var fDeltaY = fMoveY > 0 ? fMoveY * fSignY : 0;
    var vViewDir = this.getView();
    var fViewDist = vViewDir.length();
    vViewDir.normalize();
    var vRightDir = vViewDir.clone().cross(camera.up);
    vRightDir.normalize();
    var vYViewDirRight = worldRight.clone().multiplyScalar(worldRight.clone().dot(vViewDir));
    var vYviewDirFront = worldFront.clone().multiplyScalar(worldFront.clone().dot(vViewDir));
    var vYViewDir = vYviewDirFront.clone().add(vYViewDirRight);
    vYViewDir = vYViewDir.clone().length() > Number.MIN_VALUE ? vYViewDir.normalize() : camera.up;
    var scale = 1;
    var fDollyDist = fDeltaY * (this.walkMultiplier * scale);
    var dir = flyPlanarMotion ? vYViewDir : vViewDir;
    if (flyPlanarMotion) {
      var dDirThreshold = Math.cos(0.65);
      if (dDirThreshold != 1 && (worldUp.clone().dot(camera.up) < -Number.MIN_VALUE && worldUp.clone().dot(vViewDir) < -dDirThreshold || worldUp.clone().dot(camera.up) > Number.MIN_VALUE && worldUp.clone().dot(vViewDir) > dDirThreshold)) {
        dir = -dir;
      }
    }
    var fSpinAngle = -fDeltaX * this.walkMultiplier * 0.05;
    var vRotAxis = camera.up;
    if (flyPlanarMotion) {
      if (worldUp.clone().dot(camera.up) < -Number.MIN_VALUE || Math.abs(worldUp.clone().dot(camera.up)) < Number.MIN_VALUE && worldUp.clone().dot(vViewDir) > Number.MIN_VALUE) {
        fSpinAngle = -fSpinAngle;
      }
      vRotAxis = worldUp;
    }
    var quat = (new THREE.Quaternion).setFromAxisAngle(vRotAxis, fSpinAngle);
    quat.normalize();
    vViewDir = quat.clone().rotate(vViewDir);
    vViewDir.normalize();
    camera.up = quat.clone().rotate(camera.up);
    camera.up.normalize();
    camera.position.add(dir.clone().multiplyScalar(fDollyDist));
    this.center = camera.position.clone().add(vViewDir.clone().multiplyScalar(fViewDist));
    dir = flyPlanarMotion ? worldUp : camera.up;
    dir.normalize();
    if (fDollyDist == 0) {
      fDollyDist = flyUpDownSensitivity;
    }
    camera.lookAt(this.center);
    changed(false);
  };
  this.updown = function(movementY) {
    if (this.navApi.getIsLocked()) {
      return;
    }
    var deltaCursor = movementY;
    var deltaAmount = getMoveAmountFromCursorOffset(deltaCursor);
    cam.m_amount += deltaAmount;
    var upDir = new THREE.Vector3(0, 1, 0);
    var eye = cam.saveEye.clone().sub(upDir.clone().multiplyScalar(cam.m_amount));
    var eyeHeight = eye.clone().dot(upDir);
    camera.position = eye;
    if (eyeHeight < cam.minSceneBound) {
      camera.position.add(upDir.clone().multiplyScalar(cam.minSceneBound - eyeHeight));
    }
    if (eyeHeight > cam.maxSceneBound) {
      camera.position.add(upDir.clone().multiplyScalar(cam.maxSceneBound - eyeHeight));
    }
    this.center = camera.position.clone().add(cam.saveCenter.clone().sub(cam.saveEye));
    camera.lookAt(this.center);
    changed(false);
  };
  this.addHistoryElement = function() {
  };
  this.addIntermediateHistoryElement = function() {
    if (this.rewindParams.snapped) {
      this.rewindParams.history = this.rewindParams.history.slice(0, this.rewindParams.timelineIndex);
    } else {
      if (this.rewindParams.slideOffset.x > 0) {
        this.rewindParams.history = this.rewindParams.history.slice(0, this.rewindParams.timelineIndex);
      } else {
        this.rewindParams.history = this.rewindParams.history.slice(0, this.rewindParams.timelineIndex + 1);
      }
    }
    this.addHistoryElement();
  };
  this.clearHistory = function() {
    this.rewindParams.history.length = 0;
    this.rewindParams.timelineIndex = 0;
    this.rewindParams.timelineIndexSlide = 0;
    this.rewindParams.resetWeights = true;
  };
  this.openTimeline = function(location) {
    this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
    if (this.rewindParams.resetWeights) {
      this.rewindParams.slideOffset.x = 0;
      this.rewindParams.snapped = this.rewindParams.snappingEnabled;
    }
    if (this.rewindParams.history.length == 0) {
      this.addHistoryElement();
    }
    for (var i = 0;i < this.rewindParams.history.length;i++) {
      var index = i - this.rewindParams.timelineIndex;
      var size = this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize;
      this.rewindParams.history[i].thumbnailBounds.setCenter((new THREE.Vector2(location.x + index * size, location.y)).add(this.rewindParams.slideOffset));
      if (this.rewindParams.resetWeights) {
        this.rewindParams.history[i].weight = i == this.rewindParams.timelineIndex ? 1 : 0;
      }
    }
    if (this.rewindParams.resetWeights) {
      this.rewindParams.resetWeights = false;
    }
    var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2;
    this.rewindParams.open = true;
    this.rewindParams.openLocation = location.clone();
    this.rewindParams.openLocationOrigin = location.clone();
    this.rewindParams.openBracket = location.clone();
    this.rewindParams.openBracketA = new THREE.Vector2(size, location.y);
    this.rewindParams.openBracketB = new THREE.Vector2(window.innerWidth - size, location.y);
    if (this.rewindParams.openBracketA.x > this.rewindParams.openBracketB.x) {
      var swap = this.rewindParams.openBracketA.x;
      this.rewindParams.openBracketA.x = this.rewindParams.openBracketB.x;
      this.rewindParams.openBracketB.x = swap;
    }
    this.rewindParams.locationOffset = new THREE.Vector2(0, 0);
    this.rewindParams.snapOffset = new THREE.Vector2(0, 0);
  };
  this.slideTimeline = function(location_) {
    if (!this.rewindParams.open || this.rewindParams.history.length == 0) {
      return;
    }
    var location = location_.clone().add(this.rewindParams.locationOffset);
    var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2;
    var bracketA = size;
    var bracketB = window.innerWidth - size;
    var edgeA = this.rewindParams.history[0].thumbnailBounds.center().x;
    var edgeB = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
    var extent = 0;
    if (location.x < this.rewindParams.openBracketA.x) {
      extent = location.x - this.rewindParams.openBracketA.x;
      var edgeAnew = edgeA - extent;
      if (bracketA < edgeAnew) {
        extent = Math.min(extent + (edgeAnew - bracketA), 0);
      }
    }
    if (location.x > this.rewindParams.openBracketB.x) {
      extent = location.x - this.rewindParams.openBracketB.x;
      var edgeBnew = edgeB - extent;
      if (bracketB > edgeBnew) {
        extent = Math.max(extent + (edgeBnew - bracketB), 0);
      }
    }
    this.rewindParams.openLocation.x += extent;
    this.rewindParams.openBracketA.x += extent;
    this.rewindParams.openBracketB.x += extent;
    this.rewindParams.openBracket.x = location.x - (this.rewindParams.openLocation.x - this.rewindParams.openLocationOrigin.x);
    var iconOffset = new THREE.Vector2(-extent, 0);
    var L = location.clone().sub(this.rewindParams.openLocation.clone().sub(this.rewindParams.openLocationOrigin));
    iconOffset.x += this.rewindParams.snapOffset.x;
    this.rewindParams.snapOffset.x = 0;
    var snapped = false;
    if (this.rewindParams.snappingEnabled) {
      var kEnterSnapDistance = 4;
      var kLeaveSnapDistance = 16;
      for (var i = 0;i < this.rewindParams.history.length;i++) {
        var P = this.rewindParams.history[i].thumbnailBounds.center().add(iconOffset);
        if (Math.abs(P.x - L.x) < kEnterSnapDistance || this.rewindParams.snapped && Math.abs(P.x - L.x) < kLeaveSnapDistance) {
          snapped = true;
          if (extent != 0) {
            this.rewindParams.snapOffset.x = P.x - L.x;
            iconOffset.x -= this.rewindParams.snapOffset.x;
          } else {
            this.rewindParams.openBracket.x += P.x - L.x;
          }
          L.x = P.x;
          break;
        }
      }
    }
    this.rewindParams.snapped = snapped;
    var weightMax = -1;
    var weightTotal = 0;
    for (var j = 0;j < this.rewindParams.history.length;j++) {
      var tempBox = this.rewindParams.history[j].thumbnailBounds.clone();
      this.rewindParams.history[j].thumbnailBounds.setCenter(this.rewindParams.history[j].thumbnailBounds.center().add(iconOffset));
      if (this.rewindParams.history[j].thumbnail) {
        var leftEdge = this.rewindParams.history[j].thumbnailBounds.center().x - this.rewindParams.thumbnailSize / 2;
        $("#rewindFrame" + j).css("left", leftEdge);
        $("#rewindBorder" + j).css("left", leftEdge - 4);
      }
      var newSize = new THREE.Vector2((this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2, (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2);
      tempBox.setFromCenterAndSize(tempBox.center(), newSize);
      var Icon2DCoords = new THREE.Vector2(0, 0);
      tempBox.getIcon2DCoords(L, Icon2DCoords);
      var weight = 1 - Math.abs(Math.equalityClamp(Icon2DCoords.x, -1, 1));
      this.rewindParams.history[j].weight = weight;
      if (j == 0 && L.x < tempBox.center().x) {
        this.rewindParams.history[j].weight = 1;
      }
      if (j == this.rewindParams.history.length - 1 && L.x > tempBox.center().x) {
        this.rewindParams.history[j].weight = 1;
      }
      weightTotal = weightTotal + this.rewindParams.history[j].weight;
      if (this.rewindParams.history[j].weight > weightMax) {
        weightMax = this.rewindParams.history[j].weight;
        if (this.rewindParams.snappingEnabled && this.rewindParams.history[j].weight == 1) {
          this.rewindParams.slideOffset.x = 0;
          this.rewindParams.snapped = true;
        } else {
          this.rewindParams.slideOffset.x = this.rewindParams.history[j].thumbnailBounds.center().x - L.x;
        }
        this.rewindParams.timelineIndexSlide = j;
      }
    }
    for (var k = 0;k < this.rewindParams.history.length;k++) {
      this.rewindParams.history[k].weight = this.rewindParams.history[k].weight / weightTotal;
    }
    var xBracketMin = this.rewindParams.history[0].thumbnailBounds.center().x;
    var xBracketMax = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
    if (this.rewindParams.openBracket.x < xBracketMin) {
      this.rewindParams.locationOffset.x += xBracketMin - this.rewindParams.openBracket.x;
      this.rewindParams.openBracket.x = xBracketMin;
    } else {
      if (this.rewindParams.openBracket.x > xBracketMax) {
        this.rewindParams.locationOffset.x += xBracketMax - this.rewindParams.openBracket.x;
        this.rewindParams.openBracket.x = xBracketMax;
      }
    }
  };
  this.shiftBackOneElement = function() {
    if (this.rewindParams.history.length != 0 && (this.rewindParams.timelineIndex > 0 || this.rewindParams.slideOffset.x != 0)) {
      if (this.rewindParams.snapped || this.rewindParams.slideOffset.x > 0) {
        this.rewindParams.timelineIndex--;
      }
      this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
      this.rewindParams.resetWeights = true;
      cam.elapsedTime = 0;
      this.animateToRewindIndex();
    }
  };
  this.animateToRewindIndex = function() {
    var currentTimelineIndex = this.rewindParams.timelineIndex;
    var unitTime = 0;
    if (cam.elapsedTime >= shotParams.duration) {
      unitTime = 1;
    } else {
      var tMax = shotParams.destinationPercent;
      unitTime = Math.easeClamp(cam.elapsedTime / shotParams.duration, 0, tMax);
      cam.elapsedTime += deltaTime / 500;
    }
    cam.center = cam.center.clone().multiplyScalar(1 - unitTime).clone().add(this.rewindParams.history[currentTimelineIndex].camera.center.clone().multiplyScalar(unitTime));
    camera.position = camera.position.clone().multiplyScalar(1 - unitTime).clone().add(this.rewindParams.history[currentTimelineIndex].camera.position.clone().multiplyScalar(unitTime));
    camera.up = this.rewindParams.history[currentTimelineIndex].camera.up;
    cam.pivot = cam.center;
    camera.lookAt(cam.center);
    changed(false);
    if (cube) {
      requestAnimationFrame(cube.render);
    }
    if (unitTime !== 1) {
      requestAnimationFrame(function() {
        cam.animateToRewindIndex();
      });
    }
  };
  this.closeTimeline = function() {
    if (this.rewindParams.timelineIndex != this.rewindParams.timelineIndexSlide) {
      this.rewindParams.timelineIndex = this.rewindParams.timelineIndexSlide;
    }
    this.rewindParams.open = false;
  };
  this.getInterpolatedCamera = function() {
    var interpolatedCam = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1E4);
    interpolatedCam.center = new THREE.Vector3(0, 0, 0);
    interpolatedCam.pivot = new THREE.Vector3(0, 0, 0);
    interpolatedCam.leftFov = 0;
    interpolatedCam.rightFov = 0;
    interpolatedCam.topFov = 0;
    interpolatedCam.bottomFov = 0;
    interpolatedCam.up.set(0, 0, 0);
    for (var i = 0;i < this.rewindParams.history.length;i++) {
      var frameCam = this.rewindParams.history[i].camera;
      var wi = this.rewindParams.history[i].weight;
      interpolatedCam.center.add(frameCam.center.clone().multiplyScalar(wi));
      interpolatedCam.position.add(frameCam.position.clone().multiplyScalar(wi));
      interpolatedCam.up.add(frameCam.up.clone().multiplyScalar(wi));
      interpolatedCam.rotation.add(frameCam.rotation.clone().multiplyScalar(wi));
      interpolatedCam.pivot.add(frameCam.pivot.clone().multiplyScalar(wi));
      interpolatedCam.leftFov += frameCam.leftFov * wi;
      interpolatedCam.rightFov += frameCam.rightFov * wi;
      interpolatedCam.topFov += frameCam.topFov * wi;
      interpolatedCam.bottomFov += frameCam.bottomFov * wi;
    }
    camera.position = interpolatedCam.position;
    camera.up = interpolatedCam.up;
    camera.rotation = interpolatedCam.rotation;
    camera.leftFov = interpolatedCam.leftFov;
    camera.rightFov = interpolatedCam.rightFov;
    camera.topFov = interpolatedCam.topFov;
    camera.bottomFov = interpolatedCam.bottomFov;
    cam.center = interpolatedCam.center;
    cam.pivot = interpolatedCam.pivot;
    camera.lookAt(cam.center);
    camera.up.normalize();
    changed(false);
  };
};
Autocam.ViewCube = function(tagId, autocam, cubeContainer) {
  var self = this;
  var cam = autocam;
  var camera = autocam.camera;
  autocam.setCube(this);
  var path = RESOURCE_ROOT + "textures/";
  self.currentFace = "front";
  var edgeNames = ["top,front", "top right", "top,left", "top,back", "bottom,front", "bottom,right", "bottom,left", "bottom,back", "left,front", "front,right", "right,back", "back,left"];
  var cornerNames = ["front,top,right", "back,top,right", "front,top,left", "back,top,left", "front,bottom,right", "back,bottom,right", "front,bottom,left", "back,bottom,left"];
  var menuOptionList = ["Go Home", null, "Orthographic", "Perspective", "Perspective with Ortho Faces", null, "Set current view as Home", "Focus and set as Home", "Reset Home", null, "Set current view as Front", "Set current view as Top", "Reset orientation"];
  var menuEnableList = [true, null, false, true, false, null, true, true, true, null, true, true, true];
  var shadowScene, cubeScene, gridScene, lineScene, controlScene;
  var renderer;
  var controlCamera;
  self.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2E3);
  self.camera.position.copy(camera.position);
  self.center = new THREE.Vector3(0, 0, 0);
  self.camera.lookAt(self.center);
  var cube, line, cubeGroup, home, shadow, context;
  var gridMeshes = [];
  var arrowGroup;
  var windowHalfX;
  var windowHalfY;
  var faceMapMaterials = [];
  var arrowBuffer = [];
  var intersectsFace = [];
  var controlBuffer = [];
  var cubeBuffer = [];
  var INTERSECTED = null;
  var INTERSECTED_F = null;
  var INTERSECTED_C = null;
  var cubeSize = 0;
  var position;
  var loadedTextureCount = 0;
  var _orthogonalView = true;
  var _havePointerLockFeature = false;
  var _havePointerLock = false;
  var _pointerLockMoveBugSPK865 = false;
  var _isChrome = navigator.userAgent.search("Chrome") != -1;
  var _isWindows = navigator.platform.search("Win32") != -1;
  var _dragged = false;
  var _transparent = false;
  var changingTextures = [];
  this.width = 0;
  this.height = 0;
  this.animSpeed = 500;
  this.animate = true;
  this.compass = false;
  this.viewScaleFactorCompass = 1.5;
  this.viewScale = 1;
  this.draggable = true;
  this.wantHomeButton = false;
  this.wantRollArrows = true;
  this.wantContextMenu = true;
  this.inactiveOpacity = 0.5;
  var getPosition = function(element) {
    var rect = element.getBoundingClientRect();
    return{x:rect.left, y:rect.top, w:rect.width, h:rect.height};
  };
  var pointerLockChange = function(e) {
    e.preventDefault();
    e.stopPropagation();
    _havePointerLock = document.pointerLockElement === cubeContainer || (document.mozPointerLockElement === cubeContainer || document.webkitPointerLockElement === cubeContainer);
  };
  var Init = function() {
    var bounds = cubeContainer.getBoundingClientRect();
    self.width = bounds.width;
    self.height = bounds.height;
    position = getPosition(cubeContainer);
    windowHalfX = self.width / 2;
    windowHalfY = self.height / 2;
    controlCamera = new THREE.PerspectiveCamera(70, self.height / self.width, 1, 1E4);
    controlCamera.position.set(0, 0, 500);
    shadowScene = new THREE.Scene;
    cubeScene = new THREE.Scene;
    gridScene = new THREE.Scene;
    lineScene = new THREE.Scene;
    controlScene = new THREE.Scene;
    _orthogonalView = true;
    cubeSize = 200;
    self.viewScale = cubeSize * 3.5;
    var filteringType = THREE.LinearFilter;
    var texture = [];
    texture.push(loadTexture(path + "VCface4.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[0], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    texture.push(loadTexture(path + "VCface5.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[1], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    texture.push(loadTexture(path + "VCface1.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[2], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    texture.push(loadTexture(path + "VCface2.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[3], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    texture.push(loadTexture(path + "VCface3.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[4], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    texture.push(loadTexture(path + "VCface6.png"));
    faceMapMaterials.push(new THREE.MeshBasicMaterial({map:texture[5], overdraw:false, shading:THREE.SmoothShading, transparent:true, wireframe:false}));
    for (var i = 0;i < texture.length;i++) {
      texture[i].minFilter = texture[i].maxFilter = filteringType;
    }
    var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 5, 5, 5);
    var cubeLine = new THREE.BoxGeometry(cubeSize + 1, cubeSize + 1, cubeSize + 1, 5, 5, 5);
    cube = new THREE.Mesh(cubeGeometry, new THREE.MeshFaceMaterial(faceMapMaterials));
    cube.position.set(0, 0, 0);
    var borderTexture = loadTexture(path + "VCedge1.png");
    borderTexture.minFilter = borderTexture.maxFilter = filteringType;
    line = new THREE.Mesh(cubeLine, new THREE.MeshBasicMaterial({map:borderTexture, overdraw:false, transparent:true, shading:THREE.SmoothShading}));
    line.position.set(0, 0, 0);
    cubeGroup = new THREE.Object3D;
    cubeGroup.add(cube);
    cubeScene.add(cubeGroup);
    lineScene.add(line);
    var arrowDist = cubeSize;
    var arrowGeo = new THREE.Geometry;
    var v1 = new THREE.Vector3(-30, 0, 0);
    var v2 = new THREE.Vector3(30, 0, 0);
    var v3 = new THREE.Vector3(0, -30, 0);
    arrowGeo.vertices.push(v1);
    arrowGeo.vertices.push(v2);
    arrowGeo.vertices.push(v3);
    arrowGeo.faces.push(new THREE.Face3(1, 0, 2));
    arrowGeo.computeFaceNormals();
    var arrowMaterial1 = new THREE.MeshBasicMaterial({overdraw:true, color:14540253, transparent:true, opacity:1, shading:THREE.FlatShading});
    var arrowMaterial2 = new THREE.MeshBasicMaterial({overdraw:true, color:14540253, transparent:true, opacity:1, shading:THREE.FlatShading});
    var arrowMaterial3 = new THREE.MeshBasicMaterial({overdraw:true, color:14540253, transparent:true, opacity:1, shading:THREE.FlatShading});
    var arrowMaterial4 = new THREE.MeshBasicMaterial({overdraw:true, color:14540253, transparent:true, opacity:1, shading:THREE.FlatShading});
    var upArrow = new THREE.Mesh(arrowGeo, arrowMaterial1);
    upArrow.position.set(0, arrowDist, 0);
    var downArrow = new THREE.Mesh(arrowGeo, arrowMaterial2);
    downArrow.position.set(0, -arrowDist, 0);
    downArrow.rotation.z += Math.PI;
    var rightArrow = new THREE.Mesh(arrowGeo, arrowMaterial3);
    rightArrow.position.set(arrowDist, 0, 0);
    rightArrow.rotation.z -= Math.PI / 2;
    var leftArrow = new THREE.Mesh(arrowGeo, arrowMaterial4);
    leftArrow.position.set(-arrowDist, 0, 0);
    leftArrow.rotation.z += Math.PI / 2;
    arrowGroup = new THREE.Object3D;
    arrowGroup.position.set(0, 0, 0);
    arrowGroup.add(upArrow);
    arrowGroup.add(downArrow);
    arrowGroup.add(rightArrow);
    arrowGroup.add(leftArrow);
    controlScene.add(arrowGroup);
    arrowBuffer.push(upArrow);
    arrowBuffer.push(downArrow);
    arrowBuffer.push(rightArrow);
    arrowBuffer.push(leftArrow);
    var homeGeo = new THREE.PlaneGeometry(cubeSize / 3, cubeSize / 3, 2, 2);
    var homeMaterial = new THREE.MeshBasicMaterial({map:loadTexture(path + "VChome.png"), transparent:true, shading:THREE.FlatShading});
    home = new THREE.Mesh(homeGeo, homeMaterial);
    home.position.set(-cubeSize, cubeSize, 0);
    controlScene.add(home);
    controlBuffer.push(home);
    var rollArrows = new THREE.PlaneGeometry(cubeSize * 1.5, cubeSize * 1.5, 2, 2);
    var rollMaterial = new THREE.MeshBasicMaterial({map:loadTexture(path + "VCarrows.png"), shading:THREE.FlatShading, transparent:true});
    var roll = new THREE.Mesh(rollArrows, rollMaterial);
    roll.position.set(cubeSize * 0.5 + 20, cubeSize * 0.5 + 20, 0);
    var rollSelectionLeft = new THREE.PlaneGeometry(cubeSize * 0.75, cubeSize * 0.5, 2, 2);
    var rollSelectionLeftMat = new THREE.MeshBasicMaterial({transparent:true, opacity:0});
    var rollLeft = new THREE.Mesh(rollSelectionLeft, rollSelectionLeftMat);
    rollLeft.position.set(cubeSize * 0.5 + 20, cubeSize, 0);
    var rollSelectionRight = new THREE.PlaneGeometry(cubeSize * 0.5, cubeSize * 0.75, 2, 2);
    var rollSelectionRightMat = new THREE.MeshBasicMaterial({transparent:true, opacity:0});
    var rollRight = new THREE.Mesh(rollSelectionRight, rollSelectionRightMat);
    rollRight.position.set(cubeSize, cubeSize * 0.5 + 20, 0);
    controlScene.add(roll);
    controlScene.add(rollLeft);
    controlScene.add(rollRight);
    controlBuffer.push(rollLeft);
    controlBuffer.push(rollRight);
    controlBuffer.push(roll);
    var contextGeo = new THREE.PlaneGeometry(cubeSize / 2.3, cubeSize / 2.3, 2, 2);
    var contextMaterial = new THREE.MeshBasicMaterial({map:loadTexture(path + "VCcontext.png"), transparent:true, shading:THREE.FlatShading});
    context = new THREE.Mesh(contextGeo, contextMaterial);
    context.position.set(cubeSize, -cubeSize, 0);
    controlScene.add(context);
    controlBuffer.push(context);
    var shadowGeo = new THREE.Geometry;
    shadowGeo.vertices.push(new THREE.Vector3(0, 0, 0));
    shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
    shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
    shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));
    shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));
    shadowGeo.faces.push(new THREE.Face3(4, 3, 2));
    shadowGeo.faces.push(new THREE.Face3(4, 2, 1));
    var shadowMat;
    shadowMat = new THREE.MeshBasicMaterial({color:0, transparent:true, opacity:0.5});
    shadow = new THREE.Mesh(shadowGeo, shadowMat);
    shadowScene.add(shadow);
    createCubeGrid();
    if (cam.renderer.toUpperCase() === "CANVAS") {
      renderer = new THREE.CanvasRenderer;
    } else {
      if (cam.renderer.toUpperCase() === "WEBGL") {
        renderer = new FireflyWebGLRenderer({alpha:true});
      } else {
        console.log("Incorrect use of Autocam.renderer property");
        renderer = new THREE.CanvasRenderer;
      }
    }
    self.useTransparency(true);
    self.setSize(self.width, self.height);
    self.camera.topFov = self.camera.bottomFov = self.camera.fov / 2;
    self.camera.leftFov = self.camera.rightFov = self.camera.aspect * self.camera.fov / 2;
    renderer.autoClear = false;
    renderer.setSize(self.width, self.height);
    renderer.sortObjects = false;
    cubeContainer.appendChild(renderer.domElement);
    cubeContainer.addEventListener("mousedown", onDocumentMouseDown, false);
    cubeContainer.addEventListener("mousemove", onDocumentMouseMove, false);
    window.addEventListener("resize", onWindowResize, false);
    _havePointerLockFeature = "pointerLockElement" in document || ("mozPointerLockElement" in document || "webkitPointerLockElement" in document);
    if (_havePointerLockFeature) {
      document.exitPointerLock = document.exitPointerLock || (document.mozExitPointerLock || document.webkitExitPointerLock);
      cubeContainer.requestPointerLock = cubeContainer.requestPointerLock || (cubeContainer.mozRequestPointerLock || cubeContainer.webkitRequestPointerLock);
      document.addEventListener("pointerlockchange", pointerLockChange, false);
      document.addEventListener("mozpointerlockchange", pointerLockChange, false);
      document.addEventListener("webkitpointerlockchange", pointerLockChange, false);
    }
    changingTextures.push(loadTexture(path + "VChomeS.png"));
    changingTextures.push(loadTexture(path + "VCarrowsS0.png"));
    changingTextures.push(loadTexture(path + "VCarrowsS1.png"));
    changingTextures.push(loadTexture(path + "VChome.png"));
    changingTextures.push(loadTexture(path + "VCarrows.png"));
    changingTextures.push(loadTexture(path + "VCcontext.png"));
    changingTextures.push(loadTexture(path + "VCcontextS.png"));
  };
  var mouseOverCube = function() {
    if (!cam.navApi.getIsLocked()) {
      cubeContainer.style.opacity = "1.0";
      _transparent = false;
    }
    if (typeof wheel != "undefined") {
      wheel.disabledMode = true;
    }
    requestAnimationFrame(self.render);
  };
  var mouseMoveOverCube = function(event) {
    if (!_transparent && (!cam.viewCubeMenuOpen && !cam.navApi.getIsLocked())) {
      var x = Math.max(Math.abs((event.clientX - position.x) / position.w - 0.5) * 4 - 1, 0);
      var y = Math.max(Math.abs((event.clientY - position.y) / position.h - 0.5) * 4 - 1, 0);
      var d = Math.max(0, Math.min(Math.sqrt(x * x + y * y), 1));
      cubeContainer.style.opacity = 1 - d * (1 - self.inactiveOpacity);
    } else {
      if (!cam.navApi.getIsLocked()) {
        cubeContainer.style.opacity = 1;
      }
    }
  };
  var mouseOutCube = function() {
    if (cam.viewCubeMenuOpen) {
      return;
    }
    cubeContainer.style.opacity = self.inactiveOpacity;
    _transparent = true;
    if (typeof wheel != "undefined") {
      wheel.disabledMode = false;
    }
    requestAnimationFrame(self.render);
  };
  var loadTexture = function(url) {
    var image = new Image;
    image.crossOrigin = "anonymous";
    var texture = new THREE.Texture(image);
    image.onload = function() {
      texture.needsUpdate = true;
      loadedTextureCount++;
      if (loadedTextureCount >= 14) {
        requestAnimationFrame(self.render);
      }
    };
    image.src = url;
    return texture;
  };
  var createCubeGrid = function() {
    var currentGridLength;
    var cubeCorners = [];
    var cubeEdges = [];
    cubeCorners[0] = buildCubeCorner(0, 0);
    cubeCorners[1] = buildCubeCorner(0, Math.PI / 2);
    cubeCorners[2] = buildCubeCorner(0, -Math.PI / 2);
    cubeCorners[3] = buildCubeCorner(0, Math.PI);
    cubeCorners[4] = buildCubeCorner(Math.PI / 2, 0);
    cubeCorners[5] = buildCubeCorner(Math.PI / 2, Math.PI / 2);
    cubeCorners[6] = buildCubeCorner(Math.PI / 2, -Math.PI / 2);
    cubeCorners[7] = buildCubeCorner(Math.PI / 2, Math.PI);
    cubeEdges[0] = buildCubeEdge(0, 0, 0);
    cubeEdges[1] = buildCubeEdge(0, Math.PI / 2, 0);
    cubeEdges[2] = buildCubeEdge(0, -Math.PI / 2, 0);
    cubeEdges[3] = buildCubeEdge(0, Math.PI, 0);
    cubeEdges[4] = buildCubeEdge(Math.PI / 2, 0, 0);
    cubeEdges[5] = buildCubeEdge(Math.PI / 2, Math.PI / 2, 0);
    cubeEdges[6] = buildCubeEdge(Math.PI / 2, -Math.PI / 2, 0);
    cubeEdges[7] = buildCubeEdge(Math.PI / 2, Math.PI, 0);
    cubeEdges[8] = buildCubeEdge(0, 0, Math.PI / 2);
    cubeEdges[9] = buildCubeEdge(0, 0, -Math.PI / 2);
    cubeEdges[10] = buildCubeEdge(-Math.PI / 2, 0, -Math.PI / 2);
    cubeEdges[11] = buildCubeEdge(-Math.PI, 0, -Math.PI / 2);
    gridMeshes.push(buildCubeFace(0, 0));
    gridMeshes[0].name = "front";
    intersectsFace.push(gridMeshes[0]);
    cubeBuffer.push(gridMeshes[0]);
    gridScene.add(gridMeshes[0]);
    gridMeshes.push(buildCubeFace(0, Math.PI / 2));
    gridMeshes[1].name = "right";
    intersectsFace.push(gridMeshes[1]);
    cubeBuffer.push(gridMeshes[1]);
    gridScene.add(gridMeshes[1]);
    gridMeshes.push(buildCubeFace(0, Math.PI));
    gridMeshes[2].name = "back";
    intersectsFace.push(gridMeshes[2]);
    cubeBuffer.push(gridMeshes[2]);
    gridScene.add(gridMeshes[2]);
    gridMeshes.push(buildCubeFace(0, -Math.PI / 2));
    gridMeshes[3].name = "left";
    intersectsFace.push(gridMeshes[3]);
    cubeBuffer.push(gridMeshes[3]);
    gridScene.add(gridMeshes[3]);
    gridMeshes.push(buildCubeFace(Math.PI / 2, 0));
    gridMeshes[4].name = "bottom";
    intersectsFace.push(gridMeshes[4]);
    cubeBuffer.push(gridMeshes[4]);
    gridScene.add(gridMeshes[4]);
    gridMeshes.push(buildCubeFace(-Math.PI / 2, 0));
    gridMeshes[5].name = "top";
    intersectsFace.push(gridMeshes[5]);
    cubeBuffer.push(gridMeshes[5]);
    gridScene.add(gridMeshes[5]);
    currentGridLength = gridMeshes.length;
    for (var i = 0;i < cubeCorners.length;i++) {
      gridMeshes.push(cubeCorners[i]);
      gridMeshes[currentGridLength + i].name = cornerNames[i];
      gridScene.add(gridMeshes[currentGridLength + i]);
      intersectsFace.push(gridMeshes[currentGridLength + i]);
      cubeBuffer.push(gridMeshes[currentGridLength + i]);
    }
    currentGridLength = gridMeshes.length;
    for (var i = 0;i < cubeEdges.length;i++) {
      gridMeshes.push(cubeEdges[i]);
      gridMeshes[currentGridLength + i].name = edgeNames[i];
      gridScene.add(gridMeshes[currentGridLength + i]);
      intersectsFace.push(gridMeshes[currentGridLength + i]);
      cubeBuffer.push(gridMeshes[currentGridLength + i]);
    }
  };
  var findPickingIntersects = function(pickingVector, camera, intersectionBuffer) {
    var raycaster;
    var intersects;
    var projector = new THREE.Projector;
    var direction = new THREE.Vector3;
    direction.copy(pickingVector);
    projector.unprojectVector(direction, camera);
    raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
    intersects = raycaster.intersectObjects(intersectionBuffer);
    return intersects;
  };
  var getPickVector = function(event, position) {
    var x = event.clientX - position.x;
    var y = event.clientY - position.y;
    x = x / position.w * 2 - 1;
    y = (position.h - y) / position.h * 2 - 1;
    return new THREE.Vector3(x, y, 0.5);
  };
  function isFullscreen() {
    return document.fullscreenElement || (document.webkitFullscreenElement || (document.mozFullScreenElement || document.msFullscreenElement));
  }
  var onDocumentMouseDown = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (cam.navApi.getIsLocked()) {
      return;
    }
    position = getPosition(cubeContainer);
    cubeContainer.removeEventListener("mousemove", onDocumentMouseMove, false);
    document.addEventListener("mouseup", onDocumentMouseUp, false);
    if (!cam.navApi.getUsePivotAlways()) {
      cam.pivot.copy(cam.center);
      cam.navApi.setPivotPoint(cam.center);
      cam.navApi.setPivotSetFlag(false);
    }
    cam.startInteraction(event.pageX, event.pageY);
    var intersectsWithCube;
    var pickingVector;
    if (cam.rewindParams.history.length == 0) {
      cam.addHistoryElement();
    }
    if (!cam.rewindParams.snapped || cam.rewindParams.timelineIndex + 1 != cam.rewindParams.history.length) {
      cam.addIntermediateHistoryElement();
    }
    event = event || window.event;
    var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
    if (event.which === rightMouse) {
      return;
    }
    if (cam.currentlyAnimating) {
      return;
    }
    if (self.animSpeed <= 0) {
      console.error("animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation");
      return;
    }
    pickingVector = getPickVector(event, position);
    intersectsWithCube = findPickingIntersects(pickingVector, self.camera, cubeBuffer);
    if (intersectsWithCube.length > 0) {
      hideArrows();
      if (self.draggable) {
        document.addEventListener("mousemove", onDocumentMouseMoveCube, false);
        self.prevX = event.screenX;
        self.prevY = event.screenY;
        if (_havePointerLockFeature) {
          cubeContainer.requestPointerLock();
          _pointerLockMoveBugSPK865 = _isChrome && _isWindows;
        }
      }
    }
  };
  var onDocumentMouseMoveCube = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (self.animSpeed <= 0) {
      document.removeEventListener("mousemove", onDocumentMouseMoveCube, false);
      console.error("animSpeed cannot be 0 or less");
      return;
    }
    if (cam.currentlyAnimating) {
      return;
    }
    var movementX, movementY;
    if (_havePointerLockFeature) {
      if (_pointerLockMoveBugSPK865) {
        _pointerLockMoveBugSPK865 = false;
        movementX = movementY = 0;
      } else {
        movementX = event.movementX || (event.mozMovementX || (event.webkitMovementX || 0));
        movementY = event.movementY || (event.mozMovementY || (event.webkitMovementY || 0));
      }
    } else {
      movementX = event.screenX - self.prevX;
      movementY = event.screenY - self.prevY;
      self.prevX = event.screenX;
      self.prevY = event.screenY;
    }
    if (_havePointerLock) {
      if (movementX > 300 || movementY > 300) {
        movementX = 0;
        movementY = 0;
      }
    }
    if (movementX === movementY && movementX === 0) {
      cam.currentlyAnimating = false;
      return;
    }
    _orthogonalView = false;
    _dragged = true;
    cam.showPivot(true);
    cam.currentCursor = new THREE.Vector2(event.pageX, event.pageY);
    cam.orbit(cam.currentCursor, cam.startCursor, new THREE.Vector3(-movementX, movementY, 0), cam.startState);
    self.camera.lookAt(self.center);
    requestAnimationFrame(self.render);
  };
  var endMouseUp = function(stillNeedUp) {
    if (!stillNeedUp) {
      document.removeEventListener("mouseup", onDocumentMouseUp, false);
    }
    document.removeEventListener("mousemove", onDocumentMouseMoveCube, false);
    cubeContainer.addEventListener("mousemove", onDocumentMouseMove, false);
    if (_havePointerLock) {
      document.exitPointerLock();
    }
  };
  var onDocumentMouseUp = function(event) {
    event.preventDefault();
    event.stopPropagation();
    var cubeIntersects;
    var arrowIntersects;
    var controlIntersects;
    if (cam.currentlyAnimating || _dragged) {
      cam.showPivot(false);
      _dragged = false;
      endMouseUp(false);
      return;
    }
    if (cam.viewCubeMenuOpen) {
      var x = event.clientX - position.x;
      var y = event.clientY - position.y;
      if (cam.menuOrigin.x <= x && (x <= cam.menuOrigin.x + cam.menuSize.x && (cam.menuOrigin.y <= y && y <= cam.menuOrigin.y + cam.menuSize.y))) {
        var menuItemNumber = Math.floor((y - 5 - cam.menuOrigin.y) / 25);
        switch(menuItemNumber) {
          case 0:
            cam.goHome();
            break;
          case 1:
            break;
          case 2:
            break;
          case 3:
            break;
          case 4:
            cam.setCurrentViewAsHome(false);
            break;
          case 5:
            cam.setCurrentViewAsHome(true);
            break;
          case 6:
            cam.resetHome();
            break;
          case 7:
            cam.setCurrentViewAsFront();
            break;
          case 8:
            cam.setCurrentViewAsTop();
            break;
          case 9:
            cam.resetOrientation();
            break;
        }
      }
      cam.viewCubeMenuOpen = false;
      cam.removeDropdownMenu(cubeContainer);
      if (event.clientX < position.x || (event.clientX > position.w + position.x || (event.clientY < position.y || event.clientY > position.h + position.y))) {
        mouseOutCube();
      }
      if (self.mouseMoveSave) {
        self.processMouseMove(self.mouseMoveSave);
      }
      endMouseUp(false);
      return;
    }
    var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
    if (event.which === rightMouse) {
      cam.viewCubeMenuOpen = true;
      cam.drawDropdownMenu(menuOptionList, menuEnableList, event.clientX, event.clientY, cubeContainer, position);
      endMouseUp(true);
      return;
    }
    var pickingVector = getPickVector(event, position);
    cubeIntersects = findPickingIntersects(pickingVector, self.camera, cubeBuffer);
    arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
    controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);
    if (arrowIntersects.length > 0 && _orthogonalView) {
      var orientation = cam.getOrientation();
      switch(self.currentFace) {
        case "front":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("top");
                self.currentFace = "top";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("bottom");
                  self.currentFace = "bottom";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("right");
                    self.currentFace = "right";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("left");
                      self.currentFace = "left";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("right");
                self.currentFace = "right";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("left");
                  self.currentFace = "left";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("bottom");
                    self.currentFace = "bottom";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("top");
                      self.currentFace = "top";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("bottom");
                self.currentFace = "bottom";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("top");
                  self.currentFace = "top";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("left");
                    self.currentFace = "left";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("right");
                      self.currentFace = "right";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("left");
                self.currentFace = "left";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("right");
                  self.currentFace = "right";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("top");
                    self.currentFace = "top";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("bottom");
                      self.currentFace = "bottom";
                    }
                  }
                }
              }
              break;
          }
          break;
        case "right":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("top");
                self.currentFace = "top";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("bottom");
                  self.currentFace = "bottom";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("back");
                    self.currentFace = "back";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("front");
                      self.currentFace = "front";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("back");
                self.currentFace = "back";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("front");
                  self.currentFace = "front";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("bottom");
                    self.currentFace = "bottom";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("top");
                      self.currentFace = "top";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("bottom");
                self.currentFace = "bottom";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("top");
                  self.currentFace = "top";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("front");
                    self.currentFace = "front";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("back");
                      self.currentFace = "back";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("front");
                self.currentFace = "front";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("back");
                  self.currentFace = "back";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("top");
                    self.currentFace = "top";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("bottom");
                      self.currentFace = "bottom";
                    }
                  }
                }
              }
              break;
          }
          break;
        case "left":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("top");
                self.currentFace = "top";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("bottom");
                  self.currentFace = "bottom";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("front");
                    self.currentFace = "front";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("back");
                      self.currentFace = "back";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("front");
                self.currentFace = "front";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("bavk");
                  self.currentFace = "back";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("bottom");
                    self.currentFace = "bottom";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("top");
                      self.currentFace = "top";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("bottom");
                self.currentFace = "bottom";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("top");
                  self.currentFace = "top";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("back");
                    self.currentFace = "back";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("front");
                      self.currentFace = "front";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("back");
                self.currentFace = "back";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("front");
                  self.currentFace = "front";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("top");
                    self.currentFace = "top";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("bottom");
                      self.currentFace = "bottom";
                    }
                  }
                }
              }
              break;
          }
          break;
        case "back":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("top");
                self.currentFace = "top";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("bottom");
                  self.currentFace = "bottom";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("left");
                    self.currentFace = "left";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("right");
                      self.currentFace = "right";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("left");
                self.currentFace = "left";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("right");
                  self.currentFace = "right";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("bottom");
                    self.currentFace = "bottom";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("top");
                      self.currentFace = "top";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("bottom");
                self.currentFace = "bottom";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("top");
                  self.currentFace = "top";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("right");
                    self.currentFace = "right";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("left");
                      self.currentFace = "left";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("right");
                self.currentFace = "right";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("left");
                  self.currentFace = "left";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("top");
                    self.currentFace = "top";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("bottom");
                      self.currentFace = "bottom";
                    }
                  }
                }
              }
              break;
          }
          break;
        case "top":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("back");
                self.currentFace = "back";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("front");
                  self.currentFace = "front";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("right");
                    self.currentFace = "right";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("left");
                      self.currentFace = "left";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("right");
                self.currentFace = "right";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("left");
                  self.currentFace = "left";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("front");
                    self.currentFace = "front";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("back");
                      self.currentFace = "back";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("front");
                self.currentFace = "front";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("back");
                  self.currentFace = "back";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("left");
                    self.currentFace = "left";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("right");
                      self.currentFace = "right";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("left");
                self.currentFace = "left";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("right");
                  self.currentFace = "right";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("back");
                    self.currentFace = "back";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("front");
                      self.currentFace = "front";
                    }
                  }
                }
              }
              break;
          }
          break;
        case "bottom":
          switch(orientation) {
            case "up":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("front");
                self.currentFace = "front";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("back");
                  self.currentFace = "back";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("right");
                    self.currentFace = "right";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("left");
                      self.currentFace = "left";
                    }
                  }
                }
              }
              break;
            case "right":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("right");
                self.currentFace = "right";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("left");
                  self.currentFace = "left";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("back");
                    self.currentFace = "back";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("front");
                      self.currentFace = "front";
                    }
                  }
                }
              }
              break;
            case "down":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("back");
                self.currentFace = "back";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("front");
                  self.currentFace = "front";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("left");
                    self.currentFace = "left";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("right");
                      self.currentFace = "right";
                    }
                  }
                }
              }
              break;
            case "left":
              if (arrowIntersects[0].object === arrowBuffer[0]) {
                cam.calculateCubeTransform("left");
                self.currentFace = "left";
              } else {
                if (arrowIntersects[0].object === arrowBuffer[1]) {
                  cam.calculateCubeTransform("right");
                  self.currentFace = "right";
                } else {
                  if (arrowIntersects[0].object === arrowBuffer[2]) {
                    cam.calculateCubeTransform("front");
                    self.currentFace = "front";
                  } else {
                    if (arrowIntersects[0].object === arrowBuffer[3]) {
                      cam.calculateCubeTransform("back");
                      self.currentFace = "back";
                    }
                  }
                }
              }
              break;
          }
          break;
      }
      cam.elapsedTime = 0;
      cam.sphericallyInterpolateTransition();
    }
    if (controlIntersects.length > 0) {
      cam.elapsedTime = 0;
      if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[0]) {
        cam.goHome();
        endMouseUp(false);
        return;
      }
      if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[4]) {
        cam.viewCubeMenuOpen = true;
        cam.drawDropdownMenu(menuOptionList, menuEnableList, event.clientX, event.clientY, cubeContainer, position);
        endMouseUp(true);
        return;
      }
      if (self.wantRollArrows && (_orthogonalView && (controlIntersects[0].object === controlBuffer[1] || controlIntersects[0].object === controlBuffer[2]))) {
        var clockwise = controlIntersects[0].object === controlBuffer[2];
        var destination = {center:cam.center.clone(), position:camera.position.clone(), pivot:camera.pivot.clone(), fov:camera.fov, worldUp:cam.sceneUpDirection.clone()};
        var dir = cam.center.clone().sub(camera.position).normalize();
        if (clockwise) {
          destination.up = camera.up.clone().cross(dir);
        } else {
          destination.up = camera.up.clone().multiplyScalar(-1);
          destination.up.cross(dir);
        }
        destination.up.normalize();
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
      }
    }
    if (cubeIntersects.length > 0) {
      cam.calculateCubeTransform(cubeIntersects[0].object.name);
      self.currentFace = cubeIntersects[0].object.name;
      cam.elapsedTime = 0;
      self.mouseMoveSave = event;
      cam.sphericallyInterpolateTransition(function() {
        if (self.mouseMoveSave) {
          self.processMouseMove(self.mouseMoveSave);
        }
      });
    }
    endMouseUp(false);
  };
  this.processMouseMove = function(event) {
    var intersectsFaces;
    var arrowIntersects;
    var pickingVector;
    var controlIntersects;
    if (cam.viewCubeMenuOpen || cam.currentlyAnimating) {
      self.mouseMoveSave = event;
      return;
    }
    self.mouseMoveSave = null;
    var pickingVector = getPickVector(event, position);
    intersectsFaces = findPickingIntersects(pickingVector, self.camera, intersectsFace);
    arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
    controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);
    if (INTERSECTED && !_dragged) {
      INTERSECTED.material.color.setHex(14540253);
      INTERSECTED = null;
      requestAnimationFrame(self.render);
    }
    if (arrowIntersects.length > 0 && !_dragged) {
      INTERSECTED = arrowIntersects[0].object;
      INTERSECTED.material.color.setHex(45055);
      requestAnimationFrame(self.render);
    }
    if (INTERSECTED_F && !_dragged) {
      INTERSECTED_F.material.opacity = 0;
      INTERSECTED_F = null;
      requestAnimationFrame(self.render);
    }
    if (intersectsFaces.length > 0 && !_dragged) {
      INTERSECTED_F = intersectsFaces[0].object;
      INTERSECTED_F.material.opacity = 0.3;
      requestAnimationFrame(self.render);
    }
    if (controlIntersects.length > 0 && !_dragged) {
      if (INTERSECTED_C !== controlIntersects[0].object) {
        if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[0]) {
          INTERSECTED_C = controlIntersects[0].object;
          controlBuffer[0].material.map = changingTextures[0];
        } else {
          if (self.wantRollArrows && controlIntersects[0].object === controlBuffer[1]) {
            INTERSECTED_C = controlIntersects[0].object;
            controlBuffer[3].material.map = changingTextures[1];
          } else {
            if (self.wantRollArrows && controlIntersects[0].object === controlBuffer[2]) {
              INTERSECTED_C = controlIntersects[0].object;
              controlBuffer[3].material.map = changingTextures[2];
            } else {
              if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[4]) {
                INTERSECTED_C = controlIntersects[0].object;
                controlBuffer[4].material.map = changingTextures[6];
              } else {
                if (self.wantHomeButton && INTERSECTED_C === controlBuffer[0]) {
                  INTERSECTED_C = null;
                  controlBuffer[0].material.map = changingTextures[3];
                } else {
                  if (self.wantRollArrows && (INTERSECTED_C === controlBuffer[1] || (INTERSECTED_C === controlBuffer[2] || INTERSECTED_C === controlBuffer[3]))) {
                    INTERSECTED_C = null;
                    controlBuffer[3].material.map = changingTextures[4];
                  } else {
                    if (self.wantContextMenu && INTERSECTED_C === controlBuffer[4]) {
                      INTERSECTED_C = null;
                      controlBuffer[4].material.map = changingTextures[5];
                    }
                  }
                }
              }
            }
          }
        }
        requestAnimationFrame(self.render);
      }
    } else {
      if (INTERSECTED_C !== null && !_dragged) {
        if (self.wantHomeButton && INTERSECTED_C === controlBuffer[0]) {
          INTERSECTED_C = null;
          controlBuffer[0].material.map = changingTextures[3];
        } else {
          if (self.wantRollArrows && (INTERSECTED_C === controlBuffer[1] || (INTERSECTED_C === controlBuffer[2] || INTERSECTED_C === controlBuffer[3]))) {
            INTERSECTED_C = null;
            controlBuffer[3].material.map = changingTextures[4];
          } else {
            if (self.wantContextMenu && INTERSECTED_C === controlBuffer[4]) {
              INTERSECTED_C = null;
              controlBuffer[4].material.map = changingTextures[5];
            }
          }
        }
        requestAnimationFrame(self.render);
      }
    }
  };
  var onDocumentMouseMove = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!cam.navApi.getIsLocked()) {
      self.processMouseMove(event);
    }
  };
  var onWindowResize = function() {
    position = getPosition(cubeContainer);
    self.width = cubeContainer.offsetWidth;
    self.height = cubeContainer.offsetHeight;
    windowHalfX = self.width / 2;
    windowHalfY = self.height / 2;
    self.camera.aspect = self.width / self.height;
    self.camera.updateProjectionMatrix();
    self.camera.topFov = self.camera.bottomFov = self.camera.fov / 2;
    self.camera.leftFov = self.camera.rightFov = self.camera.aspect * self.camera.fov / 2;
    renderer.setSize(self.width, self.height);
    requestAnimationFrame(self.render);
  };
  var buildCubeFace = function(rotationX, rotationY) {
    var material;
    var edge = 45;
    var square = 60;
    var masterCubeSize = edge + square;
    var geo = new THREE.Geometry;
    var v0 = new THREE.Vector3(0, 0, 0);
    var v1 = new THREE.Vector3(square, -square, masterCubeSize);
    var v2 = new THREE.Vector3(square, square, masterCubeSize);
    var v3 = new THREE.Vector3(-square, square, masterCubeSize);
    var v4 = new THREE.Vector3(-square, -square, masterCubeSize);
    geo.vertices.push(v0);
    geo.vertices.push(v1);
    geo.vertices.push(v2);
    geo.vertices.push(v3);
    geo.vertices.push(v4);
    geo.faces.push(new THREE.Face3(1, 2, 3));
    geo.faces.push(new THREE.Face3(1, 3, 4));
    geo.applyMatrix((new THREE.Matrix4).makeRotationX(rotationX));
    geo.applyMatrix((new THREE.Matrix4).makeRotationY(rotationY));
    geo.computeFaceNormals();
    geo.computeVertexNormals();
    material = new THREE.MeshBasicMaterial({overdraw:true, opacity:0, color:45055, transparent:true});
    return new THREE.Mesh(geo, material);
  };
  var buildCubeEdge = function(rotationX, rotationY, rotationZ) {
    var material;
    var edge = 45;
    var square = 60;
    var masterCubeSize = edge + square;
    var meshReturn;
    var geo = new THREE.Geometry;
    var e0 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
    var e1 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
    var e2 = new THREE.Vector3(-square, square, masterCubeSize);
    var e3 = new THREE.Vector3(square, square, masterCubeSize);
    var e4 = new THREE.Vector3(square, masterCubeSize, square);
    var e5 = new THREE.Vector3(-square, masterCubeSize, square);
    var e6 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
    var e7 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
    geo.vertices.push(e0);
    geo.vertices.push(e1);
    geo.vertices.push(e2);
    geo.vertices.push(e3);
    geo.vertices.push(e4);
    geo.vertices.push(e5);
    geo.vertices.push(e6);
    geo.vertices.push(e7);
    geo.faces.push(new THREE.Face3(0, 1, 2));
    geo.faces.push(new THREE.Face3(0, 2, 3));
    geo.faces.push(new THREE.Face3(4, 5, 6));
    geo.faces.push(new THREE.Face3(4, 6, 7));
    geo.applyMatrix((new THREE.Matrix4).makeRotationX(rotationX));
    geo.applyMatrix((new THREE.Matrix4).makeRotationY(rotationY));
    geo.applyMatrix((new THREE.Matrix4).makeRotationZ(rotationZ));
    geo.computeFaceNormals();
    geo.computeVertexNormals();
    material = new THREE.MeshBasicMaterial({overdraw:true, opacity:0, color:45055, transparent:true});
    meshReturn = new THREE.Mesh(geo, material);
    return meshReturn;
  };
  var buildCubeCorner = function(rotationX, rotationY) {
    var material;
    var edge = 45;
    var square = 60;
    var masterCubeSize = edge + square;
    var meshReturn;
    var geo = new THREE.Geometry;
    var c0 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
    var c1 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
    var c2 = new THREE.Vector3(square, square, masterCubeSize);
    var c3 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);
    var c4 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
    var c5 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
    var c6 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);
    var c7 = new THREE.Vector3(masterCubeSize, square, square);
    var c8 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
    var c9 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
    var c10 = new THREE.Vector3(square, masterCubeSize, square);
    var c11 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
    geo.vertices.push(c0);
    geo.vertices.push(c1);
    geo.vertices.push(c2);
    geo.vertices.push(c3);
    geo.vertices.push(c4);
    geo.vertices.push(c5);
    geo.vertices.push(c6);
    geo.vertices.push(c7);
    geo.vertices.push(c8);
    geo.vertices.push(c9);
    geo.vertices.push(c10);
    geo.vertices.push(c11);
    geo.faces.push(new THREE.Face3(0, 1, 2));
    geo.faces.push(new THREE.Face3(0, 2, 3));
    geo.faces.push(new THREE.Face3(4, 5, 6));
    geo.faces.push(new THREE.Face3(4, 6, 7));
    geo.faces.push(new THREE.Face3(8, 9, 10));
    geo.faces.push(new THREE.Face3(8, 10, 11));
    geo.applyMatrix((new THREE.Matrix4).makeRotationX(rotationX));
    geo.applyMatrix((new THREE.Matrix4).makeRotationY(rotationY));
    geo.computeFaceNormals();
    geo.computeVertexNormals();
    material = new THREE.MeshBasicMaterial({overdraw:true, opacity:0, color:45055, transparent:true});
    meshReturn = new THREE.Mesh(geo, material);
    return meshReturn;
  };
  var changeBasisWorldToStandard = function(V) {
    var worldD = cam.cubeFront.clone();
    var worldU = cam.sceneUpDirection.clone();
    var worldR = worldD.clone().cross(worldU);
    worldU.copy(worldR).cross(worldD);
    worldD.normalize();
    worldU.normalize();
    worldR.normalize();
    var answer = (new THREE.Vector3(worldD.x, worldU.x, worldR.x)).multiplyScalar(V.x);
    answer.add((new THREE.Vector3(worldD.y, worldU.y, worldR.y)).multiplyScalar(V.y));
    answer.add((new THREE.Vector3(worldD.z, worldU.z, worldR.z)).multiplyScalar(V.z));
    return answer;
  };
  this.render = function() {
    var scale = self.compass ? self.viewScaleFactorCompass * self.viewScale : self.viewScale;
    var viewDir = cam.center.clone().sub(camera.position).normalize();
    var upDir = camera.up.normalize();
    viewDir = changeBasisWorldToStandard(viewDir);
    upDir = changeBasisWorldToStandard(upDir);
    self.camera.position = viewDir.multiplyScalar(-1).normalize().multiplyScalar(scale);
    self.camera.up = upDir.normalize();
    self.camera.lookAt(self.center);
    checkControlVisibility();
    renderer.clear();
    renderer.render(shadowScene, self.camera);
    renderer.render(cubeScene, self.camera);
    renderer.render(lineScene, self.camera);
    renderer.render(gridScene, self.camera);
    renderer.render(controlScene, controlCamera);
  };
  function isAxisAligned(vec) {
    var sceneRight = cam.sceneFrontDirection.clone().cross(cam.sceneUpDirection);
    var checkUp = Math.abs(Math.abs(vec.dot(cam.sceneUpDirection)) - 1);
    var checkFront = Math.abs(Math.abs(vec.dot(cam.sceneFrontDirection)) - 1);
    var checkRight = Math.abs(Math.abs(vec.dot(sceneRight)) - 1);
    return checkUp < 1E-5 || (checkFront < 1E-5 || checkRight < 1E-5);
  }
  var checkControlVisibility = function() {
    var dir = cam.center.clone().sub(camera.position).normalize();
    _orthogonalView = isAxisAligned(dir) && isAxisAligned(camera.up);
    _orthogonalView && (!_transparent && !cam.currentlyAnimating) ? showArrows() : hideArrows();
    _transparent ? hideContext() : showContext();
    _transparent ? hideHome() : showHome();
  };
  var hideArrows = function() {
    for (var i = 0;i < arrowBuffer.length;i++) {
      arrowBuffer[i].material.opacity = 0;
    }
    for (var i = 3;i < controlBuffer.length - 1;i++) {
      controlBuffer[i].material.opacity = 0;
    }
  };
  var showArrows = function() {
    for (var i = 0;i < arrowBuffer.length;i++) {
      arrowBuffer[i].material.opacity = 1;
    }
    for (var i = 3;i < controlBuffer.length - 1;i++) {
      controlBuffer[i].material.opacity = self.wantRollArrows ? 1 : 0;
    }
  };
  var hideContext = function() {
    context.material.opacity = 0;
  };
  var showContext = function() {
    context.material.opacity = self.wantContextMenu ? 1 : 0;
  };
  var hideHome = function() {
    home.material.opacity = 0;
  };
  var showHome = function() {
    home.material.opacity = self.wantHomeButton ? 1 : 0;
  };
  this.refreshCube = function() {
    onWindowResize();
  };
  this.setSize = function(width, height) {
    self.width = width;
    self.height = height;
    if (cubeContainer.children.length > 1) {
      for (var i = 1;i < cubeContainer.children.length;i++) {
        cubeContainer.children[i].style.bottom = (self.height / 5).toString() + "px";
      }
    }
    onWindowResize();
  };
  this.useTransparency = function(transparent) {
    _transparent = transparent;
    if (transparent) {
      cubeContainer.onmouseover = mouseOverCube;
      cubeContainer.onmousemove = mouseMoveOverCube;
      cubeContainer.onmouseout = mouseOutCube;
      mouseOutCube();
    } else {
      cubeContainer.onmouseover = null;
      cubeContainer.onmouseout = null;
      cubeContainer.onmousemove = null;
      cubeContainer.style.opacity = "1.0";
    }
  };
  Init();
};
function ViewController(viewerImpl, viewerApi) {
  var kHalf_PI = 0.5 * Math.PI;
  var kTwo_PI = 2 * Math.PI;
  var kMinFOV = 6.88;
  var kMaxFOV = 100;
  var kScreenEpsilon = 0.001;
  var kEpsilon = 1E-5;
  var kUpTolerance = Math.sin(THREE.Math.degToRad(20));
  var isMac = navigator.userAgent.search("Mac OS") != -1;
  var isFirefox = navigator.userAgent.search("Firefox") != -1;
  var lastTouchedElement = undefined;
  var k35mmVerticalCameraBackSize = 12;
  function fov2fl(fov) {
    var rads = THREE.Math.degToRad(fov);
    if (rads <= 0) {
      rads = 1E-4;
    }
    return Math.round(k35mmVerticalCameraBackSize / Math.tan(rads * 0.5));
  }
  function fl2fov(fl) {
    if (fl <= 0) {
      fl = 1E-4;
    }
    var rads = 2 * Math.atan(k35mmVerticalCameraBackSize / fl);
    return THREE.Math.radToDeg(rads);
  }
  var projectAxis = function() {
    var projectionVec = new THREE.Vector3;
    return function(x, y, z, normal) {
      var vec = new THREE.Vector3(x, y, z);
      var projectionLength = normal.dot(vec);
      projectionVec.copy(normal);
      projectionVec.multiplyScalar(projectionLength);
      return vec.sub(projectionVec);
    };
  }();
  this.setClickBehavior = function(config) {
    this.clickConfig = config;
  };
  this.getClickBehavior = function() {
    return this.clickConfig;
  };
  var orient = function() {
    var m1 = new THREE.Matrix4;
    var x = new THREE.Vector3;
    var y = new THREE.Vector3;
    var z = new THREE.Vector3;
    return function(object, pos, towards, up) {
      var te = m1.elements;
      z.subVectors(towards, pos).normalize();
      if (z.lengthSq() === 0) {
        z.z = 1;
      }
      x.crossVectors(up, z).normalize();
      if (x.lengthSq() === 0) {
        if (up.z > up.y) {
          z.y -= 1E-4;
        } else {
          z.z += 1E-4;
        }
        x.crossVectors(up, z).normalize();
      }
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      object.setRotationFromMatrix(m1);
    };
  }();
  function TurntableView(camera) {
    var kMinDistance = 0.01;
    var kDefaultDistance = 10;
    var kLookSpeedDefault = 5;
    var kDollySpeedDefault = 0.025;
    var kMinDollySpeed = 0.01;
    var myCamera = camera;
    var myAzimuth = 0;
    var myElevation = 0;
    var myDistance = 0;
    var myTrackingDistance = 0;
    var myLookSpeed = kLookSpeedDefault;
    var myDollySpeed = kDollySpeedDefault;
    var myViewDirty = false;
    var myCameraChanged = false;
    var myCameraFlipped = false;
    var myPivotBehind = false;
    var mySaveCOI = null;
    var mySaveCOIset = false;
    var myPivotPoint = new THREE.Vector3(0, 0, 0);
    var myPosition = camera.position.clone();
    var myTrackOffset = new THREE.Vector2(0, 0);
    var myCurrentUp = camera.up.clone();
    this.saveCOI = function() {
      mySaveCOI = this.getPivotPoint().clone();
      mySaveCOIset = viewerApi.navigation.getPivotSetFlag();
    };
    this.restoreCOI = function() {
      if (mySaveCOI !== null) {
        this.setPivotPoint(mySaveCOI, true, mySaveCOIset);
        if (!mySaveCOIset) {
          viewerApi.navigation.setPivotSetFlag(false);
        }
        mySaveCOI = null;
      }
    };
    this.isDirty = function() {
      return myViewDirty;
    };
    this.cameraChanged = function(reset) {
      var changed = myCameraChanged;
      if (reset) {
        myCameraChanged = false;
      }
      return changed;
    };
    this.getPosition = function() {
      return myPosition.clone().add(this.getViewOffset());
    };
    this.setPosition = function(pos) {
      this.setView(pos, myPivotPoint);
    };
    this.getPivotDistance = function() {
      return myDistance;
    };
    this.setPivotPoint = function(newCOI, preserveView, isset) {
      if (preserveView) {
        var wasDirty = myViewDirty;
        var eye = this.getPosition();
        var eyeCOI = new THREE.Vector3;
        eyeCOI.subVectors(newCOI, eye);
        var right = this.getCameraRightVector();
        var up = this.getCameraUpVector();
        var offX = right.dot(eyeCOI);
        var offY = up.dot(eyeCOI);
        right.multiplyScalar(offX);
        up.multiplyScalar(offY);
        eye.add(right);
        eye.add(up);
        this.setView(eye, newCOI, -offX, -offY);
        myViewDirty = wasDirty;
      } else {
        this.setView(myPosition, newCOI);
      }
      viewerApi.navigation.setPivotPoint(this.getPivotPoint());
      if (isset) {
        viewerApi.navigation.setPivotSetFlag(true);
      }
      if (!myViewDirty) {
        myCameraChanged = true;
      }
    };
    this.getPivotPoint = function() {
      return myPivotPoint;
    };
    this.pivotIsSet = function() {
      return viewerApi.navigation.getPivotSetFlag();
    };
    this.getLookAtPoint = function() {
      var eye = this.getEyeVector();
      var point = eye.add(myPosition);
      return point.add(this.getViewOffset());
    };
    this.getForwardLookAtPoint = function(hitFunction) {
      var eye = this.getEyeVector().normalize();
      var pos = this.getPosition();
      var p = hitFunction(0.5, 0.5);
      var distance = p ? p.sub(pos).length() : 0.5 * (myCamera.near + myCamera.far);
      return pos.add(eye.multiplyScalar(distance));
    };
    this.getCameraUpVector = function() {
      var eye = this.getEyeVector();
      if (eye.lengthSq() === 0) {
        return myCamera.up;
      }
      return this.getCameraRightVector().cross(eye).normalize();
    };
    this.getCameraRightVector = function() {
      var right = new THREE.Vector3;
      var eye = this.getEyeVector();
      if (eye.lengthSq() === 0) {
        return right.set(1, 0, 0);
      }
      var up = myCameraFlipped ? this.getCurrentUpVector().multiplyScalar(-1) : myCamera.up;
      right.crossVectors(eye, up);
      if (right.lengthSq() === 0) {
        if (up.z > up.y) {
          eye.y -= 1E-4;
        } else {
          eye.z += 1E-4;
        }
        right.crossVectors(eye, up);
      }
      return right.normalize();
    };
    this.checkCameraUp = function() {
      var r = this.getCameraRightVector();
      var u = this.getWorldUpVector();
      var rdotu = r.dot(u);
      if (Math.abs(rdotu) < kUpTolerance) {
        myCurrentUp.copy(u);
        return;
      }
      u.copy(myCamera.up);
      var x = u.x >= 0 ? u.x : -u.x;
      var y = u.y >= 0 ? u.y : -u.y;
      var z = u.z >= 0 ? u.z : -u.z;
      if (x > y && x > z) {
        u.set(u.x > 0 ? 1 : -1, 0, 0);
      } else {
        if (y > x && y > z) {
          u.set(0, u.y > 0 ? 1 : -1, 0);
        } else {
          u.set(0, 0, u.z > 0 ? 1 : -1);
        }
      }
      myCurrentUp.copy(u);
    };
    this.setWorldUpVector = function(up, reorient) {
      viewerApi.navigation.setWorldUpVector(up);
      if (reorient) {
        myCameraFlipped = false;
        myCamera.up.copy(up);
        myCamera.up.copy(this.getCameraUpVector());
      }
      this.setView(myPosition, myPivotPoint, myTrackOffset.x, myTrackOffset.y);
    };
    this.getCurrentUpVector = function() {
      return myCurrentUp.clone();
    };
    this.getCurrentRightVector = function() {
      var vec = this.getCurrentUpVector();
      if (Math.abs(vec.z) <= Math.abs(vec.y)) {
        vec.set(vec.y, -vec.x, 0);
      } else {
        if (vec.z >= 0) {
          vec.set(vec.z, 0, -vec.x);
        } else {
          vec.set(-vec.z, 0, vec.x);
        }
      }
      return vec.normalize();
    };
    this.getWorldUpVector = function() {
      return viewerApi.navigation.getWorldUpVector();
    };
    this.getWorldRightVector = function() {
      var vec = this.getWorldUpVector();
      if (Math.abs(vec.z) <= Math.abs(vec.y)) {
        vec.set(vec.y, -vec.x, 0);
      } else {
        if (vec.z >= 0) {
          vec.set(vec.z, 0, -vec.x);
        } else {
          vec.set(-vec.z, 0, vec.x);
        }
      }
      return vec.normalize();
    };
    this.getEyeVector = function() {
      var eye = new THREE.Vector3;
      eye.subVectors(myPivotPoint, myPosition);
      if (myPivotBehind) {
        eye.set(-eye.x, -eye.y, -eye.z);
      }
      return eye;
    };
    this.setTrackingDistance = function(distance) {
      myTrackingDistance = distance;
    };
    this.getWorldSize = function(atDistance) {
      var viewport = viewerApi.navigation.getScreenViewport();
      var aspect = viewport.width / viewport.height;
      var worldHeight = 2 * atDistance * Math.tan(THREE.Math.degToRad(myCamera.fov * 0.5));
      var worldWidth = worldHeight * aspect;
      return new THREE.Vector2(worldWidth, worldHeight);
    };
    this.trackReset = function() {
      myTrackOffset.set(0, 0);
      viewerApi.navigation.setPivotSetFlag(false);
    };
    this.trackRelative = function(deltaX, deltaY) {
      var trackSpeed = this.getWorldSize(myTrackingDistance);
      myTrackOffset.set(myTrackOffset.x + deltaX * trackSpeed.x, myTrackOffset.y + deltaY * trackSpeed.y);
      myViewDirty = true;
    };
    this.getViewOffset = function() {
      var up = this.getCameraUpVector();
      var right = this.getCameraRightVector();
      var trackX = right.multiplyScalar(myTrackOffset.x);
      var trackY = up.multiplyScalar(myTrackOffset.y);
      return trackX.add(trackY);
    };
    this.adjustDollyLookSpeed = function(direction) {
      if (direction === 0) {
        myDollySpeed = kDollySpeedDefault;
        myLookSpeed = kLookSpeedDefault;
      } else {
        myDollySpeed *= direction > 0 ? 1.1 : 0.9;
        myLookSpeed *= direction > 0 ? 1.1 : 0.9;
        if (myDollySpeed < 1E-6) {
          myDollySpeed = 1E-6;
        }
        if (myLookSpeed < 1E-6) {
          myLookSpeed = 1E-6;
        }
      }
    };
    this.getDollySpeed = function() {
      var distance = myDistance * myDollySpeed;
      return distance < kMinDollySpeed ? kMinDollySpeed : distance;
    };
    this.getLookSpeed = function() {
      return myLookSpeed;
    };
    this.coiIsVisible = function() {
      if (myPivotBehind) {
        return false;
      }
      var offX = Math.abs(myTrackOffset.x);
      var offY = Math.abs(myTrackOffset.y);
      var viewport = viewerApi.navigation.getScreenViewport();
      var halfH = myDistance * Math.tan(THREE.Math.degToRad(myCamera.fov * 0.5));
      var halfW = halfH * (viewport.width / viewport.height);
      return offX < halfW && offY < halfH;
    };
    this.coiIsActive = function() {
      return viewerApi.navigation.getPivotSetFlag() && this.coiIsVisible();
    };
    this.orbitRelative = function(deltaAzimuth, deltaElevation) {
      if (Math.abs(deltaAzimuth) > kEpsilon || Math.abs(deltaElevation) > kEpsilon) {
        this.look(myAzimuth - deltaAzimuth * myLookSpeed, myElevation + deltaElevation * myLookSpeed, myDistance, true);
      }
    };
    this.dollyRelativeTowardsPoint = function(deltaDistance, target) {
      if (Math.abs(deltaDistance) <= kEpsilon) {
        return;
      }
      this.saveCOI();
      this.setPivotPoint(target, true, false);
      this.dollyRelativeTowardsCOI(deltaDistance);
      this.restoreCOI();
    };
    this.dollyRelativeTowardsCOI = function(deltaDistance) {
      if (Math.abs(deltaDistance) <= kEpsilon) {
        return;
      }
      deltaDistance *= this.getDollySpeed();
      var dolly = myPivotPoint.clone().sub(myPosition);
      var oldLength = dolly.length();
      var newLength = oldLength + deltaDistance;
      if (newLength < kMinDistance) {
        newLength = kMinDistance;
      }
      var scaleFactor = newLength / oldLength;
      if (Math.abs(scaleFactor - 1) > kEpsilon) {
        dolly.multiplyScalar(scaleFactor);
        dolly.set(-dolly.x, -dolly.y, -dolly.z);
        dolly.add(myPivotPoint);
        this.setView(dolly, myPivotPoint, myTrackOffset.x * scaleFactor, myTrackOffset.y * scaleFactor);
      }
    };
    this.setView = function(pos, coi, panx, pany, forceForward) {
      var view = new THREE.Vector3;
      view.subVectors(pos, coi);
      var azim = 0;
      var elev = 0;
      var dist = kDefaultDistance;
      var lengthSquared = view.lengthSq();
      if (lengthSquared > 0) {
        var up = this.getCurrentUpVector();
        var right = this.getCurrentRightVector();
        var back = right.clone().cross(up).normalize();
        var projUp = up.dot(view);
        var projRight = right.dot(view);
        var projBack = back.dot(view);
        var xz = new THREE.Vector2(projRight, projBack);
        var d = xz.length();
        elev = Math.atan2(projUp, d);
        azim = Math.atan2(projRight, projBack);
        dist = Math.sqrt(lengthSquared);
        myPivotBehind = forceForward ? false : view.dot(this.getEyeVector()) > 0;
      }
      myPivotPoint.copy(coi);
      myPosition.copy(pos);
      myTrackOffset.set(panx || 0, pany || 0);
      myViewDirty = true;
      this.look(azim, elev, dist, false);
    };
    this.look = function(a, e, d, doUpdate) {
      if (d < kMinDistance) {
        d = kMinDistance;
      }
      if (a > kTwo_PI) {
        a -= kTwo_PI;
      } else {
        if (a < 0) {
          a += kTwo_PI;
        }
      }
      e += kHalf_PI;
      if (e > kTwo_PI) {
        e -= kTwo_PI;
      } else {
        if (e < 0) {
          e += kTwo_PI;
        }
      }
      myCameraFlipped = e > Math.PI;
      e -= kHalf_PI;
      if (Math.abs(myAzimuth - a) > kEpsilon || (Math.abs(myElevation - e) > kEpsilon || Math.abs(myDistance - d) > kEpsilon)) {
        myViewDirty = true;
      }
      myAzimuth = a;
      myElevation = e;
      myDistance = d;
      myTrackingDistance = d;
      if (doUpdate) {
        var rotate = new THREE.Quaternion;
        var up = this.getCurrentUpVector();
        var right = this.getCurrentRightVector();
        var back = right.clone().cross(up).normalize();
        rotate.setFromAxisAngle(right, -myElevation);
        back.applyQuaternion(rotate);
        rotate.setFromAxisAngle(up, myAzimuth);
        back.applyQuaternion(rotate);
        myPosition.set(myPivotPoint.x, myPivotPoint.y, myPivotPoint.z);
        myPosition.add(back.multiplyScalar(myDistance));
        myViewDirty = true;
      }
    };
    this.updateCamera = function() {
      viewerApi.navigation.setView(this.getPosition(), this.getLookAtPoint());
      if (!viewerApi.navigation.getPivotSetFlag()) {
        myPivotPoint.copy(myCamera.target);
        myPosition.copy(myCamera.position);
        myTrackOffset.set(0, 0);
      }
      viewerApi.navigation.setPivotPoint(myPivotPoint);
      viewerApi.navigation.updateCamera();
      myViewDirty = false;
    };
    this.oneStepTowards = function(newPos, newCoi, newFov, nSteps) {
      var offx, offy;
      if (nSteps > 1) {
        var stepSize = 1 / nSteps;
        var oneMinusStep = 1 - stepSize;
        var pos = newPos.clone().multiplyScalar(stepSize);
        var coi = newCoi.clone().multiplyScalar(stepSize);
        offx = myTrackOffset.x * oneMinusStep;
        offy = myTrackOffset.y * oneMinusStep;
        myPosition.multiplyScalar(oneMinusStep).add(pos);
        myPivotPoint.multiplyScalar(oneMinusStep).add(coi);
        myCamera.fov = myCamera.fov * oneMinusStep + newFov * stepSize;
      } else {
        offx = offy = 0;
        myPosition.copy(newPos);
        myPivotPoint.copy(newCoi);
        myCamera.fov = newFov;
      }
      this.setView(myPosition, myPivotPoint, offx, offy, true);
    };
    this.changeFOV = function(fov) {
      if (fov < kMinFOV) {
        fov = kMinFOV;
      } else {
        if (fov > kMaxFOV) {
          fov = kMaxFOV;
        }
      }
      if (fov === myCamera.fov) {
        return;
      }
      if (this.coiIsVisible()) {
        var oldFOV = THREE.Math.degToRad(myCamera.fov);
        var newFOV = THREE.Math.degToRad(fov);
        var distance = myDistance * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
        this.look(myAzimuth, myElevation, distance, true);
      }
      myCamera.fov = fov;
      myViewDirty = true;
    };
  }
  function PivotIndicator(viewerImpl) {
    var kFadeTimeMilliseconds = 750;
    var kIndicatorColor = 32512;
    var kIndicatorOpacity = 0.6;
    var myFadeTime = 0;
    var myGeometry = new THREE.SphereGeometry(1);
    var myMaterialPre = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
    var myMaterialPost = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
    var myMesh = new THREE.Mesh(myGeometry, myMaterialPost);
    var myViewer = viewerImpl;
    myViewer.createOverlayScene("pivot", myMaterialPre, myMaterialPost);
    myMesh.visible = false;
    this.shown = function() {
      return myMesh.visible;
    };
    this.show = function(position, scale, fade) {
      myMesh.scale.x = scale;
      myMesh.scale.y = scale;
      myMesh.scale.z = scale;
      myMesh.position.set(position.x, position.y, position.z);
      myMaterialPost.opacity = kIndicatorOpacity;
      myMaterialPre.opacity = kIndicatorOpacity;
      myMesh.visible = true;
      myViewer.addOverlay("pivot", myMesh);
      if (fade) {
        myFadeTime = Date.now() + kFadeTimeMilliseconds;
      } else {
        myFadeTime = 0;
      }
    };
    this.hide = function() {
      if (myMesh.visible) {
        myMesh.visible = false;
        myViewer.removeOverlay("pivot", myMesh);
        myFadeTime = 0;
      }
    };
    this.fade = function() {
      if (myFadeTime > 0) {
        var fadeDelta = myFadeTime - Date.now();
        if (fadeDelta <= 0) {
          this.hide();
          return true;
        }
        var opacity = fadeDelta / kFadeTimeMilliseconds * kIndicatorOpacity;
        myMaterialPre.opacity = opacity;
        myMaterialPost.opacity = opacity;
        return true;
      }
      return false;
    };
    this.fading = function() {
      return myFadeTime > 0;
    };
  }
  function RollInteraction(viewer, camera) {
    var kRollColor = 12303291;
    var kHudFov = 30;
    var kHudWorldScale = 2 * Math.tan(THREE.Math.degToRad(kHudFov * 0.5));
    var myMaterialPre = new THREE.MeshPhongMaterial({color:kRollColor, ambient:kRollColor, opacity:0.5, transparent:true});
    var myMaterialPost = new THREE.MeshPhongMaterial({color:kRollColor, ambient:kRollColor, opacity:0.5, transparent:true});
    var myVec1 = new THREE.Vector3;
    var myVec2 = new THREE.Vector3;
    var myRotate = new THREE.Quaternion;
    var myCamera = new THREE.PerspectiveCamera(camera.fov, camera.aspect, camera.near, camera.far);
    var mySceneCamera = camera;
    var myViewer = viewer;
    var kRingSizeMin = 0.55;
    var kRingSizeMax = 0.85;
    var myRingShrink = 1;
    var myLookAtPoint = null;
    var myReferenceCircle = null;
    var myReferenceXaxis = null;
    var myReferenceYaxis = null;
    var myReferenceZaxis = null;
    var myReferenceGeometry = null;
    var myReferenceUp = null;
    var mySnapPoints = null;
    var mySnapFlags = null;
    var mySnapAngles = new Array(6);
    var myClosestAngle = 0;
    var myRollAngle = 0;
    var myAnglesFlipped = false;
    var myCurrentlySnapped = true;
    var mySnappedRoll = 0;
    var kSnapEqualThreshold = 0.1 * Math.PI / 180;
    var kSnapInThreshold = 5 * Math.PI / 180;
    var kSnapOutThreshold = 7 * Math.PI / 180;
    var kNOSNAP = 1E3;
    var kAliasLengthThreshold = 0.1;
    myViewer.createOverlayScene("roll", myMaterialPre, myMaterialPost, myCamera);
    function angleDiff(a, b) {
      var diff = Math.abs(a - b);
      if (diff > kTwo_PI) {
        return diff;
      }
      return Math.min(kTwo_PI - diff, diff);
    }
    function isThisAxis(index, worldUp) {
      var snapVec = getSnapVector(index);
      if (snapVec.distanceToSquared(worldUp) < kEpsilon) {
        return true;
      }
      myVec2.set(-worldUp.x, -worldUp.y, -worldUp.z);
      return snapVec.distanceToSquared(myVec2) < kEpsilon;
    }
    function filterSnapAngles(snapLengths, worldUp) {
      var kAliasSnapThreshold = kSnapInThreshold + kSnapOutThreshold + 2 * Math.PI / 180;
      for (var i = 0;i < 6;++i) {
        if (mySnapAngles[i] === kNOSNAP) {
          continue;
        }
        for (var j = i + 1;j < 6;++j) {
          if (mySnapAngles[j] === kNOSNAP) {
            continue;
          }
          var diff = angleDiff(mySnapAngles[i], mySnapAngles[j]);
          if (diff < kAliasSnapThreshold) {
            if (snapLengths[i] < snapLengths[j] && !isThisAxis(i, worldUp) || isThisAxis(j, worldUp)) {
              mySnapAngles[i] = kNOSNAP;
              break;
            } else {
              mySnapAngles[j] = kNOSNAP;
            }
          }
        }
      }
    }
    function oppositeAngle(angle) {
      if (angle > kTwo_PI) {
        return angle;
      }
      if (angle <= 0) {
        return angle + Math.PI;
      }
      return angle - Math.PI;
    }
    function updateSnapPoints(viewVec, cameraUp, worldUp) {
      var normal = viewVec.clone().normalize();
      var snaps = new Array(3);
      var lengths = new Array(6);
      snaps[0] = projectAxis(1, 0, 0, normal);
      snaps[1] = projectAxis(0, 1, 0, normal);
      snaps[2] = projectAxis(0, 0, 1, normal);
      var i;
      var left = cameraUp.clone().cross(normal).normalize();
      for (i = 0;i < 3;++i) {
        var snap = snaps[i];
        lengths[i] = snap.length();
        if (lengths[i] < kAliasLengthThreshold) {
          mySnapAngles[i] = kNOSNAP;
        } else {
          snap.multiplyScalar(1 / lengths[i]);
          mySnapAngles[i] = Math.atan2(left.dot(snap), cameraUp.dot(snap));
        }
      }
      mySnapAngles[3] = oppositeAngle(mySnapAngles[0]);
      mySnapAngles[4] = oppositeAngle(mySnapAngles[1]);
      mySnapAngles[5] = oppositeAngle(mySnapAngles[2]);
      lengths[3] = lengths[0];
      lengths[4] = lengths[1];
      lengths[5] = lengths[2];
      filterSnapAngles(lengths, worldUp);
      for (i = 0;i < 6;++i) {
        if (mySnapAngles[i] !== kNOSNAP) {
          var z = myVec2.set(0, 0, 1);
          myRotate.setFromAxisAngle(z, mySnapAngles[i]);
          var pos = myVec2.set(0, 0.54, 0);
          pos.applyQuaternion(myRotate);
          mySnapPoints[i].position.copy(pos);
          mySnapPoints[i].visible = true;
        } else {
          mySnapPoints[i].visible = false;
        }
      }
    }
    function buildReferenceGeometry() {
      myReferenceGeometry = new THREE.Object3D;
      var geom = new THREE.RingGeometry(0.49, 0.5, 60);
      var circle = new THREE.Mesh(geom, myMaterialPre);
      myReferenceCircle = circle;
      var geomX = new THREE.BoxGeometry(0.93, 0.007, 0.007);
      var geomY = new THREE.BoxGeometry(0.007, 0.93, 0.007);
      var geomZ = new THREE.BoxGeometry(0.007, 0.007, 0.93);
      myReferenceXaxis = new THREE.Mesh(geomX, myMaterialPre);
      myReferenceYaxis = new THREE.Mesh(geomY, myMaterialPre);
      myReferenceZaxis = new THREE.Mesh(geomZ, myMaterialPre);
      myReferenceGeometry.add(myReferenceXaxis);
      myReferenceGeometry.add(myReferenceYaxis);
      myReferenceGeometry.add(myReferenceZaxis);
      myReferenceUp = new THREE.Mesh(new THREE.CircleGeometry(0.005), myMaterialPre);
      myReferenceGeometry.add(myReferenceUp);
      mySnapPoints = new Array(6);
      mySnapFlags = new Array(6);
      for (var i = 0;i < 6;++i) {
        mySnapPoints[i] = new THREE.Mesh(new THREE.CircleGeometry(0.005, 16), myMaterialPre);
        mySnapFlags[i] = new THREE.Mesh(new THREE.CircleGeometry(0.0025, 16), myMaterialPre);
        mySnapFlags[i].visible = false;
        mySnapPoints[i].add(mySnapFlags[i]);
        circle.add(mySnapPoints[i]);
      }
      myReferenceGeometry.add(circle);
      return myReferenceGeometry;
    }
    function getReferenceGeometry(scale, lookAtPoint, viewVec, worldUp, cameraUp) {
      if (!myReferenceGeometry) {
        myReferenceGeometry = buildReferenceGeometry();
      }
      orient(myReferenceCircle, lookAtPoint, myCamera.position, worldUp);
      updateSnapPoints(viewVec, cameraUp, worldUp);
      myReferenceGeometry.scale.x = scale;
      myReferenceGeometry.scale.y = scale;
      myReferenceGeometry.scale.z = scale;
      myReferenceGeometry.position.copy(lookAtPoint);
      return myReferenceGeometry;
    }
    function getSnapVector(index) {
      myVec1.set(0, 0, 0);
      if (index >= 0) {
        var v = index >= 3 ? -1 : 1;
        index %= 3;
        if (index === 0) {
          myVec1.x = v;
        }
        if (index === 1) {
          myVec1.y = v;
        }
        if (index === 2) {
          myVec1.z = v;
        }
      }
      if (myAnglesFlipped) {
        myVec1.multiplyScalar(-1);
      }
      return myVec1;
    }
    function closestSnap(dtheta, snapThresh) {
      var diff = angleDiff(mySnapAngles[0], dtheta);
      var closest = 0;
      for (var i = 1;i < 6;++i) {
        var d = angleDiff(mySnapAngles[i], dtheta);
        if (d < diff) {
          diff = d;
          closest = i;
        }
      }
      myClosestAngle = diff;
      return diff < snapThresh ? closest : -1;
    }
    function applyRoll(angle, client) {
      if (angle === 0) {
        return;
      }
      var kStableRollThreshold = 30 * Math.PI / 180;
      var view = myVec2.copy(myCamera.position).sub(myLookAtPoint).normalize();
      myRotate.setFromAxisAngle(view, angle);
      var up = myVec1.copy(client.getWorldUp());
      var viewUpAngle = Math.abs(view.angleTo(up));
      if (viewUpAngle < kStableRollThreshold || Math.PI - viewUpAngle < kStableRollThreshold) {
        up.copy(client.getCameraUp());
      }
      up.applyQuaternion(myRotate);
      client.setWorldUp(up, true);
    }
    function justNowSnapped() {
      if (!myCurrentlySnapped) {
        var closest = closestSnap(myRollAngle, kSnapInThreshold);
        if (closest >= 0) {
          myClosestAngle = 0;
          myCurrentlySnapped = true;
          myRollAngle = mySnapAngles[closest];
          return getSnapVector(closest);
        }
      }
      return false;
    }
    function justNowUnsnapped() {
      if (myCurrentlySnapped) {
        var closest = closestSnap(myRollAngle, kSnapOutThreshold);
        if (closest < 0) {
          myCurrentlySnapped = false;
          return true;
        }
        myClosestAngle = 0;
      }
      return false;
    }
    function isReallySnapped(angle, threshold, i, worldUp) {
      var circleSnapped = angle < threshold;
      if (circleSnapped) {
        var snapUp = getSnapVector(i);
        return snapUp.distanceToSquared(worldUp) < kEpsilon;
      }
      return false;
    }
    function updateIndicators(worldUp, cameraUp) {
      var wDotC = worldUp.dot(cameraUp);
      var flipped = wDotC < 0;
      if (flipped) {
        cameraUp = cameraUp.clone().multiplyScalar(-1);
      }
      orient(myReferenceUp, myLookAtPoint, myCamera.position, cameraUp);
      myReferenceUp.position.copy(cameraUp.multiplyScalar(0.495));
      var isSnapped = false;
      var threshold = myCurrentlySnapped ? kSnapOutThreshold : kSnapInThreshold;
      for (var i = 0;i < 6;++i) {
        var angle = angleDiff(mySnapAngles[i], myRollAngle);
        var snapped = isReallySnapped(angle, threshold, i, worldUp);
        if (snapped) {
          isSnapped = true;
        }
        var proximityScale = snapped ? 4 : (1 - 3 * angle / Math.PI) * 3;
        if (proximityScale < 1) {
          proximityScale = 1;
        }
        proximityScale *= myRingShrink;
        mySnapFlags[i].visible = snapped;
        var snap = mySnapPoints[i];
        snap.scale.x = proximityScale;
        snap.scale.y = proximityScale;
        snap.scale.z = proximityScale;
      }
      myReferenceXaxis.visible = isSnapped;
      myReferenceYaxis.visible = isSnapped;
      myReferenceZaxis.visible = isSnapped;
      return isSnapped;
    }
    this.updateRollCamera = function(size, distance) {
      myCamera.position.copy(mySceneCamera.position);
      myCamera.quaternion.copy(mySceneCamera.quaternion);
      myCamera.up.copy(mySceneCamera.up);
      myCamera.aspect = mySceneCamera.aspect;
      myCamera.fov = kHudFov;
      if (size && distance) {
        myCamera.near = distance - size;
        myCamera.far = distance + size;
      }
      myCamera.updateProjectionMatrix();
    };
    this.isSnapped = function() {
      return myCurrentlySnapped;
    };
    this.start = function(lookAtPoint, worldUp, cameraUp) {
      myLookAtPoint = lookAtPoint;
      var ringSize = (kRingSizeMin + kRingSizeMax) * 0.5;
      myRingShrink = kRingSizeMax / ringSize;
      var viewVec = myVec1.copy(lookAtPoint).sub(mySceneCamera.position);
      var distance = viewVec.length();
      var worldHeight = distance * kHudWorldScale;
      var worldSize = worldHeight * ringSize;
      this.updateRollCamera(worldSize, distance);
      myViewer.addOverlay("roll", getReferenceGeometry(worldSize, lookAtPoint, viewVec, worldUp, cameraUp));
      myRollAngle = 0;
      mySnappedRoll = 0;
      var wDotC = worldUp.dot(cameraUp);
      myAnglesFlipped = wDotC < 0;
      myCurrentlySnapped = updateIndicators(worldUp, cameraUp);
    };
    this.handleRoll = function(dx, dy, p2, client) {
      this.updateRollCamera();
      updateIndicators(client.getWorldUp(), client.getCameraUp());
      if (dx !== 0 || dy !== 0) {
        var v1x = p2.x - dx - 0.5;
        var v1y = p2.y - dy - 0.5;
        var v2x = p2.x - 0.5;
        var v2y = p2.y - 0.5;
        return handleRollByAngle(Math.atan2(v2y, v2x) - Math.atan2(v1y, v1x), client);
      }
      return false;
    };
    this.handleRollTouch = function(p1a, p2a, p1b, p2b, client) {
      this.updateRollCamera();
      updateIndicators(client.getWorldUp(), client.getCameraUp());
      var angle = Math.atan2(p2b.y - p1b.y, p2b.x - p1b.x) - Math.atan2(p2a.y - p1a.y, p2a.x - p1a.x);
      return handleRollByAngle(angle, client);
    };
    function handleRollByAngle(angle, client) {
      myRollAngle += angle;
      if (myRollAngle > Math.PI) {
        myRollAngle = myRollAngle - kTwo_PI;
      } else {
        if (myRollAngle <= -Math.PI) {
          myRollAngle = kTwo_PI + myRollAngle;
        }
      }
      var snappedUp = justNowSnapped();
      if (snappedUp) {
        mySnappedRoll = myRollAngle;
        client.setWorldUp(snappedUp, true);
      } else {
        if (justNowUnsnapped()) {
          var deltaRoll = myRollAngle - mySnappedRoll;
          applyRoll(deltaRoll, client);
          mySnappedRoll = 0;
        } else {
          if (!myCurrentlySnapped) {
            applyRoll(angle, client);
          }
        }
      }
      return true;
    }
    this.end = function() {
      myViewer.removeOverlay("roll", myReferenceGeometry);
    };
  }
  THREE.EventDispatcher.call(this);
  this.camera = viewerImpl.camera;
  this.domElement = viewerImpl.canvas;
  this.downX = -1;
  this.downY = -1;
  this.isDragging = false;
  this.inTouch = false;
  var _currentController = new TurntableView(this.camera);
  var kDampingFactor = 0.6;
  var kDollyScale = 0.6;
  var kDollyDragScale = 100;
  var kTouchDollyScale = -60;
  var kOrbitDragScale = kDampingFactor;
  var kFovDragScale = -1;
  var kIndicatorPixelSize = 5;
  var kClickThreshold = 2;
  var kAutoDeltaXY = 0.01;
  var kAutoScreenXY = 20;
  var kAutoDeltaZ = 1.5;
  var kTransitionFrames = 10;
  var kWheelThresholdMs = 100;
  var kDoubleClickDelayThreshold = 500;
  var kTouchSwapThreshold = 2.9;
  var kMoveThreshold = 6;
  var kColinearityThreshold = Math.cos(45 * Math.PI / 180);
  var kRotateDistanceThreshold = 6;
  var kRotateStopThreshold = Math.tan(45 * Math.PI / 180);
  var kPinchDistanceThreshold = 7;
  var kPinchStopThreshold = Math.tan(20 * Math.PI / 180);
  var kTapThreshold = 8;
  var kDoubleTapThreshold = 32;
  var kTapLength = 300;
  var kDoubleTapDelay = 300;
  var kHoldFlag = 1;
  var kMoveFlag = 2;
  var kSwipeFlag = 4;
  var kPinchFlag = 8;
  var kTwistFlag = 16;
  var kNone = -5;
  var kKeyboard = -4;
  var kSingleTouch = -3;
  var kMultiTouch = -2;
  var kWheel = -1;
  var kMouseLeft = 0;
  var kMouseMiddle = 1;
  var kMouseRight = 2;
  var _activeMode = -1;
  var _activeModeLocked = false;
  var _autoCam = null;
  var _autoCamStartXY = null;
  var _client = viewerImpl;
  var _commandKeyDown = false;
  var _startXYZ = new THREE.Vector3;
  var _moveXYZ = new THREE.Vector3;
  var _startXY = new THREE.Vector2;
  var _moveXY = new THREE.Vector2;
  var _deltaXY = new THREE.Vector2;
  var _wheelAccum = 0;
  var _wheelOldest = null;
  var _wheelNewest = null;
  var _wheelContinuous = false;
  var _lastMouseX, _lastMouseY;
  var _motionDelta = new THREE.Vector3;
  var _autoMove = [false, false, false, false, false, false];
  var _modifierState = {SHIFT:0, ALT:0, CONTROL:0, SPACE:0, F1:0, F2:0, F3:0, F4:0, LOCK_PAN:0, LOCK_DOLLY:0, LOCK_FOV:0, LOCK_ROLL:0};
  var _activeTrigger = kNone;
  var _selector = null;
  var _pivotIndicator = new PivotIndicator(viewerImpl);
  var _rollInteraction = new RollInteraction(viewerImpl, this.camera);
  var _needNextRefresh = false;
  var _needRefresh = false;
  var _tumbled = false;
  var _interactionActive = false;
  var _upTransition = 0;
  var _upTarget = null;
  var _viewTransition = 0;
  var _viewTargetPos = null;
  var _viewTargetCoi = null;
  var _viewTargetFov = null;
  var _prevTouches = [];
  var _currTouches = [];
  var _prevPinch = null;
  var _currPinch = null;
  var _prevCentroid = null;
  var _currCentroid = null;
  var _gestureFlags = 0;
  var _projector = new THREE.Projector;
  var _tapBeginX = -1;
  var _tapBeginY = -1;
  var _tapBeginTime = -1;
  var _taps = [];
  var _doubleTapTimer = null;
  var _is2d = false;
  var _wheelPivots = false;
  var _checkMouseDoubleClick = {};
  var _navigating = false;
  var _this = this;
  var _keys = {BACKSPACE:8, TAB:9, ENTER:13, SHIFT:16, CONTROL:17, ALT:18, ESCAPE:27, SPACE:32, LCOMMAND:91, RCOMMAND:93, PAGEUP:33, PAGEDOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, INSERT:45, DELETE:46, ZERO:48, SEMICOLONMOZ:59, EQUALSMOZ:61, d:68, f:70, h:72, o:79, p:80, x:88, y:89, z:90, DASHMOZ:109, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, DASHMOZNEW:173, SEMICOLON:186, EQUALS:187, COMMA:188, DASH:189, PERIOD:190, SLASH:191, 
  LBRACKET:219, RBRACKET:221, SINGLEQUOTE:222, COMMANDMOZ:224};
  this.homePosition = new THREE.Vector3(0, 0, 1);
  this.homeTarget = new THREE.Vector3(0, 0, 0);
  this.homeUp = new THREE.Vector3(0, 1, 0);
  this.homeFov = this.camera.fov;
  if (_wheelPivots) {
    _pivotIndicator.hide();
  }
  function triggerMode(mode) {
    if (_activeMode !== mode) {
      viewerApi.fireEvent({type:Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, value:mode});
      _activeMode = mode;
    }
  }
  this.setAutocam = function(autocam) {
    _autoCam = autocam;
    _autoCam.sync(this.camera, true);
    _autoCam.orbitMultiplier = _currentController.getLookSpeed();
  };
  this.setViewpoint = function(position, coi, up) {
    if (!viewerApi.navigation.getIsLocked()) {
      _currentController.setView(position, coi, 0, 0, true);
      if (up) {
        this.camera.up.copy(up);
        _currentController.checkCameraUp();
      }
    }
  };
  this.setCOI = function(coi, preserveView, centerView, isset) {
    if (preserveView && !centerView || !viewerApi.navigation.getIsLocked()) {
      _currentController.setPivotPoint(coi, preserveView, isset);
      if (centerView) {
        var pos = _currentController.getPosition();
        this.transitionView(pos, coi, this.camera.fov, this.getWorldUp());
        this.pivotActive(_currentController.pivotIsSet());
      } else {
        if (_pivotIndicator.shown()) {
          this.activatePivot(_pivotIndicator.fading());
        }
      }
    }
  };
  this.syncCamera = function() {
    this.setViewpoint(this.camera.position, this.camera.target, this.camera.up);
    if (this.camera.pivot && this.camera.pivot.distanceToSquared(this.camera.target) > 0) {
      this.setCOI(this.camera.pivot, true, false);
    }
  };
  this.setSelector = function(selector) {
    _selector = selector;
  };
  this.getNavigationMode = function() {
    return _activeMode;
  };
  this.setNavigationMode = function(mode) {
    if (mode !== this.getNavigationMode()) {
      _modifierState.LOCK_DOLLY = 0;
      _modifierState.LOCK_PAN = 0;
      _modifierState.LOCK_ROLL = 0;
      _modifierState.LOCK_FOV = 0;
      switch(mode) {
        case Autodesk.Viewing.NAVIGATION_MODE.ORBIT:
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.PAN:
          _modifierState.LOCK_PAN = 1;
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.DOLLY:
          _modifierState.LOCK_DOLLY = 1;
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.ROLL:
          _modifierState.LOCK_ROLL = 1;
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.FOV:
          _modifierState.LOCK_FOV = 1;
          break;
      }
    }
  };
  this.recordHomeView = function() {
    this.homePosition.copy(_currentController.getPosition());
    this.homeTarget.copy(_currentController.getLookAtPoint());
    this.homeUp.copy(_currentController.getWorldUpVector());
    this.homeFov = this.camera.fov;
    if (_autoCam) {
      _autoCam.setHomeViewFrom(this.camera);
    }
  };
  this.goHome = function() {
    if (!viewerApi.navigation.getIsLocked()) {
      if (!_autoCam) {
        viewerApi.navigation.setPivotSetFlag(false);
        this.transitionView(this.homePosition, this.homeTarget, this.homeFov, this.homeUp);
      } else {
        _autoCam.goHome();
      }
    }
  };
  this.getBoundingBox = function(ignoreSelection) {
    var bounds;
    if (!ignoreSelection && _selector !== null) {
      bounds = _selector.getSelectionBounds();
    }
    if (!bounds || bounds.empty()) {
      bounds = _client.getVisibleBounds();
    }
    return bounds;
  };
  this.setWorldUp = function(newUp, reorient) {
    if (newUp && newUp.lengthSq() > 0) {
      _currentController.setWorldUpVector(newUp, reorient);
      if (_autoCam) {
        _autoCam.setWorldUpVector(newUp);
      }
      _client.setWorldUp(newUp);
      _needRefresh = true;
    }
  };
  this.getCOI = function() {
    return _currentController.getPivotPoint();
  };
  this.getLookAtPoint = function() {
    return _currentController.getLookAtPoint();
  };
  this.transitionWorldUp = function(x, y, z) {
    _upTarget = (new THREE.Vector3(x, y, z)).normalize();
    var oldUp = _currentController.getWorldUpVector();
    _upTransition = kTransitionFrames;
    var upDelta = _upTarget.clone().sub(oldUp);
    upDelta.multiplyScalar(1 / _upTransition);
    this.setWorldUp(oldUp.add(upDelta), true);
    --_upTransition;
  };
  this.getWorldUp = function() {
    return _currentController.getWorldUpVector();
  };
  this.getCameraUp = function() {
    return _currentController.getCameraUpVector();
  };
  this.getFOV = function() {
    return this.camera.fov;
  };
  this.setFOV = function(degrees) {
    _currentController.changeFOV(degrees);
  };
  this.getFocalLength = function() {
    return fov2fl(this.camera.fov);
  };
  this.setFocalLength = function(millimeters) {
    _currentController.changeFOV(fl2fov(millimeters));
  };
  function computeOrthogonalUp(pos, coi, worldUp) {
    var eye = coi.clone().sub(pos);
    if (eye.lengthSq() === 0) {
      return eye.copy(worldUp);
    }
    var right = eye.clone().cross(worldUp);
    if (right.lengthSq() === 0) {
      if (worldUp.z > up.y) {
        eye.y -= 1E-4;
      } else {
        eye.z += 1E-4;
      }
      right.crossVectors(eye, up);
    }
    return right.cross(eye).normalize();
  }
  this.transitionView = function(pos, coi, fov, worldUp) {
    worldUp = worldUp || this.getWorldUp();
    if (_autoCam) {
      targetView = {position:pos, up:computeOrthogonalUp(pos, coi, worldUp), center:coi, pivot:coi, fov:fov, worldUp:worldUp};
      _autoCam.goToView(targetView);
    } else {
      viewerApi.navigation.setTransitionActive(true);
      _viewTransition = kTransitionFrames - 1;
      _viewTargetPos = pos;
      _viewTargetCoi = coi;
      _viewTargetFov = fov;
      _currentController.oneStepTowards(pos, coi, fov, kTransitionFrames);
      var currentUp = this.getWorldUp();
      if (worldUp !== currentUp && worldUp.clone().sub(currentUp).lengthSq() > 0) {
        this.transitionWorldUp(worldUp.x, worldUp.y, worldUp.z);
      }
    }
  };
  this.computeFit = function(oldpos, oldcoi, fov) {
    var boundingBox = this.getBoundingBox(false);
    return viewerApi.navigation.computeFit(oldpos, oldcoi, fov, boundingBox);
  };
  this.fitToView = function(immediate, boundingBox) {
    if (!boundingBox) {
      boundingBox = this.getBoundingBox(false);
    }
    var fit = viewerApi.navigation.fitBounds(immediate, boundingBox);
    this.activatePivot(true);
    return fit;
  };
  this.handleEvent = function(event) {
    if (typeof this[event.type] === "function") {
      this[event.type](event);
    }
  };
  this.activatePivot = function(fadeIt) {
    var distance = _currentController.getPivotDistance();
    var worldHeight = 2 * distance * Math.tan(THREE.Math.degToRad(this.camera.fov * 0.5));
    var viewport = viewerApi.navigation.getScreenViewport();
    var devicePixelRatio = window.devicePixelRatio || 1;
    var indicatorSize = kIndicatorPixelSize * worldHeight / (viewport.height * devicePixelRatio);
    _pivotIndicator.show(_currentController.getPivotPoint(), indicatorSize, fadeIt);
  };
  this.pivotActive = function(state, fadeIt) {
    if (_is2d || _wheelPivots) {
      return;
    }
    fadeIt = fadeIt || false;
    if (!state && _pivotIndicator.shown()) {
      _pivotIndicator.hide();
      return;
    }
    if (state) {
      this.activatePivot(fadeIt);
    }
  };
  this.interactionStart = function(trigger, force) {
    if (force || trigger > _activeTrigger) {
      _activeTrigger = trigger;
      _interactionActive = true;
      if (_autoCam) {
        _autoCam.startInteraction(_startXY.x, _startXY.y);
        _autoCamStartXY = _startXY.clone();
      }
      this.pivotActive(_currentController.pivotIsSet(), trigger === kWheel);
    }
  };
  this.interactionCheck = function() {
    if (_autoMove[0] || (_autoMove[1] || (_autoMove[2] || (_autoMove[3] || (_autoMove[4] || (_autoMove[5] || (_modifierState.SHIFT || (_modifierState.CONTROL || (_modifierState.ALT || _modifierState.SPACE))))))))) {
      this.interactionStart(kKeyboard, true);
    }
    if (_currTouches.length > 0) {
      this.interactionStart(_currTouches.length === 1 ? kSingleTouch : kMultiTouch);
    }
  };
  this.interactionEnd = function(trigger) {
    if (trigger === _activeTrigger) {
      if (trigger !== kWheel) {
        this.pivotActive(false);
      }
      _interactionActive = false;
    }
  };
  this.autoMove = function(index, state) {
    if (index < 0) {
      _autoMove[0] = _autoMove[1] = _autoMove[2] = _autoMove[3] = _autoMove[4] = _autoMove[5] = state;
    } else {
      _autoMove[index] = state;
    }
    if (!state) {
      this.interactionEnd(kKeyboard);
    }
    this.interactionCheck();
  };
  function getHitPoint(x, y) {
    y = 1 - y;
    x = x * 2 - 1;
    y = y * 2 - 1;
    if (_is2d) {
      return _client.intersectGroundViewport(x, y);
    }
    var result = _client.castRayViewport(x, y, false);
    return result ? result.intersectPoint : null;
  }
  function getWorldPoint(x, y, camera) {
    y = 1 - y;
    x = x * 2 - 1;
    y = y * 2 - 1;
    var clickPoint = new THREE.Vector3(x, y, 0.5);
    _projector.unprojectVector(clickPoint, camera);
    var position = _currentController.getPosition();
    var direction = clickPoint.sub(position).normalize();
    var pivot = _currentController.getPivotPoint().clone();
    var view = _currentController.getEyeVector();
    var denominator = direction.dot(view);
    var distance = denominator !== 0 ? pivot.sub(position).dot(view) / denominator : pivot.sub(position).length();
    return direction.multiplyScalar(distance).add(position);
  }
  this.getMotionDelta = function(dxyz, dxy) {
    var navapi = viewerApi.navigation;
    var autoDeltaZ = navapi && navapi.getReverseZoomDirection() ? -kAutoDeltaZ : kAutoDeltaZ;
    if (isMac) {
      autoDeltaZ *= -1;
    }
    if (_autoMove[0]) {
      _moveXYZ.x += kAutoDeltaXY;
      _moveXY.x += kAutoScreenXY;
    }
    if (_autoMove[1]) {
      _moveXYZ.x -= kAutoDeltaXY;
      _moveXY.x -= kAutoScreenXY;
    }
    if (_autoMove[2]) {
      _moveXYZ.y += kAutoDeltaXY;
      _moveXY.y += kAutoScreenXY;
    }
    if (_autoMove[3]) {
      _moveXYZ.y -= kAutoDeltaXY;
      _moveXY.y -= kAutoScreenXY;
    }
    if (_autoMove[4]) {
      _moveXYZ.z += autoDeltaZ;
    }
    if (_autoMove[5]) {
      _moveXYZ.z -= autoDeltaZ;
    }
    var deltaX = _moveXYZ.x - _startXYZ.x;
    var deltaY = _moveXYZ.y - _startXYZ.y;
    var deltaZ = _moveXYZ.z - _startXYZ.z;
    if (Math.abs(deltaX) < kScreenEpsilon) {
      deltaX = 0;
    }
    if (Math.abs(deltaY) < kScreenEpsilon) {
      deltaY = 0;
    }
    if (Math.abs(deltaZ) < kScreenEpsilon) {
      deltaZ = 0;
    }
    dxyz.set(deltaX, deltaY, deltaZ);
    if (dxy) {
      dxy.set(_moveXY.x - _startXY.x, _moveXY.y - _startXY.y);
    }
  };
  this.stepMotionDelta = function(delta, damped) {
    if (damped) {
      _startXYZ.x += delta.x * kDampingFactor;
      _startXYZ.y += delta.y * kDampingFactor;
      _startXYZ.z += delta.z * kDampingFactor;
    } else {
      _startXYZ.copy(_moveXYZ);
    }
    _startXY.copy(_moveXY);
  };
  function checkForTouchDelta() {
    for (var i = 0;i < _currTouches.length;++i) {
      if (_currTouches[i].x !== _prevTouches[i].x || _currTouches[i].y !== _prevTouches[i].y) {
        return true;
      }
    }
    return false;
  }
  function promoteDelta(delta) {
    if (delta < 0 && delta > -3) {
      return-3;
    }
    return delta > 0 && delta < 3 ? 3 : delta;
  }
  this.getAccumulatedWheelDelta = function() {
    var now = Date.now();
    var delta = 0;
    if (_wheelNewest && now - _wheelNewest > kWheelThresholdMs) {
      delta = promoteDelta(_wheelAccum);
      _wheelAccum = 0;
      _wheelOldest = null;
      _wheelNewest = null;
      _wheelContinuous = false;
    } else {
      if (_wheelOldest && now - _wheelOldest > kWheelThresholdMs) {
        if (_wheelContinuous) {
          if (Math.abs(_wheelAccum) >= 3) {
            delta = _wheelAccum;
            _wheelAccum = 0;
          }
        } else {
          delta = promoteDelta(_wheelAccum);
          _wheelContinuous = true;
          _wheelAccum = 0;
        }
      }
    }
    return delta;
  };
  this.adjustSpeed = function(direction) {
    _currentController.adjustDollyLookSpeed(direction);
    if (_autoCam) {
      _autoCam.orbitMultiplier = _currentController.getLookSpeed();
    }
  };
  function isRoll() {
    return _modifierState.ALT && _modifierState.SHIFT || _modifierState.LOCK_ROLL;
  }
  function isTrack() {
    var mod = _modifierState;
    return _activeTrigger === kMouseRight && (!mod.SHIFT && (!mod.ALT && !mod.CONTROL)) || (_activeTrigger === kMouseMiddle && (!mod.SHIFT && !mod.CONTROL) || (_activeTrigger === kMouseMiddle && (mod.ALT && !mod.CONTROL) || (mod.SHIFT && (!mod.CONTROL && (!mod.ALT && _activeTrigger !== kMouseMiddle)) || (mod.LOCK_PAN && !mod.ALT || mod.SPACE))));
  }
  function isDolly() {
    var mod = _modifierState;
    return _activeTrigger === kMouseRight && (mod.SHIFT && (!mod.ALT && !mod.CONTROL)) || (_activeTrigger === kMouseRight && (mod.ALT && (!mod.SHIFT && !mod.CONTROL)) || (_activeTrigger === kMouseMiddle && (mod.CONTROL && (!mod.SHIFT && !mod.ALT)) || mod.LOCK_DOLLY && !mod.ALT));
  }
  function isFOV() {
    return _modifierState.CONTROL && _modifierState.SHIFT || _modifierState.LOCK_FOV;
  }
  function isTouchPanDolly() {
    return _activeTrigger === kMultiTouch && (_currTouches.length === 2 && (_activeMode === Autodesk.Viewing.NAVIGATION_MODE.TOUCH_PAN_DOLLY || _activeMode !== Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL && !!(_gestureFlags & (kSwipeFlag | kPinchFlag))));
  }
  function isTouchRoll() {
    return _activeTrigger === kMultiTouch && (_currTouches.length === 2 && (_activeMode === Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL || _activeMode !== Autodesk.Viewing.NAVIGATION_MODE.TOUCH_PAN_DOLLY && !!(_gestureFlags & kTwistFlag)));
  }
  function initTracking(camera, x, y) {
    var distance = _currentController.getPivotDistance();
    var p = getHitPoint(x, y);
    if (p) {
      var hitToEye = p.sub(_currentController.getPosition());
      var view = _currentController.getEyeVector().normalize();
      distance = Math.abs(view.dot(hitToEye));
    }
    _currentController.setTrackingDistance(distance);
  }
  this.checkInteractionMode = function() {
    var newMode = isTouchPanDolly() ? Autodesk.Viewing.NAVIGATION_MODE.TOUCH_PAN_DOLLY : isTouchRoll() ? Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL : isRoll() ? Autodesk.Viewing.NAVIGATION_MODE.ROLL : isFOV() ? Autodesk.Viewing.NAVIGATION_MODE.FOV : isDolly() || _motionDelta.z !== 0 ? Autodesk.Viewing.NAVIGATION_MODE.DOLLY : isTrack() ? Autodesk.Viewing.NAVIGATION_MODE.PAN : Autodesk.Viewing.NAVIGATION_MODE.ORBIT;
    if (newMode !== _activeMode) {
      if (_activeMode === Autodesk.Viewing.NAVIGATION_MODE.ROLL || _activeMode === Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL) {
        _rollInteraction.end();
        _currentController.restoreCOI();
        viewerApi.navigation.setIsLocked(false);
        _needRefresh = true;
      }
      switch(newMode) {
        case Autodesk.Viewing.NAVIGATION_MODE.ROLL:
        ;
        case Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL:
          var lookAtPoint = _currentController.getLookAtPoint();
          var viewVec = lookAtPoint.sub(this.camera.position);
          var distance = (this.camera.near + this.camera.far) * 0.5;
          viewVec.normalize().multiplyScalar(distance);
          lookAtPoint = viewVec.add(this.camera.position);
          _currentController.saveCOI();
          _currentController.setPivotPoint(lookAtPoint, true, false);
          this.pivotActive(true);
          viewerApi.navigation.setIsLocked(true);
          viewerApi.navigation.setPivotSetFlag(true);
          _rollInteraction.start(lookAtPoint, this.getWorldUp(), _currentController.getCameraUpVector());
          _needRefresh = true;
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.PAN:
          initTracking(this.camera, _moveXYZ.x, _moveXYZ.y);
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.TOUCH_PAN_DOLLY:
          initTracking(this.camera, _prevCentroid.x, _prevCentroid.y);
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.FOV:
          _wheelAccum = 0;
          _wheelOldest = null;
          _wheelNewest = null;
          _wheelContinuous = false;
          break;
        default:
          break;
      }
      triggerMode(newMode);
    }
  };
  function getTouchCentroid(touchset) {
    var viewport = _this.domElement.getBoundingClientRect();
    var width = viewport.width;
    var height = viewport.height;
    var C = {};
    C.x = touchset.reduce(function(accum, elem) {
      return accum + elem.x;
    }, 0) / touchset.length;
    C.y = touchset.reduce(function(accum, elem) {
      return accum + elem.y;
    }, 0) / touchset.length;
    C.scaledX = C.x / width;
    C.scaledY = C.y / height;
    return C;
  }
  function getTwoFingerMagnitude(touchset) {
    var viewport = _this.domElement.getBoundingClientRect();
    var width = viewport.width;
    var height = viewport.height;
    var x0 = touchset[0].x / width;
    var y0 = touchset[0].y / height;
    var x1 = touchset[1].x / width;
    var y1 = touchset[1].y / height;
    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));
  }
  function parseGesture(C, prevC, points, prevPoints) {
    var dCx = C.x - prevC.x;
    var dCy = C.y - prevC.y;
    var dCLen = Math.sqrt(dCx * dCx + dCy * dCy);
    var centroidMoved = dCLen > kMoveThreshold;
    var movingPoints = 0;
    var followingPoints = 0;
    var expandingPoints = 0;
    var shrinkingPoints = 0;
    var rotating = 0;
    var clockwise = 0;
    var pcnt = prevPoints.length;
    for (var i = 0;i < pcnt;++i) {
      var tx = points[i].x - prevPoints[i].x;
      var ty = points[i].y - prevPoints[i].y;
      var tLen = Math.sqrt(tx * tx + ty * ty);
      if (tLen > kMoveThreshold) {
        movingPoints += 1;
        var val = (dCx * tx + dCy * ty) / (dCLen * tLen);
        if (centroidMoved && val > kColinearityThreshold) {
          followingPoints++;
        }
      }
      tx = points[i].x - C.x;
      ty = points[i].y - C.y;
      var px = prevPoints[i].x - prevC.x;
      var py = prevPoints[i].y - prevC.y;
      var pLen = Math.sqrt(px * px + py * py);
      if (pLen > 0) {
        tLen = (tx * py - ty * px) / pLen;
        var expand = (tx * px + ty * py) / pLen - pLen;
        if (Math.abs(tLen) > kRotateDistanceThreshold && Math.abs(expand) <= Math.abs(tLen) * kRotateStopThreshold) {
          rotating++;
          if (tLen > 0) {
            clockwise++;
          }
        }
        if (Math.abs(expand) > kPinchDistanceThreshold && Math.abs(tLen) <= Math.abs(expand) * kPinchStopThreshold) {
          if (expand > 0) {
            expandingPoints++;
          } else {
            shrinkingPoints++;
          }
        }
      }
    }
    var flags = 0;
    if (movingPoints == 0 && !centroidMoved) {
      flags |= kHoldFlag;
    } else {
      flags |= kMoveFlag;
      if (pcnt == 1) {
        flags |= kSwipeFlag;
      } else {
        if (movingPoints > 0 && (followingPoints < pcnt && expandingPoints + shrinkingPoints == pcnt)) {
          flags |= kPinchFlag;
        }
        if (rotating == pcnt && (clockwise == 0 || clockwise == pcnt)) {
          flags |= kTwistFlag;
        }
        if (centroidMoved && followingPoints == pcnt) {
          flags |= kSwipeFlag;
        }
      }
    }
    return flags;
  }
  function parseTouches() {
    _currPinch = _prevPinch = _currCentroid = _prevCentroid = null;
    _gestureFlags = 0;
    if (_activeTrigger === kMultiTouch) {
      if (_currTouches.length === 2) {
        _currPinch = getTwoFingerMagnitude(_currTouches);
        _prevPinch = getTwoFingerMagnitude(_prevTouches);
      }
      _currCentroid = getTouchCentroid(_currTouches);
      _prevCentroid = getTouchCentroid(_prevTouches);
      _gestureFlags = parseGesture(_currCentroid, _prevCentroid, _currTouches, _prevTouches);
    }
  }
  function stepTouches() {
    for (var i = 0;i < _prevTouches.length;++i) {
      _prevTouches[i] = _currTouches[i];
    }
  }
  function isValidTap(tap) {
    var deltaX = Math.abs(tap.endX - tap.startX);
    var deltaY = Math.abs(tap.endY - tap.startY);
    var deltaT = tap.endTime - tap.startTime;
    var passThreshold = deltaX <= kTapThreshold && deltaY <= kTapThreshold;
    var passLength = deltaT <= kTapLength;
    var pass = passThreshold && passLength;
    return pass;
  }
  function isSingleTap(tap) {
    var delay = Date.now() - tap.endTime;
    return delay >= kDoubleTapDelay;
  }
  function isDoubleTap(tap1, tap2) {
    var delay = tap2.startTime - tap1.endTime;
    var deltaX = Math.abs(tap2.endX - tap1.startX);
    var deltaY = Math.abs(tap2.endY - tap1.startY);
    var passThreshold = deltaX <= kDoubleTapThreshold && deltaY <= kDoubleTapThreshold;
    var passDelay = delay <= kDoubleTapDelay;
    var pass = passThreshold && passDelay;
    return pass;
  }
  function processTaps() {
    if (_doubleTapTimer !== null) {
      clearTimeout(_doubleTapTimer);
      _doubleTapTimer = null;
    }
    while (_taps.length > 0) {
      var tap1 = _taps.shift();
      if (isValidTap(tap1)) {
        if (_taps.length > 0) {
          var tap2 = _taps.shift();
          if (isValidTap(tap2)) {
            if (isDoubleTap(tap1, tap2)) {
              _this.handleDoubleTap(tap1, tap2);
            } else {
              _this.handleSingleTap(tap1);
              _taps.unshift(tap2);
            }
          } else {
            _this.handleSingleTap(tap1);
          }
        } else {
          if (isSingleTap(tap1)) {
            _this.handleSingleTap(tap1);
          } else {
            _taps.unshift(tap1);
            _doubleTapTimer = setTimeout(function() {
              _doubleTapTimer = null;
              processTaps();
            }, kDoubleTapDelay);
            break;
          }
        }
      }
    }
  }
  this.update = function() {
    var wheelEnded = false;
    var updatePivot = false;
    if (this.camera.dirty) {
      this.syncCamera();
    }
    if (viewerApi.navigation.getRequestFitToView() && !viewerApi.navigation.getTransitionActive()) {
      viewerApi.navigation.setRequestFitToView(false);
      this.fitToView();
    }
    if (viewerApi.navigation.getRequestHomeView() && !viewerApi.navigation.getTransitionActive()) {
      viewerApi.navigation.setRequestHomeView(false);
      this.goHome();
    }
    var request = viewerApi.navigation.getRequestTransition();
    if (request && !viewerApi.navigation.getTransitionActive()) {
      viewerApi.navigation.setRequestTransition(false);
      this.transitionView(request.position, request.coi, request.fov, request.worldUp);
    }
    this.getMotionDelta(_motionDelta, _deltaXY);
    var deltaX = _motionDelta.x;
    var deltaY = _motionDelta.y;
    var deltaZ = _motionDelta.z;
    parseTouches();
    if (!_activeModeLocked) {
      this.checkInteractionMode();
    }
    _activeModeLocked = _activeTrigger > kWheel;
    if (_needNextRefresh || (deltaX !== 0 || (deltaY !== 0 || (deltaZ !== 0 || checkForTouchDelta())))) {
      if (_activeTrigger > kWheel) {
        _upTransition = 0;
        _viewTransition = 0;
      }
      if (_needNextRefresh) {
        _needRefresh = true;
        _needNextRefresh = false;
      }
      if (!_navigating) {
        _navigating = true;
      }
      switch(_activeMode) {
        case Autodesk.Viewing.NAVIGATION_MODE.ORBIT:
          if (_autoCam && _autoCam.startState) {
            _deltaXY.x = -_deltaXY.x;
            _autoCam.orbit(_moveXY, _autoCamStartXY, _deltaXY, _autoCam.startState);
          } else {
            deltaX *= kOrbitDragScale;
            deltaY *= kOrbitDragScale;
            _currentController.orbitRelative(deltaX, deltaY);
          }
          _tumbled = true;
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.DOLLY:
          var dollyTarget, screenX, screenY;
          deltaZ *= kDollyScale;
          if (_activeTrigger >= kMouseLeft || _activeTrigger === kSingleTouch) {
            deltaY = -deltaY;
            deltaZ = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
            deltaZ *= kDollyDragScale;
            deltaX = 0;
            deltaY = 0;
            screenX = screenY = 0.5;
          } else {
            var viewport = viewerApi.navigation.getScreenViewport();
            screenX = (_lastMouseX - viewport.left) / viewport.width;
            screenY = (_lastMouseY - viewport.top) / viewport.height;
          }
          if (viewerApi.navigation.getZoomTowardsPivot()) {
            if (!_currentController.coiIsActive()) {
              dollyTarget = getWorldPoint(0.5, 0.5, this.camera);
              _currentController.dollyRelativeTowardsPoint(deltaZ, dollyTarget);
            } else {
              _currentController.dollyRelativeTowardsCOI(deltaZ);
            }
          } else {
            dollyTarget = getWorldPoint(screenX, screenY, this.camera);
            _currentController.dollyRelativeTowardsPoint(deltaZ, dollyTarget);
          }
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.PAN:
          _currentController.trackRelative(-deltaX, deltaY);
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.TOUCH_PAN_DOLLY:
          var p = getHitPoint(_currCentroid.scaledX, _currCentroid.scaledY);
          if (!p) {
            var clickPoint = new THREE.Vector3(_currCentroid.scaledX * 2 - 1, 2 - _currCentroid.scaledY * 2, 0);
            _projector.unprojectVector(clickPoint, this.camera);
            var direction = clickPoint.sub(_currentController.getPosition());
            var ratio = _currentController.getPivotDistance() / this.camera.near;
            p = direction.multiplyScalar(ratio).add(_currentController.getPosition());
          }
          var dz = kTouchDollyScale * (_currPinch - _prevPinch);
          _currentController.dollyRelativeTowardsPoint(dz, p);
          _currentController.trackRelative(_currCentroid.scaledX - _prevCentroid.scaledX, _currCentroid.scaledY - _prevCentroid.scaledY);
          stepTouches();
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.ROLL:
          _needNextRefresh = _rollInteraction.handleRoll(deltaX, deltaY, _moveXYZ, this);
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.TOUCH_ROLL:
          _needNextRefresh = _rollInteraction.handleRollTouch(_prevTouches[0], _prevTouches[1], _currTouches[0], _currTouches[1], this);
          stepTouches();
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.FOV:
          if (_activeTrigger >= kMouseLeft || _activeTrigger === kSingleTouch) {
            deltaY = -deltaY;
            deltaZ = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
            if (deltaZ !== 0) {
              deltaZ *= kFovDragScale;
              _currentController.changeFOV(this.camera.fov * (1 + deltaZ));
            }
          } else {
            var deltaFocalLength = this.getAccumulatedWheelDelta() / 3;
            if (deltaFocalLength !== 0) {
              _currentController.changeFOV(fl2fov(fov2fl(this.camera.fov) + deltaFocalLength));
            }
          }
          break;
        case Autodesk.Viewing.NAVIGATION_MODE.OTHER:
          break;
      }
      updatePivot = true;
    }
    this.stepMotionDelta(_motionDelta, _activeMode !== Autodesk.Viewing.NAVIGATION_MODE.PAN && _activeMode !== Autodesk.Viewing.NAVIGATION_MODE.ROLL);
    if (_activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon) {
      this.interactionEnd(kWheel);
      wheelEnded = true;
      updatePivot = true;
    }
    if (!_interactionActive && (wheelEnded || _activeTrigger > kNone)) {
      if (!_autoCam) {
        if (_tumbled && !_rollInteraction.isSnapped()) {
          this.setWorldUp(_currentController.getCameraUpVector(), false);
        }
      }
      if (_activeTrigger > kWheel) {
        _startXYZ.copy(_moveXYZ);
      }
      _activeTrigger = kNone;
      _activeModeLocked = false;
      _tumbled = false;
      this.interactionCheck();
      this.checkInteractionMode();
      if (_navigating) {
        _navigating = false;
      }
    }
    var transitionEnded = false;
    if (_upTransition > 0 && _upTarget) {
      var newUp = _upTarget;
      if (_upTransition > 1) {
        var stepSize = 1 / _upTransition;
        var oneMinusStep = 1 - stepSize;
        var oldUp = _currentController.getWorldUpVector();
        newUp = oldUp.multiplyScalar(oneMinusStep).add(_upTarget.clone().multiplyScalar(stepSize));
      }
      this.setWorldUp(newUp, true);
      --_upTransition;
      if (_upTransition === 0) {
        transitionEnded = true;
      }
    }
    if (_viewTransition > 0 && (_viewTargetPos && _viewTargetCoi)) {
      _currentController.oneStepTowards(_viewTargetPos, _viewTargetCoi, _viewTargetFov, _viewTransition);
      updatePivot = true;
      --_viewTransition;
      if (_viewTransition === 0) {
        transitionEnded = true;
        viewerApi.navigation.setTransitionActive(false);
      }
    }
    if (_pivotIndicator.shown() && _pivotIndicator.fade()) {
      _client.overlayDirty = true;
    }
    var moved = false;
    if (_needRefresh || _currentController.isDirty()) {
      _currentController.updateCamera();
      _needRefresh = false;
      moved = true;
    }
    if (_currentController.cameraChanged(true)) {
      moved = true;
    }
    if (updatePivot) {
      var isSet = _currentController.pivotIsSet();
      if (transitionEnded) {
        this.pivotActive(isSet, true);
      } else {
        this.pivotActive(isSet && (_interactionActive || (_viewTransition || _upTransition)), _activeTrigger === kWheel);
      }
    }
    if (moved) {
      this.moveDelay = Date.now() + 150;
    } else {
      if (this.moveDelay !== 0) {
        var delta = this.moveDelay - Date.now();
        if (delta > 0) {
          moved = true;
        } else {
          this.moveDelay = 0;
        }
      }
    }
    return moved;
  };
  this.clientToCanvasCoords = function(event, normalized, screen) {
    var viewport = this.domElement.getBoundingClientRect();
    var width = viewport.width;
    var height = viewport.height;
    var canvasX = event.clientX - viewport.left;
    var canvasY = event.clientY - viewport.top;
    event.canvasX = canvasX;
    event.canvasY = canvasY;
    event.normalizedX = canvasX / width * 2 - 1;
    event.normalizedY = (height - canvasY) / height * 2 - 1;
    if (normalized) {
      normalized.set(canvasX / width, canvasY / height, 0);
    }
    if (screen) {
      screen.set(canvasX, canvasY);
    }
  };
  this.handleResize = function() {
    viewerApi.navigation.setScreenViewport(viewerApi.container.getBoundingClientRect());
  };
  this.setCOIFromMouse = function(mouseX, mouseY, useGround, setIt) {
    var point = null;
    if (!_is2d) {
      var result = _client.castRay(mouseX, mouseY, true);
      if (result.intersectPoint) {
        point = result.intersectPoint;
      } else {
        if (useGround) {
          point = _client.intersectGround(mouseX, mouseY);
        } else {
          var viewport = viewerApi.navigation.getScreenViewport();
          var x = (mouseX - viewport.left) / viewport.width;
          var y = (mouseY - viewport.top) / viewport.height;
          point = getWorldPoint(x, y, this.camera);
        }
      }
    } else {
      point = _client.intersectGround(mouseX, mouseY);
    }
    if (point) {
      this.setCOI(point, true, false, setIt);
    }
  };
  this.handleSingleClick = function(event) {
    var mods = _modifierState;
    if (_activeTrigger === kMouseLeft) {
      var result = _client.castRay(event.clientX, event.clientY, false);
      var key = "click";
      if (mods.CONTROL) {
        key += "Ctrl";
      }
      if (mods.SHIFT) {
        key += "Shift";
      }
      if (mods.ALT) {
        key += "Alt";
      }
      if (mods.SPACE) {
        key += "Space";
      }
      if (mods.F1) {
        key += "F1";
      }
      if (mods.F2) {
        key += "F2";
      }
      if (mods.F3) {
        key += "F3";
      }
      if (mods.F4) {
        key += "F4";
      }
      var objectKey = "";
      if (result.node || result.intersectPoint) {
        objectKey = "onObject";
      } else {
        objectKey = "offObject";
      }
      if (this.clickConfig && (this.clickConfig[key] && this.clickConfig[key][objectKey])) {
        this.handleAction(this.clickConfig[key][objectKey], result);
      }
    } else {
      if (_activeTrigger === kMouseMiddle && (mods.SHIFT && (!mods.ALT && !mods.CONTROL))) {
        var result = _client.castRay(event.clientX, event.clientY, false);
        if (result.intersectPoint) {
          this.setCOI(result.intersectPoint, true, false, true);
          this.pivotActive(true, true);
        }
      }
    }
  };
  this.handleAction = function(actionArray, rayData) {
    for (var i = 0;i < actionArray.length;++i) {
      switch(actionArray[i]) {
        case "selectOnly":
          if (_selector) {
            if (rayData.node) {
              _selector.setSelection([rayData.node]);
            }
          }
          break;
        case "deselectAll":
          if (_selector) {
            _selector.setSelection([]);
          }
          break;
        case "selectToggle":
          if (_selector) {
            if (rayData.node) {
              _selector.toggleSelection(rayData.node);
            }
          }
          break;
        case "isolate":
          if (rayData.node) {
            viewerApi.isolate(rayData.node);
          }
          break;
        case "showAll":
          _client.visibilityManager.isolateNone();
          break;
        case "setCOI":
          if (rayData.intersectPoint) {
            this.setCOI(rayData.intersectPoint, true, false, true);
            this.pivotActive(true, true);
          }
          break;
        case "hide":
          if (rayData.node) {
            _client.hideMultiple([rayData.node]);
          }
          break;
        case "show":
          if (rayData.node) {
            _client.showMultiple([rayData.node]);
          }
          break;
        case "toggleVisibility":
          if (rayData.node) {
            _client.toggleVisibility(rayData.node);
          }
          break;
        case "focus":
          if (_selector) {
            if (rayData.node) {
              _selector.setSelection([rayData.node]);
            } else {
              _selector.setSelection([]);
            }
            this.fitToView();
          }
          break;
      }
    }
  };
  this.handleDoubleClick = function(event) {
    var button = _this.applyButtonMappings(event.button);
    if (_selector != null && button == 0) {
      var result = _client.castRay(event.clientX, event.clientY, false);
      if (result.node) {
        _selector.setSelection([result.node]);
      } else {
        _selector.clearSelection();
      }
      this.fitToView();
    }
    if (button == 1) {
      viewerApi.navigation.fitBounds(false, this.getBoundingBox(true));
      viewerApi.navigation.setPivotSetFlag(false);
    }
  };
  this.handleSingleTap = function(tap) {
    var x = (tap.startX + tap.endX) / 2;
    var y = (tap.startY + tap.endY) / 2;
    var result = _client.castRay(x, y, false);
    if (result.intersectPoint) {
      this.setCOI(result.intersectPoint, true, false, true);
      this.pivotActive(true, true);
    }
  };
  this.handleDoubleTap = function(tap1, tap2) {
    var x = (tap1.startX + tap1.endX + tap2.startX + tap2.endX) / 4;
    var y = (tap1.startY + tap1.endY + tap2.startY + tap2.endY) / 4;
    if (_selector != null) {
      var result = _client.castRay(x, y, false);
      if (result.node) {
        _selector.setSelection([result.node]);
      } else {
        _selector.clearSelection();
      }
      this.fitToView();
    }
  };
  this.handleWheelInput = function(delta) {
    if (_is2d || _wheelPivots) {
      _this.setCOIFromMouse(_lastMouseX, _lastMouseY, _wheelPivots);
    }
    if (viewerApi.navigation.getReverseZoomDirection()) {
      delta *= -1;
    }
    _moveXYZ.z += delta;
    _wheelAccum += delta;
    var now = Date.now();
    if (!_wheelOldest) {
      _wheelOldest = now;
    }
    _wheelNewest = now;
    if (delta != 0) {
      this.interactionStart(kWheel);
    }
  };
  this.applyButtonMappings = function(button) {
    if (viewerApi.navigation.getUseLeftHandedInput()) {
      button = button === kMouseLeft ? kMouseRight : button === kMouseRight ? kMouseLeft : button;
    }
    return button;
  };
  this.resetKeys = function() {
    this.autoMove(-1, false);
    _modifierState.SHIFT = 0;
    _modifierState.CONTROL = 0;
    _modifierState.ALT = 0;
    _modifierState.SPACE = 0;
    _modifierState.F1 = 0;
    _modifierState.F2 = 0;
    _modifierState.F3 = 0;
    _modifierState.F4 = 0;
  };
  this.applyKeyMappings = function(event, state) {
    switch(event.keyCode) {
      case _keys.LCOMMAND:
      ;
      case _keys.RCOMMAND:
      ;
      case _keys.COMMANDMOZ:
        _commandKeyDown = state;
        return isMac && (_commandKeyDown && _modifierState.SHIFT) ? null : _keys.CONTROL;
      case _keys.SHIFT:
        return state && (isMac && _commandKeyDown) ? null : _keys.SHIFT;
      case _keys.h:
        return _keys.HOME;
      case _keys.EQUALSMOZ:
        return _keys.EQUALS;
      case _keys.DASHMOZNEW:
      ;
      case _keys.DASHMOZ:
        return _keys.DASH;
    }
    return event.keyCode;
  };
  this.handleKeyDown = function(event) {
    var isModKey = false;
    var keyCode = this.applyKeyMappings(event, true);
    switch(keyCode) {
      case _keys.SHIFT:
        _modifierState.SHIFT = 1;
        isModKey = true;
        break;
      case _keys.CONTROL:
        _modifierState.CONTROL = 1;
        isModKey = true;
        break;
      case _keys.ALT:
        _modifierState.ALT = 1;
        isModKey = true;
        break;
      case _keys.SPACE:
        _modifierState.SPACE = 1;
        isModKey = true;
        break;
      case _keys.F1:
        _modifierState.F1 = 1;
        break;
      case _keys.F2:
        _modifierState.F2 = 1;
        break;
      case _keys.F3:
        _modifierState.F3 = 1;
        break;
      case _keys.F4:
        _modifierState.F4 = 1;
        break;
      case _keys.HOME:
        this.goHome();
        break;
      case _keys.f:
        this.fitToView();
        break;
      case _keys.EQUALS:
        this.adjustSpeed(1);
        break;
      case _keys.DASH:
        this.adjustSpeed(-1);
        break;
      case _keys.ZERO:
        this.adjustSpeed(0);
        break;
      case _keys.LEFT:
        this.autoMove(0, true);
        break;
      case _keys.RIGHT:
        this.autoMove(1, true);
        break;
      case _keys.PAGEUP:
        this.autoMove(2, true);
        break;
      case _keys.PAGEDOWN:
        this.autoMove(3, true);
        break;
      case _keys.UP:
        this.autoMove(4, true);
        break;
      case _keys.DOWN:
        this.autoMove(5, true);
        break;
      default:
        return false;
    }
    if (isModKey) {
      this.interactionStart(kKeyboard);
    }
    return true;
  };
  this.handleKeyUp = function(event) {
    var isModKey = false;
    switch(this.applyKeyMappings(event, false)) {
      case _keys.SHIFT:
        _modifierState.SHIFT = 0;
        isModKey = true;
        break;
      case _keys.CONTROL:
        _modifierState.CONTROL = 0;
        isModKey = true;
        break;
      case _keys.ALT:
        _modifierState.ALT = 0;
        isModKey = true;
        break;
      case _keys.SPACE:
        _modifierState.SPACE = 0;
        isModKey = true;
        break;
      case _keys.F1:
        _modifierState.F1 = 0;
        break;
      case _keys.F2:
        _modifierState.F2 = 0;
        break;
      case _keys.F3:
        _modifierState.F3 = 0;
        break;
      case _keys.F4:
        _modifierState.F4 = 0;
        break;
      case _keys.HOME:
      ;
      case _keys.f:
        break;
      case _keys.LEFT:
        this.autoMove(0, false);
        break;
      case _keys.RIGHT:
        this.autoMove(1, false);
        break;
      case _keys.PAGEUP:
        this.autoMove(2, false);
        break;
      case _keys.PAGEDOWN:
        this.autoMove(3, false);
        break;
      case _keys.UP:
        this.autoMove(4, false);
        break;
      case _keys.DOWN:
        this.autoMove(5, false);
        break;
      case _keys.ESCAPE:
        if (viewerApi.objectContextMenu && viewerApi.objectContextMenu.hide()) {
          break;
        }
        viewerApi.fireEvent({type:Autodesk.Viewing.ESCAPE_EVENT});
        this.resetKeys();
        this.interactionEnd(_activeTrigger);
        break;
      default:
        return false;
    }
    if (isModKey) {
      this.interactionEnd(kKeyboard);
    }
    return true;
  };
  this.handleButtonDown = function(button) {
    this.interactionStart(button);
  };
  this.handleButtonUp = function(button) {
    this.interactionEnd(button);
  };
  this.handleTouchChange = function(oldNumTouches, newNumTouches) {
    if (oldNumTouches === 0) {
      this.interactionStart(newNumTouches === 1 ? kSingleTouch : kMultiTouch);
    } else {
      this.interactionEnd(oldNumTouches === 1 ? kSingleTouch : kMultiTouch);
    }
  };
  this.keydown = function(event) {
    if (lastTouchedElement !== viewerImpl.canvas) {
      return;
    }
    if (isMac && (event.metaKey && (event.keyCode != _keys.LCOMMAND && event.keyCode != _keys.RCOMMAND))) {
      return;
    }
    if (_this.handleKeyDown(event)) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  this.keyup = function(event) {
    if (isMac && (event.metaKey && (event.keyCode != _keys.LCOMMAND && event.keyCode != _keys.RCOMMAND))) {
      return;
    }
    if (_this.handleKeyUp(event)) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  this.updateModifierState = function(event) {
    _modifierState.CONTROL = isMac && event.metaKey || event.ctrlKey ? 1 : 0;
    _modifierState.SHIFT = event.shiftKey ? 1 : 0;
    _modifierState.ALT = event.altKey ? 1 : 0;
  };
  this.mousedown = function(event) {
    if (_this.isDragging || _this.inTouch) {
      return;
    }
    if (!(_isIE11 && inFullscreen())) {
      document.activeElement.blur();
    }
    event.preventDefault();
    event.stopPropagation();
    _this.updateModifierState(event);
    _this.clientToCanvasCoords(event, _startXYZ, _startXY);
    _moveXYZ.copy(_startXYZ);
    _moveXY.copy(_startXY);
    var buttonDown = _this.applyButtonMappings(event.button);
    _this.handleButtonDown(buttonDown);
    _this.downX = event.canvasX;
    _this.downY = event.canvasY;
    _this.isDragging = true;
    if (viewerApi.navigation.getUseLeftHandedInput() && buttonDown === 0 || isFirefox && buttonDown === 1) {
      var cmdc = _checkMouseDoubleClick;
      var delayOK = cmdc.time !== undefined && event.timeStamp - cmdc.time < kDoubleClickDelayThreshold;
      var positionOK = cmdc.x !== undefined && cmdc.y !== undefined && (Math.abs(cmdc.x - event.canvasX) <= kClickThreshold && Math.abs(cmdc.y - event.canvasY) <= kClickThreshold);
      if (!delayOK || (!positionOK || cmdc.clickCount && 2 <= cmdc.clickCount)) {
        cmdc.clickCount = 0;
      }
      if (!cmdc.clickCount) {
        cmdc.clickCount = 1;
        cmdc.x = event.canvasX;
        cmdc.y = event.canvasY;
        cmdc.time = event.timeStamp;
      } else {
        if (cmdc.clickCount === 1) {
          cmdc.clickCount = 2;
        }
      }
    }
    function handleUp(event) {
      var buttonUp = _this.applyButtonMappings(event.button);
      if (buttonUp === buttonDown) {
        document.removeEventListener("mouseup", handleUp);
        _this.mouseup(event);
      }
    }
    document.addEventListener("mouseup", handleUp, false);
  };
  this.mousemove = function(event) {
    if (_this.inTouch) {
      return;
    }
    if (!_this.isDragging) {
      _lastMouseX = event.clientX;
      _lastMouseY = event.clientY;
      if (_is2d) {
        _client.highlightObject(_lastMouseX, _lastMouseY);
      }
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    _this.updateModifierState(event);
    _this.clientToCanvasCoords(event, _moveXYZ, _moveXY);
    var deltaX = _this.downX - event.canvasX;
    var deltaY = _this.downY - event.canvasY;
    if (Math.abs(deltaX) > kClickThreshold || Math.abs(deltaY) > kClickThreshold) {
      _this.downX = -1;
      _this.downY = -1;
    }
  };
  this.mouseup = function(event) {
    event.preventDefault();
    event.stopPropagation();
    _this.updateModifierState(event);
    _this.clientToCanvasCoords(event, _moveXYZ, _moveXY);
    var buttonUp = _this.applyButtonMappings(event.button);
    _this.handleButtonUp(buttonUp);
    var deltaX = _this.downX - event.canvasX;
    var deltaY = _this.downY - event.canvasY;
    _this.downX = -1;
    _this.downY = -1;
    _this.isDragging = false;
    if (Math.abs(deltaX) <= kClickThreshold && Math.abs(deltaY) <= kClickThreshold) {
      _this.handleSingleClick(event);
    }
    if (viewerApi.navigation.getUseLeftHandedInput() && buttonUp === 0 || isFirefox && buttonUp === 1) {
      var cmdc = _checkMouseDoubleClick;
      if (cmdc.clickCount === 2) {
        _this.handleDoubleClick(event);
        cmdc.clickCount = 0;
        cmdc.x = undefined;
        cmdc.y = undefined;
        cmdc.time = undefined;
      }
    }
  };
  this.doubleclick = function(event) {
    event.preventDefault();
    event.stopPropagation();
    _this.clientToCanvasCoords(event, _startXYZ, _startXY);
    _moveXYZ.copy(_startXYZ);
    _this.downX = event.canvasX;
    _this.downY = event.canvasY;
    _this.handleDoubleClick(event);
  };
  this.mousewheel = function(event) {
    event.preventDefault();
    event.stopPropagation();
    if (_this.inTouch) {
      return;
    }
    var delta = 0;
    if (event.wheelDelta) {
      delta = event.wheelDelta / 40;
    } else {
      if (event.detail) {
        delta = -event.detail;
      }
    }
    _this.handleWheelInput(delta);
  };
  this.touchstart = function(event) {
    if (_this.isDragging) {
      return;
    }
    _this.inTouch = true;
    event.preventDefault();
    event.stopPropagation();
    function updateTouches(event) {
      if (_currTouches.length !== event.targetTouches.length) {
        _this.handleTouchChange(_currTouches.length, event.targetTouches.length);
      }
      _prevTouches = [];
      _currTouches = [];
      for (var i = 0;i < event.targetTouches.length;++i) {
        var touch = event.targetTouches[i];
        touch.clientX = touch.pageX;
        touch.clientY = touch.pageY;
        _this.clientToCanvasCoords(touch);
        _prevTouches.push({x:touch.canvasX, y:touch.canvasY});
        _currTouches.push({x:touch.canvasX, y:touch.canvasY});
      }
      if (_currTouches.length === 1) {
        _this.clientToCanvasCoords(event.targetTouches[0], _startXYZ, _startXY);
        _moveXYZ.copy(_startXYZ);
      }
    }
    updateTouches(event);
    if (_currTouches.length === 1) {
      var touch = _currTouches[0];
      _tapBeginX = touch.x;
      _tapBeginY = touch.y;
      _tapBeginTime = Date.now();
    } else {
      _tapBeginX = _tapBeginY = _tapBeginTime = -1;
    }
    document.activeElement.blur();
    _this.updateModifierState(event);
    function handleUp(event) {
      event.preventDefault();
      event.stopPropagation();
      if (event.targetTouches.length === 0) {
        _this.handleTouchChange(_currTouches.length, 0);
        document.removeEventListener("touchend", handleUp);
        _this.touchend(event);
      } else {
        updateTouches(event);
      }
    }
    if (event.targetTouches.length === 1) {
      document.addEventListener("touchend", handleUp, false);
    }
  };
  this.touchmove = function(event) {
    if (_this.isDragging) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    _currTouches = [];
    for (var i = 0;i < event.targetTouches.length;++i) {
      var touch = event.targetTouches[i];
      touch.clientX = touch.pageX;
      touch.clientY = touch.pageY;
      _this.clientToCanvasCoords(touch);
      _currTouches.push({x:touch.canvasX, y:touch.canvasY});
    }
    if (_currTouches.length === 2 && _prevTouches.length === 2) {
      var dx = _currTouches[1].x - _currTouches[0].x;
      var dy = _currTouches[1].y - _currTouches[0].y;
      var theta = Math.atan2(dy, dx);
      if (theta < 0) {
        theta += kTwo_PI;
      }
      var lastdx = _prevTouches[1].x - _prevTouches[0].x;
      var lastdy = _prevTouches[1].y - _prevTouches[0].y;
      var lasttheta = Math.atan2(lastdy, lastdx);
      if (lasttheta < 0) {
        lasttheta += kTwo_PI;
      }
      var d = Math.abs(theta - lasttheta);
      if (d > Math.PI) {
        d = kTwo_PI - d;
      }
      if (d > kTouchSwapThreshold) {
        var swap = _currTouches[1];
        _currTouches[1] = _currTouches[0];
        _currTouches[0] = swap;
      }
    }
    if (_currTouches.length === 1) {
      _this.clientToCanvasCoords(event.targetTouches[0], _moveXYZ, _moveXY);
    }
    _this.updateModifierState(event);
  };
  this.touchend = function(event) {
    _this.inTouch = false;
    if (_tapBeginTime !== -1) {
      var touch = _currTouches[0];
      var tap = {startX:_tapBeginX, startY:_tapBeginY, startTime:_tapBeginTime, endX:touch.x, endY:touch.y, endTime:Date.now()};
      _taps.push(tap);
    }
    processTaps();
    _prevTouches = [];
    _currTouches = [];
    _this.updateModifierState(event);
  };
  this.set2DMode = function(val) {
    _is2d = val;
    if (val) {
      _pivotIndicator.hide();
    }
  };
  this.blur = function(event) {
    _this.resetKeys();
    _this.interactionEnd(_activeTrigger);
  };
  this.domElement.addEventListener("mousedown", this.mousedown, false);
  window.addEventListener("mousemove", this.mousemove, false);
  this.domElement.addEventListener("dblclick", this.doubleclick, false);
  this.domElement.addEventListener("mousewheel", this.mousewheel, false);
  this.domElement.addEventListener("DOMMouseScroll", this.mousewheel, false);
  this.domElement.addEventListener("touchstart", function(event) {
    _this.touchstart(event);
  }, false);
  this.domElement.addEventListener("touchmove", function(event) {
    _this.touchmove(event);
  }, false);
  window.addEventListener("keydown", this.keydown, false);
  window.addEventListener("keyup", this.keyup, false);
  this.mouseover = function(e) {
    lastTouchedElement = e.target;
    if (lastTouchedElement != viewerImpl.canvas) {
      _this.autoMove(-1, false);
    }
  };
  window.addEventListener("mouseover", this.mouseover, false);
  window.addEventListener("blur", this.blur, false);
  this.uninitialize = function() {
    window.removeEventListener("mousemove", this.mousemove, false);
    window.removeEventListener("keydown", this.keydown, false);
    window.removeEventListener("keyup", this.keyup, false);
    window.removeEventListener("mouseover", this.mouseover, false);
    window.removeEventListener("blur", this.blur, false);
  };
}
ViewController.prototype = Object.create(THREE.EventDispatcher.prototype);
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.Selector = function(viewer) {
  var _this = this;
  this.viewer = viewer;
  this.model = null;
  this.selectedObjects = [];
  var selectedParentMap = {};
  viewer.api.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function(event) {
    _this.deselectInvisible();
  });
  viewer.api.addEventListener(Autodesk.Viewing.HIDE_EVENT, function(event) {
    _this.deselectInvisible();
  });
  function unmarkObject(object) {
    var objectId = object.dbId || object.fragIds;
    if (selectedParentMap[objectId] > 0) {
      selectedParentMap[objectId]--;
      if (selectedParentMap[objectId] == 0) {
        var fragIds = object.fragIds;
        if (typeof fragIds != "undefined") {
          if (!Array.isArray(fragIds)) {
            fragIds = [fragIds];
          }
          for (var i = 0;i < fragIds.length;++i) {
            var fragId = fragIds[i];
            var mesh = _this.viewer.getRenderProxy(_this.model, fragId);
            _this.viewer.highlightFragment(_this.model, fragId, false);
            if (mesh.selectionProxy) {
              _this.viewer.removeOverlay("selection", mesh.selectionProxy);
              delete mesh.selectionProxy;
            }
          }
        }
      }
    } else {
      if (selectedParentMap[objectId] < 0) {
        throw "Selection State machine broken. Negatively selected object!";
      }
    }
    if (object.children) {
      for (var i = 0;i < object.children.length;i++) {
        unmarkObject(object.children[i]);
      }
    }
  }
  function markObject(object, isChild) {
    var objectId = object.dbId || object.fragIds;
    if (selectedParentMap[objectId]) {
      selectedParentMap[objectId]++;
    } else {
      var fragIds = object.fragIds;
      if (typeof fragIds != "undefined") {
        if (!Array.isArray(fragIds)) {
          fragIds = [fragIds];
        }
        for (var i = 0;i < fragIds.length;++i) {
          var fragId = fragIds[i];
          var mesh = _this.viewer.getRenderProxy(_this.model, fragId);
          if (isChild) {
            _this.viewer.highlightFragment(_this.model, fragId, true);
          } else {
            mesh.selectionProxy = new THREE.Mesh(mesh.geometry, mesh.material, true);
            mesh.selectionProxy.matrixWorld = mesh.matrixWorld;
            _this.viewer.addOverlay("selection", mesh.selectionProxy);
          }
        }
      }
      selectedParentMap[objectId] = 1;
    }
    if (object.children) {
      for (var i = 0;i < object.children.length;i++) {
        markObject(object.children[i], true);
      }
    }
  }
  this.getSelectionLength = function() {
    return _this.selectedObjects.length;
  };
  this.getSelection = function() {
    return _this.selectedObjects.slice(0);
  };
  this.clearSelection = function(nofire) {
    if (this.selectedObjects.length > 0) {
      for (var i = 0;i < _this.selectedObjects.length;i++) {
        unmarkObject(_this.selectedObjects[i]);
      }
      _this.selectedObjects.length = 0;
      if (!nofire) {
        this.fireSelectionChangedEvent();
      }
    }
  };
  this.fireSelectionChangedEvent = function() {
    var dbIdArray = [];
    var fragIdsArray = [];
    for (var i = 0;i < _this.selectedObjects.length;i++) {
      dbIdArray.push(_this.selectedObjects[i].dbId);
      fragIdsArray.push(_this.selectedObjects[i].fragIds);
    }
    var event = {type:Autodesk.Viewing.SELECTION_CHANGED_EVENT, dbIdArray:dbIdArray, fragIdsArray:fragIdsArray, nodeArray:this.getSelection()};
    Autodesk.Viewing.Private.logger.log({viewer_current_time:Date.now(), viewer_event_type:"selection", viewer_event_on_object:dbIdArray});
    this.viewer.api.fireEvent(event);
  };
  this.isSelected = function(dbNode) {
    return this.findSelection(dbNode) != -1;
  };
  this.findSelection = function(dbNode) {
    var easyFind = this.selectedObjects.indexOf(dbNode);
    return easyFind;
  };
  function select(dbNode) {
    var selectionIndex = _this.findSelection(dbNode);
    if (selectionIndex == -1) {
      _this.selectedObjects.push(dbNode);
      markObject(dbNode);
    }
  }
  function deselect(dbNode) {
    var selectionIndex = _this.findSelection(dbNode);
    if (selectionIndex >= 0) {
      unmarkObject(dbNode);
      _this.selectedObjects.splice(selectionIndex, 1);
    }
  }
  this.toggleSelection = function(dbNode) {
    if (dbNode) {
      if (!this.isSelected(dbNode)) {
        select(dbNode);
      } else {
        deselect(dbNode);
      }
      _this.fireSelectionChangedEvent();
    }
  };
  this.setSelectionIds = function(dbNodeIdArray) {
    this.setSelection(this.model.getNodesByIds(dbNodeIdArray));
  };
  this.selectionIsEqual = function(dbNodeArray) {
    if (this.selectedObjects.length !== dbNodeArray.length) {
      return false;
    }
    for (var i = 0;i < dbNodeArray.length;i++) {
      if (!this.isSelected(dbNodeArray[i])) {
        return false;
      }
    }
    return true;
  };
  this.setSelection = function(dbNodeArray) {
    if (this.selectionIsEqual(dbNodeArray)) {
      return;
    }
    this.clearSelection(true);
    if (dbNodeArray == null) {
      return;
    }
    for (var i = 0;i < dbNodeArray.length;i++) {
      select(dbNodeArray[i]);
    }
    this.fireSelectionChangedEvent();
  };
  this.deselectInvisible = function() {
    var changed = false;
    for (var i = 0;i < _this.selectedObjects.length;i++) {
      var node = _this.selectedObjects[i];
      if (node.visible == false) {
        deselect(node);
        changed = true;
      }
    }
    if (changed) {
      this.fireSelectionChangedEvent();
    }
  };
  this.toggleSelectionId = function(dbNodeId) {
    this.toggleSelection(this.model.getNodeById(dbNodeId));
  };
  this.isSelectedOrParentIsSelected = function(node) {
    while (node) {
      if (this.findSelection(node) >= 0) {
        return true;
      }
      node = node.parent;
    }
    return false;
  };
  this.getSelectionFragIds = function() {
    return this.getFragIds(_this.selectedObjects);
  };
  this.getFragIdsFromObjectIds = function(Ids) {
    if (!Array.isArray(Ids)) {
      Ids = [Ids];
    }
    return this.getFragIds(this.model.getNodesByIds(Ids));
  };
  this.getFragIds = function(objects) {
    var fragIds = [];
    for (var i = 0;i < objects.length;++i) {
      var pushToFragIds = function(dbNode) {
        var ids = dbNode.fragIds;
        if (!Array.isArray(ids)) {
          ids = [ids];
        }
        for (var j = 0;j < ids.length;++j) {
          fragIds.push(ids[j]);
        }
        if (dbNode.children) {
          for (var k = 0;k < dbNode.children.length;k++) {
            pushToFragIds(dbNode.children[k]);
          }
        }
      };
      pushToFragIds(objects[i]);
    }
    return fragIds;
  };
  this.getSelectionBounds = function() {
    var bounds = new THREE.Box3;
    var box = new THREE.Box3;
    var fragIds = this.getSelectionFragIds();
    var viewer = this.viewer;
    var model = this.model;
    for (var i = 0;i < fragIds.length;++i) {
      var m = viewer.getRenderProxy(model, fragIds[i]);
      if (m) {
        m.geometry.boundingBox.getTransformedBox(m.matrixWorld, box);
        bounds.union(box);
      }
    }
    return bounds;
  };
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.VisibilityManager = function(viewerImpl) {
  this.viewerImpl = viewerImpl;
  this.model = null;
};
Autodesk.Viewing.Private.VisibilityManager.prototype.isolate = function(node) {
  if (node) {
    this.isolateMultiple([node]);
  } else {
    this.isolateNone();
  }
};
Autodesk.Viewing.Private.VisibilityManager.prototype.isolateNone = function() {
  this.viewerImpl.setModelVisibility(this.model, true);
  var root = this.model ? this.model.getRoot() : null;
  if (root) {
    this.setVisibiltyOnNode(root, true);
  }
  this.viewerImpl.resetIsolation(this.model);
  var event = {type:Autodesk.Viewing.ISOLATE_EVENT, nodeIdArray:[]};
  this.viewerImpl.api.fireEvent(event);
};
Autodesk.Viewing.Private.VisibilityManager.prototype.isolateMultiple = function(nodeList) {
  if (!nodeList || nodeList.length == 0) {
    this.isolateNone();
  } else {
    var root = this.model ? this.model.getRoot() : null;
    if (root) {
      this.setVisibiltyOnNode(root, false);
    }
    this.viewerImpl.setModelVisibility(this.model, false);
    for (var i = 0;i < nodeList.length;i++) {
      this.setVisibiltyOnNode(nodeList[i], true);
      this.viewerImpl.needGhostedPass = true;
    }
    var event = {type:Autodesk.Viewing.ISOLATE_EVENT, nodeIdArray:nodeList};
    this.viewerImpl.api.fireEvent(event);
  }
  this.viewerImpl.needsClear = true;
};
Autodesk.Viewing.Private.VisibilityManager.prototype.hideMultiple = function(nodes) {
  for (var i = 0;i < nodes.length;++i) {
    this.setVisibiltyOnNode(nodes[i], false);
  }
  if (nodes.length > 0) {
    var event = {type:Autodesk.Viewing.HIDE_EVENT, nodeIdArray:nodes};
    this.viewerImpl.api.fireEvent(event);
  }
};
Autodesk.Viewing.Private.VisibilityManager.prototype.hide = function(node) {
  this.setVisibiltyOnNode(node, false);
  var event = {type:Autodesk.Viewing.HIDE_EVENT, nodeIdArray:[node]};
  this.viewerImpl.api.fireEvent(event);
};
Autodesk.Viewing.Private.VisibilityManager.prototype.showMultiple = function(nodes) {
  for (var i = 0;i < nodes.length;++i) {
    this.setVisibiltyOnNode(nodes[i], true);
  }
  if (nodes.length > 0) {
    var event = {type:Autodesk.Viewing.SHOW_EVENT, nodeIdArray:nodes};
    this.viewerImpl.api.fireEvent(event);
  }
};
Autodesk.Viewing.Private.VisibilityManager.prototype.show = function(node) {
  this.setVisibiltyOnNode(node, true);
  var event = {type:Autodesk.Viewing.SHOW_EVENT, nodeIdArray:[node]};
  this.viewerImpl.api.fireEvent(event);
};
Autodesk.Viewing.Private.VisibilityManager.prototype.toggleVisibility = function(node) {
  var vis = Autodesk.Viewing.Private.VisibilityManager.isVisible(node);
  this.setVisibiltyOnNode(node, !vis);
  if (vis) {
    var event = {type:Autodesk.Viewing.HIDE_EVENT, nodeIdArray:[node]};
    this.viewerImpl.api.fireEvent(event);
  } else {
    var event = {type:Autodesk.Viewing.SHOW_EVENT, nodeIdArray:[node]};
    this.viewerImpl.api.fireEvent(event);
  }
};
Autodesk.Viewing.Private.VisibilityManager.prototype.setVisibiltyOnNode = function(node, visible) {
  var viewer = this.viewerImpl;
  var model = this.model;
  (function makeInVisibleRec(node) {
    node.visible = visible;
    var frags = node.fragIds;
    if (frags !== undefined) {
      if (Array.isArray(frags)) {
        for (var j = 0;j < frags.length;j++) {
          viewer.setFragmentVisibility(model, frags[j], visible);
        }
      } else {
        viewer.setFragmentVisibility(model, frags, visible);
      }
    }
    if (node.children) {
      for (var k = 0;k < node.children.length;k++) {
        makeInVisibleRec(node.children[k]);
      }
    }
  })(node);
  this.viewerImpl.needGhostedPass = true;
  this.viewerImpl.needsClear = true;
};
Autodesk.Viewing.Private.VisibilityManager.isVisible = function(node) {
  if (node.visible != null) {
    return node.visible;
  }
  return true;
};
Autodesk.Viewing.Private.VisibilityManager.prototype.areAllVisible = function() {
  return this.viewerImpl.isWholeModelVisible(this.model);
};
AutodeskNamespace("Autodesk.Viewing.Private");
var USE_SERVER_SIDE_SEARCH = false;
var NUM_WORKER_THREADS = 3;
var NUM_PARALLEL_DOWNLOADS = 2;
var WORKER_SCRIPT = null;
if (!LMV_WORKER_URL) {
  var LMV_WORKER_URL = "src/workers/MainWorker.js"
}
if (ENABLE_INLINE_WORKER == undefined) {
  var ENABLE_INLINE_WORKER = false
}
if (ENABLE_DEBUG) {
  NUM_WORKER_THREADS = 6;
  NUM_PARALLEL_DOWNLOADS = 6;
}
var WORKER_LOAD_GEOMETRY = "LOAD_GEOMETRY";
var WORKER_LOAD_SVF = "LOAD_SVF";
var WORKER_SEARCH = "SEARCH";
var WORKER_GET_PROPERTIES = "GET_PROPERTIES";
var WORKER_SEARCH_PROPERTIES = "SEARCH_PROPERTIES";
var WORKER_GET_OBJECT_TREE = "GET_OBJECT_TREE";
var WORKER_PARSE_FYDO = "PARSE_FYDO";
var WORKER_STREAM_FYDO = "STREAM_FYDO";
var WORKER_PARSE_FYDO_FRAME = "PARSE_FYDO_FRAME";
var WORKER_CLOUD_RENDERING = "CLOUD_RENDERING";
Autodesk.Viewing.Private.SvfLoader = function(parent) {
  this.viewer3DImpl = parent;
  this.next_pack = 0;
  this.loading = false;
  this.tmpMatrix = new THREE.Matrix4;
  this.getObjectTreeCallbacks = [];
  this.fydoMeshCounter = 0;
  if (!Autodesk.Viewing.Private.logger) {
    var loggerConfig = {console:true, viewingservice:false, webstorage:false, endpoint:"", flushThreshold:0};
    Autodesk.Viewing.Private.logger = new Autodesk.Viewing.Private.Logger(loggerConfig);
  }
  this.logger = Autodesk.Viewing.Private.logger;
  this.loadTime = 0;
};
Autodesk.Viewing.Private.SvfLoader.prototype.uninitialize = function() {
  this.svf = null;
  this.viewer3DImpl = null;
};
Autodesk.Viewing.Private.SvfLoader.prototype.pathToURL = function(path) {
  if (path.substr(0, 7) == "http://" || (path.substr(0, 8) == "https://" || (path.substr(0, 8) == "file:///" || path.substr(0, 4) == "urn:"))) {
    return path;
  }
  var rootRelPath = window.location.pathname;
  var lastSlash = rootRelPath.lastIndexOf("/");
  rootRelPath = rootRelPath.substr(0, lastSlash + 1);
  var absPath = window.location.protocol + "//" + window.location.host + rootRelPath + path;
  return absPath;
};
Autodesk.Viewing.Private.SvfLoader.prototype.loadSvf = function(path, ids, propertyDbPath, onSuccess, onError) {
  if (this.loading) {
    stderr("loading of SVF already in progress.");
    return false;
  }
  var index = path.indexOf("urn:");
  if (index != -1) {
    this.logger.bindURN(path.substr(index, path.substr(index).indexOf("/")));
    stderr("Extracted URN: " + this.logger.urn);
  }
  this.sharedDbPath = propertyDbPath;
  var isf2d = path.indexOf(".f2d") != -1;
  if (ENABLE_INLINE_WORKER) {
    var xhr = new XMLHttpRequest;
    var scriptURL = FORCE_USE_LOCAL_WORKER_SCRIPT ? LMV_WORKER_URL : RESOURCE_ROOT + LMV_WORKER_URL;
    scriptURL += "?domain=" + window.location.hostname;
    xhr.open("GET", scriptURL, true);
    xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
    var scope = this;
    xhr.onload = function() {
      WORKER_SCRIPT = xhr.responseText;
      if (isf2d) {
        scope.loadFydoCB(path, ids, onSuccess, onError);
      } else {
        scope.loadSvfCB(path, ids, onSuccess, onError);
      }
    };
    xhr.send();
    return true;
  } else {
    if (isf2d) {
      return this.loadFydoCB(path, ids, onSuccess, onError);
    } else {
      return this.loadSvfCB(path, ids, onSuccess, onError);
    }
  }
};
Autodesk.Viewing.Private.SvfLoader.prototype.loadSvfCB = function(path, ids, onSuccess, onError) {
  this.t0 = (new Date).getTime();
  this.failedToLoadSomeGeometryPacks = null;
  var w = createWorker();
  var scope = this;
  var onSVFLoad = function(ew) {
    var cleaner = function() {
      w.removeEventListener("message", onSVFLoad);
      w.terminate();
      w = null;
    };
    if (ew.data && ew.data.svf) {
      var svf = scope.svf = ew.data.svf;
      svf.geomPolyCount = 0;
      svf.instancePolyCount = 0;
      svf.geomMemory = 0;
      svf.fragments.numLoaded = 0;
      svf.meshCount = 0;
      svf.gpuNumMeshes = 0;
      svf.gpuMeshMemory = 0;
      svf.basePath = "";
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash != -1) {
        svf.basePath = path.substr(0, lastSlash + 1);
      }
      if (scope.failedToLoadSomeGeometryPacks) {
        if (onError) {
          onError(scope.failedToLoadSomeGeometryPacks.code, scope.failedToLoadSomeGeometryPacks.msg);
        }
        scope.failedToLoadSomeGeometryPacks = null;
      }
      scope.onSvfLoadDone(svf);
      if (onSuccess) {
        onSuccess(svf);
      }
      var numGeomPacks = svf.geompacks.length;
      if (numGeomPacks) {
        var count = Math.min(numGeomPacks, NUM_PARALLEL_DOWNLOADS);
        for (var i = 0;i < count;i++) {
          var pf = svf.geompacks[i];
          scope.loadGeometryPack(pf.id, pf.uri);
          scope.next_pack = i + 1;
        }
      } else {
        scope.onGeomLoadDone();
      }
      scope.loading = false;
      cleaner();
    } else {
      if (ew.data && ew.data.progress) {
      } else {
        if (ew.data && ew.data.error) {
          scope.loading = false;
          cleaner();
          if (onError) {
            onError(ew.data.error.code, ew.data.error.msg);
          }
        } else {
          if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
          } else {
            stderr("SVF download failed.");
            scope.loading = false;
            cleaner();
          }
        }
      }
    }
  };
  w.addEventListener("message", onSVFLoad, false);
  var svfPath = this.pathToURL(path);
  var msg = {operation:WORKER_LOAD_SVF, url:svfPath, headers:{}, objectIds:ids, auth:auth, viewing_url:VIEWING_URL, queryParams:"domain=" + window.location.hostname};
  w.postMessage(msg);
  return true;
};
Autodesk.Viewing.Private.SvfLoader.prototype.loadFydoCB = function(path, ids, onSuccess, onError) {
  this.t0 = (new Date).getTime();
  var streamingWorker = createWorker();
  var parsingWorker = createWorker();
  var scope = this;
  var onStream = function(ew) {
    if (ew.data && ew.data.type == "FYDOBLOB") {
      var msg = {operation:WORKER_PARSE_FYDO, data:ew.data.buffer, metadata:ew.data.metadata};
      parsingWorker.postMessage(msg);
    } else {
      if (ew.data && ew.data.type == "FYDOSTREAM") {
        var msg = {operation:WORKER_PARSE_FYDO_FRAME, data:ew.data.frames, metadata:ew.data.metadata};
        parsingWorker.postMessage(msg);
      } else {
        if (ew.data && ew.data.finished == true) {
          streamingWorker.terminate();
        } else {
          if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
          } else {
            if (ew.data && ew.data.error) {
              scope.loading = false;
              streamingWorker.terminate();
              if (onError) {
                onError.call(ew.data.error.code, ew.data.error.msg);
              }
            } else {
              stderr("FYDO download failed.");
              scope.loading = false;
              streamingWorker.terminate();
            }
          }
        }
      }
    }
  };
  var onParse = function(ew) {
    if (ew.data && ew.data.fydo) {
      var f = scope.svf = ew.data.fydo;
      stderr("Num polylines: " + f.numPolylines);
      stderr("Line segments: " + f.numLineSegs);
      stderr("Circular arcs: " + f.numCircles);
      stderr("Ellipitcal arcs:" + f.numEllipses);
      stderr("Total # of op codes generated by fydo.parse: " + f.opCount);
      f.basePath = "";
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash != -1) {
        f.basePath = path.substr(0, lastSlash + 1);
      }
      scope.onSvfLoadDone(f);
      if (onSuccess) {
        onSuccess(f);
      }
      for (var i = 0;i < f.meshes.length;i++) {
        var mdata = {mesh:f.meshes[i], packId:"0", meshIndex:i};
        f.fragments.materials[i] = scope.viewer3DImpl.create2DMaterial(f.meshes[i].material);
        scope.processReceivedMesh(mdata);
      }
      scope.onGeomLoadDone();
      f.loadDone = true;
      scope.loading = false;
      parsingWorker.terminate();
    } else {
      if (ew.data && ew.data.fydoframe) {
        stderr("# of op codes generated by fydo.parseFrame: " + ew.data.fydoframe.opCount);
        var f = scope.svf = ew.data.fydoframe;
        f.basePath = "";
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash != -1) {
          f.basePath = path.substr(0, lastSlash + 1);
        }
        scope.onSvfLoadDone(f);
        if (onSuccess && !scope.fydoMeshCounter) {
          onSuccess(f);
        }
        for (var i = scope.fydoMeshCounter;i < f.meshes.length;i++, scope.fydoMeshCounter++) {
          var mdata = {mesh:f.meshes[i], packId:"0", meshIndex:i};
          f.fragments.materials[i] = scope.viewer3DImpl.create2DMaterial(f.meshes[i].material);
          scope.processReceivedMesh(mdata);
        }
        scope.onGeomLoadDone();
        f.loadDone = true;
        scope.loading = false;
      } else {
        if (ew.data && ew.data.progress) {
        } else {
          if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
          } else {
            if (ew.data && ew.data.error) {
              scope.loading = false;
              parsingWorker.terminate();
              if (onError) {
                onError.call(ew.data.error.code, ew.data.error.msg);
              }
            } else {
              stderr("FYDO download failed.");
              scope.loading = false;
              parsingWorker.terminate();
            }
          }
        }
      }
    }
  };
  streamingWorker.addEventListener("message", onStream, false);
  parsingWorker.addEventListener("message", onParse, false);
  var svfPath = this.pathToURL(path);
  var msg = {operation:WORKER_STREAM_FYDO, url:svfPath, headers:{}, objectIds:ids, auth:auth, viewing_url:VIEWING_URL, queryParams:"domain=" + window.location.hostname};
  streamingWorker.postMessage(msg);
  return true;
};
Autodesk.Viewing.Private.SvfLoader.prototype.loadGeometryPack = function(packId, path) {
  var w;
  var workerId;
  var i, j;
  var scope = this;
  if (!this.pack_workers) {
    this.pack_workers = [];
    var onMeshLoad = function(ew) {
      if (ew.data && ew.data.mesh) {
        scope.processReceivedMesh(ew.data);
        if (ew.data.progress >= 1) {
          scope.pack_workers[ew.data.workerId].queued -= 1;
          var isdone = true;
          for (j = 0;j < scope.pack_workers.length;j++) {
            if (scope.pack_workers[j].queued != 0) {
              isdone = false;
              break;
            }
          }
          if (isdone) {
            for (j = 0;j < NUM_WORKER_THREADS;j++) {
              scope.pack_workers[j].terminate();
              scope.pack_workers[j].removeEventListener("message", onMeshLoad);
            }
            scope.pack_workers = null;
          }
          if (scope.svf.fragments.numLoaded == scope.svf.fragments.length) {
            scope.onGeomLoadDone();
            scope.loadTextures();
          }
        }
      } else {
        if (ew.data && ew.data.progress) {
          scope.pack_workers[ew.data.workerId].queued -= 1;
          if (scope.next_pack < scope.svf.geompacks.length) {
            var pf = scope.svf.geompacks[scope.next_pack++];
            scope.loadGeometryPack(pf.id, pf.uri);
          }
        } else {
          if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
          } else {
            if (ew.data && ew.data.error) {
              scope.failedToLoadSomeGeometryPacks = {code:ew.data.error.code, msg:ew.data.error.msg};
            } else {
              scope.pack_workers[ew.data.workerId].queued -= 2;
            }
          }
        }
      }
    };
    for (i = 0;i < NUM_WORKER_THREADS;i++) {
      var wr = createWorker();
      wr.addEventListener("message", onMeshLoad, false);
      wr.queued = 0;
      this.pack_workers.push(wr);
    }
  }
  var which = 0;
  var queued = this.pack_workers[0].queued;
  for (i = 1;i < NUM_WORKER_THREADS;i++) {
    if (this.pack_workers[i].queued < queued) {
      which = i;
    }
  }
  w = this.pack_workers[which];
  w.queued += 2;
  workerId = which;
  var reqPath = this.pathToURL(this.svf.basePath + path);
  var xfer = {"operation":WORKER_LOAD_GEOMETRY, "url":reqPath, "packId":parseInt(packId), "headers":{}, "workerId":workerId, "auth":auth, "viewing_url":VIEWING_URL, "queryParams":"domain=" + window.location.hostname};
  w.postMessage(xfer);
};
Autodesk.Viewing.Private.SvfLoader.prototype.convertMaterials = function() {
  var svf = this.svf;
  if (!svf.materials) {
    return;
  }
  var prmats = svf.materials["materials"];
  for (var p in prmats) {
    var simplemat = svf.simplemats[p];
    if (simplemat) {
      simplemat.color = (new THREE.Color).copy(simplemat.color);
      simplemat.ambient = (new THREE.Color).copy(simplemat.ambient);
      simplemat.specular = (new THREE.Color).copy(simplemat.specular);
      simplemat.emissive = (new THREE.Color).copy(simplemat.emissive);
      var phongMat = new THREE.MeshPhongMaterial(simplemat);
      phongMat.metal = simplemat.metal;
      if (!_isIE11 && (simplemat.doubleSided || svf.metadata && (svf.metadata.hasOwnProperty("double sided geometry") && svf.metadata["double sided geometry"]["value"]))) {
        phongMat.side = THREE.DoubleSide;
      }
      for (var uri in simplemat) {
        if (uri.indexOf("uri_") == 0) {
          phongMat[uri] = simplemat[uri];
        }
        if (uri.indexOf("uscale_") == 0) {
          phongMat[uri] = simplemat[uri];
        }
        if (uri.indexOf("vscale_") == 0) {
          phongMat[uri] = simplemat[uri];
        }
      }
      this.viewer3DImpl.addMaterial(p, phongMat);
    } else {
      this.viewer3DImpl.addMaterial(p, new THREE.MeshPhongMaterial({ambient:197379, color:7829367, specular:3355443, shininess:30, shading:THREE.SmoothShading}));
    }
  }
};
Autodesk.Viewing.Private.SvfLoader.prototype.loadTextures = function() {
  var svf = this.svf;
  var scope = this;
  scope.textures = {};
  for (var p in scope.viewer3DImpl.materials) {
    var material = scope.viewer3DImpl.materials[p];
    if (material) {
      var onTexLoad = function(tex) {
        var def = scope.textures[tex.name];
        for (var i = 0;i < def.mats.length;i++) {
          def.mats[i][def.slots[i]] = tex;
        }
        scope.viewer3DImpl.addTexture(def);
      };
      var maps = ["map", "bumpMap", "specularMap", "normalMap", "envMap"];
      if (material.bumpScale && material.bumpScale >= 1) {
        material.bumpScale = 0.03;
      }
      for (var i = 0;i < maps.length;i++) {
        var uriField = "uri_" + maps[i];
        var uri = material[uriField];
        if (uri) {
          if (scope.textures[uri]) {
            scope.textures[uri].mats.push(material);
            scope.textures[uri].slots.push(maps[i]);
          } else {
            var isEnvMap = maps[i] == "envMap";
            uri = uri.replace(/\\/g, "/");
            var texPath = scope.pathToURL(svf.basePath + uri);
            var index = texPath.indexOf("urn:");
            if (index != -1) {
              texPath = texPath.substr(0, index) + encodeURIComponent(texPath.substr(index));
              texPath += "?domain=" + window.location.hostname;
            }
            var texture;
            var uScale = material["uscale_" + maps[i]];
            var vScale = material["vscale_" + maps[i]];
            if (!uScale) {
              uScale = 1;
            }
            if (!vScale) {
              vScale = 1;
            }
            if (auth) {
              if (texPath.indexOf("/items/") != -1) {
                THREE.ImageUtils.crossOrigin = "use-credentials";
              } else {
                THREE.ImageUtils.crossOrigin = "";
              }
            }
            if (isEnvMap) {
              texture = THREE.ImageUtils.loadTexture(texPath, new THREE.SphericalReflectionMapping, onTexLoad);
            } else {
              texture = THREE.ImageUtils.loadTexture(texPath, new THREE.UVMapping, onTexLoad);
            }
            texture.name = uri;
            scope.textures[uri] = {mats:[material], slots:[maps[i]], tex:texture};
            if (maps[i] == "bumpMap" || maps[i] == "normalMap") {
              texture.anisotropy = 0;
            } else {
              texture.anisotropy = scope.viewer3DImpl.renderer.getMaxAnisotropy();
            }
            texture.repeat.set(uScale, vScale);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.flipY = !isEnvMap;
            if (isEnvMap) {
              svf.envMap = texture;
            }
          }
        }
      }
    }
  }
};
function meshToGeometry(mdata) {
  var mesh = mdata.mesh;
  var geometry = new THREE.BufferGeometry;
  mdata.byteSize = 0;
  geometry.vb = mesh.vb;
  geometry.vbstride = mesh.vbstride;
  geometry.isLines = mesh.isLines;
  for (var attributeName in mesh.vblayout) {
    var attributeData = mesh.vblayout[attributeName];
    geometry.attributes[attributeName] = {itemSize:attributeData.itemSize, itemOffset:attributeData.offset, bytesPerItem:attributeData.bytesPerItem, normalize:attributeData.normalize, isPattern:attributeData.isPattern};
  }
  mdata.byteSize += mesh.vb.byteLength;
  geometry.attributes.index = {itemSize:1, array:mesh.indices};
  mdata.byteSize += mesh.indices.byteLength;
  geometry.freeCPUBuffers = false;
  if (mesh.vb.length / mesh.vbstride > 65535) {
    stderr("Mesh with >65535 vertices. It will fail to draw.");
  }
  geometry.boundingBox = (new THREE.Box3).copy(mesh.boundingBox);
  geometry.boundingSphere = (new THREE.Sphere).copy(mesh.boundingSphere);
  mdata.geometry = geometry;
  mdata.geometry.isLines = mdata.mesh.isLines === true;
  delete mdata.mesh;
}
function getFragmentTransform(dstmtx, fragments, fragId) {
  var mtxOffset = fragId * 16;
  var fragTransforms = fragments.transforms;
  if (!fragTransforms) {
    return null;
  }
  var isIdentity = true;
  for (var j = 0;j < 16;j++) {
    if (j % 5 && fragTransforms[mtxOffset + j] != 0 || !(j % 5) && fragTransforms[mtxOffset + j] != 1) {
      isIdentity = false;
      break;
    }
  }
  if (!isIdentity) {
    for (var k = 0;k < 16;k++) {
      dstmtx.elements[k] = fragTransforms[mtxOffset + k];
    }
    return dstmtx;
  } else {
    return null;
  }
}
Autodesk.Viewing.Private.SvfLoader.prototype.processReceivedMesh = function(mdata) {
  meshToGeometry(mdata);
  var meshid = mdata.packId + ":" + mdata.meshIndex;
  var svf = this.svf;
  var fragments = svf.fragments;
  var fragIndexes = fragments.mesh2frag[meshid];
  if (fragIndexes === undefined) {
    stderr("Mesh " + meshid + " was not referenced by any fragments.");
    return;
  }
  svf.meshCount++;
  var GPU_MEMORY_LOW = 64 * 1024 * 1024;
  var GPU_MEMORY_HIGH = 128 * 1024 * 1024;
  var GPU_ITEMS_LOW = MAX_FRAGS_PER_GROUP;
  var GPU_ITEMS_HIGH = 2E3;
  var CHROME_D3D11_WORKAROUND = false;
  if (svf.gpuMeshMemory < GPU_MEMORY_LOW && svf.gpuNumMeshes < GPU_ITEMS_LOW) {
    mdata.geometry.streamingDraw = false;
    mdata.geometry.streamingIndex = false;
  } else {
    if (svf.gpuMeshMemory > GPU_MEMORY_HIGH || svf.gpuNumMeshes > GPU_ITEMS_HIGH) {
      mdata.geometry.streamingDraw = true;
      mdata.geometry.streamingIndex = true && !CHROME_D3D11_WORKAROUND;
    } else {
      var weightScore;
      if (Array.isArray(fragIndexes)) {
        weightScore = fragIndexes.length * mdata.byteSize;
      } else {
        if ((0 | fragIndexes) < 300) {
          mdata.geometry.streamingDraw = false;
          mdata.geometry.streamingIndex = false;
        } else {
          weightScore = mdata.byteSize;
        }
      }
      if (weightScore < 1E5) {
        mdata.geometry.streamingDraw = true;
        mdata.geometry.streamingIndex = true && !CHROME_D3D11_WORKAROUND;
      }
    }
  }
  if (!mdata.geometry.streamingDraw) {
    svf.gpuMeshMemory += mdata.byteSize;
    svf.gpuNumMeshes += 1;
  }
  if (!Array.isArray(fragIndexes)) {
    var mtx = getFragmentTransform(this.tmpMatrix, fragments, 0 | fragIndexes);
    var materialId = fragments.materials[fragIndexes];
    this.viewer3DImpl.addMeshInstance(mdata.geometry, 0 | fragIndexes, materialId, mtx);
  } else {
    for (var i = 0;i < fragIndexes.length;i++) {
      var fragId = 0 | fragIndexes[i];
      var materialId = fragments.materials[fragId];
      this.viewer3DImpl.addMeshInstance(mdata.geometry, fragId, materialId, getFragmentTransform(this.tmpMatrix, fragments, fragId));
    }
  }
  delete fragments.mesh2frag[meshid];
  var numTris = mdata.geometry.attributes.index.array.length / 3;
  svf.geomPolyCount += numTris;
  svf.instancePolyCount += numTris * (fragIndexes.length || 1);
  svf.geomMemory += mdata.byteSize;
  var first = !fragments.numLoaded;
  fragments.numLoaded += fragIndexes.length || 1;
  var numLoaded = fragments.numLoaded;
  var total = fragments.length;
  var fraction = numLoaded / total;
  var invfract = 0 | total / numLoaded;
  var ispow2 = (invfract & invfract - 1) == 0;
  if (first || ispow2 && this.lastRepaintFract != invfract) {
    this.lastRepaintFract = invfract;
    this.viewer3DImpl.needsRender = true;
  }
  if (fraction == 1) {
    this.viewer3DImpl.needsClear = true;
  }
  if (fraction < 1 && numLoaded % 10 == 0) {
    this.viewer3DImpl.signalProgress(fraction * 100, "fragment " + numLoaded + " / " + total);
  }
};
Autodesk.Viewing.Private.SvfLoader.prototype.onSvfLoadDone = function(svf) {
  var t1 = Date.now();
  this.loadTime += t1 - this.t0;
  stderr("SVF load: " + (t1 - this.t0));
  this.convertMaterials();
  this.t0 = t1;
  svf.bbox = new THREE.Box3(svf.bbox.min, svf.bbox.max);
  stderr("scene bounds: " + JSON.stringify(svf.bbox));
  this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
};
Autodesk.Viewing.Private.SvfLoader.prototype.onGeomLoadDone = function() {
  this.svf.loadDone = true;
  delete this.svf.fragments.entityIndexes;
  delete this.svf.fragments.packIds;
  var t1 = Date.now();
  var msg = "Fragments load time: " + (t1 - this.t0);
  this.loadTime += t1 - this.t0;
  this.viewer3DImpl.signalProgress(100, msg);
  this.viewer3DImpl.api.fireEvent({type:Autodesk.Viewing.GEOMETRY_LOADED_EVENT});
  stderr(msg);
  stderr("Total geometry size: " + this.svf.geomMemory / (1024 * 1024) + " MB");
  stderr("Number of meshes: " + this.svf.meshCount);
  stderr("Num Meshes on GPU: " + this.svf.gpuNumMeshes);
  stderr("Net GPU geom memory used: " + this.svf.gpuMeshMemory);
  var modelStats = {viewer_current_time:Date.now(), viewer_model_stats_total_load_time:this.loadTime, viewer_model_stats_total_geometry_size:this.svf.geomMemory / (1024 * 1024), viewer_model_stats_total_meshes_count:this.svf.meshCount, viewer_model_stats_total_meshes_on_gpu:this.svf.gpuNumMeshes, viewer_model_stats_total_gpu_memory_used:this.svf.gpuMeshMemory / (1024 * 1024)};
  this.logger.log(modelStats, true);
};
Autodesk.Viewing.Private.SvfLoader.prototype.getProperties = function(dbId, onSuccessCallback, onErrorCallback) {
  if (!this.propWorker) {
    this.propWorker = createWorker();
  }
  var _this = this;
  var f = function(ew) {
    if (ew.data && ew.data.error) {
      if (onErrorCallback) {
        onErrorCallback(ew.data.error.code, ew.data.error.msg, ew.data.error.args);
      }
    } else {
      if (ew.data && ew.data.debug) {
        stderr(ew.data.message);
      } else {
        if (ew.data && ew.data.dbId === dbId) {
          onSuccessCallback(ew.data.result);
          _this.propWorker.removeEventListener("message", f);
        }
      }
    }
  };
  this.propWorker.addEventListener("message", f, false);
  var reqPath = this.pathToURL(this.svf.basePath);
  if (this.sharedDbPath && !this.svf.propertydb.values.length) {
    reqPath = this.sharedDbPath;
    stderr("Using shared property db: " + reqPath);
  }
  var xfer = {"operation":WORKER_GET_PROPERTIES, "url":reqPath, "propertydb":this.svf.propertydb, "dbId":dbId, "headers":{}, "auth":auth, "viewing_url":VIEWING_URL, "queryParams":"domain=" + window.location.hostname};
  this.propWorker.postMessage(xfer);
};
Autodesk.Viewing.Private.SvfLoader.prototype.searchProperties = function(searchText, onSuccessCallback, onErrorCallback) {
  var _this = this;
  if (USE_SERVER_SIDE_SEARCH) {
    if (!this.searchWorker) {
      this.searchWorker = createWorker();
    }
    var f = function(ew) {
      if (ew.data && ew.data.error) {
        if (onErrorCallback) {
          onErrorCallback(ew.data.error.code, ew.data.error.msg);
        }
      } else {
        if (ew.data && ew.data.debug) {
          stderr(ew.data.message);
        } else {
          var result = JSON.parse(ew.data);
          if (result.type == "debug") {
            stderr(result.debug);
          } else {
            if (result.type == "response") {
              if (onSuccessCallback) {
                onSuccessCallback(result.response);
              }
              _this.searchWorker.removeEventListener("message", f);
            }
          }
        }
      }
    };
    this.searchWorker.addEventListener("message", f, false);
    this.searchWorker.postMessage({"operation":WORKER_SEARCH, "keyword":searchText, "url":this.pathToURL(this.svf.basePath), "id":this.svf.manifest.adskID});
  } else {
    if (!this.propWorker) {
      this.propWorker = createWorker();
    }
    var f = function(ew) {
      if (ew.data && ew.data.error) {
        if (onErrorCallback) {
          onErrorCallback(ew.data.error.code, ew.data.error.msg);
        }
      } else {
        if (ew.data && ew.data.debug) {
          stderr(ew.data.message);
        } else {
          if (onSuccessCallback) {
            onSuccessCallback(ew.data);
          }
          _this.propWorker.removeEventListener("message", f);
        }
      }
    };
    this.propWorker.addEventListener("message", f, false);
    var reqPath = this.pathToURL(this.svf.basePath);
    if (this.sharedDbPath && !this.svf.propertydb.values.length) {
      reqPath = this.sharedDbPath;
      stderr("Using shared property db: " + reqPath);
    }
    var xfer = {"operation":WORKER_SEARCH_PROPERTIES, "url":reqPath, "propertydb":this.svf.propertydb, "searchText":searchText, "headers":{}, "auth":auth, "viewing_url":VIEWING_URL, "queryParams":"domain=" + window.location.hostname};
    this.propWorker.postMessage(xfer);
  }
};
Autodesk.Viewing.Private.SvfLoader.prototype.createFragToNodeMapping = function() {
  var svf = this.svf;
  var f2db = svf.fragments.fragId2dbId;
  if (!svf.instanceTree || !f2db) {
    return;
  }
  var f2n = svf.fragments.fragToDbNode = new Array(f2db.length);
  (function descendTree(node) {
    var frags = node.fragIds;
    if (frags !== undefined) {
      if (Array.isArray(frags)) {
        for (var j = 0;j < frags.length;j++) {
          f2n[frags[j]] = node;
        }
      } else {
        f2n[frags] = node;
      }
    }
    if (node.children) {
      for (var k = 0;k < node.children.length;k++) {
        descendTree(node.children[k]);
      }
    }
  })(svf.instanceTree);
  svf.fragToNodeDone = true;
  this.viewer3DImpl.api.fireEvent({type:Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT});
};
Autodesk.Viewing.Private.SvfLoader.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback) {
  var scope = this;
  if (!this.propWorker) {
    this.propWorker = createWorker();
  }
  this.getObjectTreeCallbacks.push(onSuccessCallback);
  function callCallbacks() {
    for (var i = 0;i < scope.getObjectTreeCallbacks.length;i++) {
      scope.getObjectTreeCallbacks[i](scope.svf.instanceTree);
    }
    scope.getObjectTreeCallbacks = [];
  }
  if (scope.svf.instanceTree) {
    callCallbacks();
    return;
  }
  var onObjectTreeRead = function(ew) {
    if (ew.data && ew.data.error) {
    } else {
      if (ew.data && ew.data.debug) {
        stderr(ew.data.message);
      } else {
        var it = ew.data.instanceTree;
        var ib = ew.data.instanceBoxes;
        if (it) {
          if (!scope.svf.instanceTree) {
            scope.svf.instanceTree = it;
            scope.svf.maxTreeDepth = ew.data.maxTreeDepth;
            scope.createFragToNodeMapping();
          }
        }
        callCallbacks();
        if (ib) {
          scope.svf.instanceBoxes = ib;
          scope.propWorker.removeEventListener("message", onObjectTreeRead);
        }
      }
    }
  };
  this.propWorker.addEventListener("message", onObjectTreeRead, false);
  var reqPath = this.pathToURL(this.svf.basePath);
  if (this.sharedDbPath && !this.svf.propertydb.values.length) {
    reqPath = this.sharedDbPath;
    stderr("Using shared property db: " + reqPath);
  }
  var xfer = {"operation":WORKER_GET_OBJECT_TREE, "url":reqPath, "propertydb":this.svf.propertydb, "headers":{}, "fragToDbId":this.svf.fragments.fragId2dbId, "fragBoxes":this.svf.fragments.boxes, "auth":auth, "viewing_url":VIEWING_URL, "queryParams":"domain=" + window.location.hostname};
  this.propWorker.postMessage(xfer);
};
function createWorker() {
  if (ENABLE_DEBUG || !ENABLE_INLINE_WORKER) {
    return new Worker(LMV_WORKER_URL);
  }
  var blob;
  window.URL = window.URL || window.webkitURL;
  try {
    blob = new Blob([WORKER_SCRIPT], {type:"application/javascript"});
  } catch (e) {
    blob = new BlobBuilder;
    blob.append(WORKER_SCRIPT);
    blob = blob.getBlob();
  }
  return new Worker(URL.createObjectURL(blob));
}
Autodesk.Viewing.Private.SvfLoader.prototype.testCloudRendering = function(viewer) {
  var w = createWorker();
  var scope = this;
  var onRenderingsReady = function(ew) {
    var cleaner = function() {
      w.removeEventListener("message", onRenderingsReady);
      w.terminate();
      w = null;
    };
    if (ew.data && ew.data.renderings) {
      var renderings = ew.data.renderings;
      viewer.raaSPanel.loadThumbnail(renderings.thumbnail);
      viewer.raaSPanel.loadImage(renderings.image);
      stderr(renderings);
    } else {
      if (ew.data && ew.data.progress) {
      } else {
        if (ew.data && ew.data.error) {
          viewer.raaSPanel.imageError();
          cleaner();
        } else {
          if (ew.data && ew.data.debug) {
            console.log(ew.data.message);
          } else {
            console.log("Unexpected error in cloud rendering worker.");
            cleaner();
          }
        }
      }
    }
  };
  w.addEventListener("message", onRenderingsReady, false);
  var msg = {operation:WORKER_CLOUD_RENDERING, url:"urn:dXJuOmFkc2suczM6ZnMuZmlsZTp6aGFuZ3l1bi9yYWFzL0xhbWJvL2NvcmUuc3Bk", headers:{}, auth:auth, viewing_url:VIEWING_URL, queryParams:"domain=" + window.location.hostname, camera:this.viewer3DImpl.camera, canvas:{width:this.viewer3DImpl.canvas.width, height:this.viewer3DImpl.canvas.height}};
  w.postMessage(msg);
};
var Stats = function() {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement("div");
  container.id = "stats";
  container.addEventListener("mousedown", function(event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
  var fpsDiv = document.createElement("div");
  fpsDiv.id = "fps";
  fpsDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
  container.appendChild(fpsDiv);
  var fpsText = document.createElement("div");
  fpsText.id = "fpsText";
  fpsText.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
  fpsText.innerHTML = "FPS";
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement("div");
  fpsGraph.id = "fpsGraph";
  fpsGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement("span");
    bar.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement("div");
  msDiv.id = "ms";
  msDiv.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
  container.appendChild(msDiv);
  var msText = document.createElement("div");
  msText.id = "msText";
  msText.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
  msText.innerHTML = "MS";
  msDiv.appendChild(msText);
  var msGraph = document.createElement("div");
  msGraph.id = "msGraph";
  msGraph.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement("span");
    bar.style.cssText = "width:1px;height:30px;float:left;background-color:#131";
    msGraph.appendChild(bar);
  }
  var setMode = function(value) {
    mode = value;
    switch(mode) {
      case 0:
        fpsDiv.style.display = "block";
        msDiv.style.display = "none";
        break;
      case 1:
        fpsDiv.style.display = "none";
        msDiv.style.display = "block";
        break;
    }
  };
  var updateGraph = function(dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + "px";
  };
  return{REVISION:11, domElement:container, setMode:setMode, begin:function() {
    startTime = Date.now();
  }, end:function() {
    var time = Date.now();
    ms = time - startTime;
    msMin = Math.min(msMin, ms);
    msMax = Math.max(msMax, ms);
    msText.textContent = ms + " MS (" + msMin + "-" + msMax + ")";
    updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
    frames++;
    if (time > prevTime + 2E3) {
      fps = Math.round(frames * 1E3 / (time - prevTime));
      fpsMin = Math.min(fpsMin, fps);
      fpsMax = Math.max(fpsMax, fps);
      fpsText.textContent = fps + " FPS (" + fpsMin + "-" + fpsMax + ")";
      updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
      prevTime = time;
      frames = 0;
      msMin = Infinity;
      msMax = 0;
    }
    return time;
  }, update:function() {
    startTime = this.end();
  }};
};
var MAX_FRAGS_PER_GROUP = 333;
function RenderQueue(initialSize, prototypeScene, initialBbox) {
  var NORMAL = 0, HIGHLIGHTED = 1, HIDDEN = 2, MESH_VISIBLE = 1, MESH_HIGHLIGHTED = 2, MESH_HIDELINES = 4;
  var _currentScene = 0;
  var _firstFrameItems = -1;
  var _allVisible = true;
  var _allVisibleDirty = false;
  var _visibleBounds = new THREE.Box3;
  var _visibleBoundsIncludesGhosted;
  var _tmpBox = new THREE.Box3;
  var _vizmeshes = new Array(initialSize);
  var _vizflags = new Uint8Array(initialSize);
  var _camera;
  var _raycaster = new THREE.Raycaster;
  this.prototypeScene = prototypeScene;
  var _drawMode = NORMAL;
  var _wasBeginFrame = false;
  var numScenes = 0 | (initialSize + MAX_FRAGS_PER_GROUP - 1) / MAX_FRAGS_PER_GROUP;
  var _geomScenes = new Array(numScenes);
  for (var i = 0;i < numScenes;i++) {
    var scene = _geomScenes[i] = new THREE.Scene(true);
    scene.__lights = prototypeScene.__lights;
  }
  this.visibleBoundsDirty = false;
  if (initialBbox) {
    _visibleBounds.copy(initialBbox);
  }
  this.addMesh = function(fragId, mesh) {
    var oldGeom = _vizmeshes[fragId];
    if (oldGeom) {
      stderr("duplicate fragment.");
      oldGeom.parent.remove(oldGeom);
    }
    _vizmeshes[fragId] = mesh;
    _vizflags[fragId] = 1;
    mesh.fragId = fragId;
    var sceneIndex = 0 | fragId / MAX_FRAGS_PER_GROUP;
    var scene = _geomScenes[sceneIndex];
    if (!scene) {
      _geomScenes[sceneIndex] = scene = new THREE.Scene(true);
      scene.__lights = this.prototypeScene.__lights;
    }
    _tmpBox.copy(mesh.geometry.boundingBox);
    _tmpBox.applyMatrix4(mesh.matrixWorld);
    _visibleBounds.union(_tmpBox);
    scene.add(mesh);
    this.visibleBoundsDirty = true;
  };
  this.renderSome = function(renderObjectCB, timeRemaining) {
    var i = _currentScene, iEnd = _geomScenes.length;
    var vizflags = _vizflags;
    var t0 = Date.now();
    var start = t0;
    var firstIter = true;
    var isBeginFrame = i == 0;
    if (isBeginFrame && !_wasBeginFrame) {
      _firstFrameItems = -1;
      _wasBeginFrame = true;
    }
    for (;i < iEnd;i++) {
      var scene = _geomScenes[i];
      var done = false;
      if (isBeginFrame && _firstFrameItems > 0) {
        if (i == _firstFrameItems) {
          done = true;
        }
        firstIter = false;
      } else {
        if (!firstIter) {
          if (timeRemaining <= scene.avgFrameTime * 0.5) {
            done = true;
          }
        } else {
          if (timeRemaining <= 0) {
            done = true;
          }
          firstIter = false;
        }
      }
      if (done) {
        break;
      }
      var children = scene.children;
      var allHidden = true;
      if (_drawMode == HIDDEN) {
        for (var j = 0, jEnd = children.length;j < jEnd;j++) {
          var c = children[j];
          var v = !(vizflags[c.fragId] & 1);
          c.visible = v;
          allHidden = allHidden && !v;
        }
      } else {
        if (_drawMode == HIGHLIGHTED) {
          for (var j = 0, jEnd = children.length;j < jEnd;j++) {
            var c = children[j];
            var v = !!(vizflags[c.fragId] & 2);
            c.visible = v;
            allHidden = allHidden && !v;
          }
        } else {
          for (var j = 0, jEnd = children.length;j < jEnd;j++) {
            var c = children[j];
            var v = vizflags[c.fragId] == 1;
            c.visible = v;
            allHidden = allHidden && !v;
          }
        }
      }
      if (!allHidden) {
        renderObjectCB(scene);
      }
      var t1 = Date.now();
      var delta = t1 - t0;
      t0 = t1;
      if (scene.avgFrameTime === undefined) {
        scene.avgFrameTime = delta;
      } else {
        scene.avgFrameTime = 0.95 * scene.avgFrameTime + 0.05 * delta;
      }
      _currentScene = i + 1;
      timeRemaining -= scene.avgFrameTime;
    }
    if (isBeginFrame && _firstFrameItems == -1) {
      _firstFrameItems = i;
    }
    if (i == iEnd || !isBeginFrame) {
      _firstFrameItems = -1;
      _wasBeginFrame = false;
    }
    return timeRemaining;
  };
  this.isDone = function() {
    return _currentScene == _geomScenes.length;
  };
  this.reset = function(camera) {
    _camera = camera;
    _currentScene = 0;
  };
  this.drawNormalObjectsOnly = function() {
    _drawMode = NORMAL;
  };
  this.drawHighlightedObjectsOnly = function() {
    _drawMode = HIGHLIGHTED;
  };
  this.drawHiddenObjectsOnly = function() {
    _drawMode = HIDDEN;
  };
  this.setOverrideMaterial = function(mat) {
    for (var i = 0, iEnd = _geomScenes.length;i < iEnd;i++) {
      _geomScenes[i].overrideMaterial = mat;
    }
  };
  function setFlagFragment(fragId, flag, value) {
    var old = _vizflags[fragId];
    if (value) {
      _vizflags[fragId] = old | flag;
    } else {
      _vizflags[fragId] = old & ~flag;
    }
  }
  this.setHightlighted = function(fragId, value) {
    setFlagFragment(fragId, MESH_HIGHLIGHTED, value);
    this.visibleBoundsDirty = true;
  };
  this.setVisibility = function(fragId, value) {
    setFlagFragment(fragId, MESH_VISIBLE, value);
    _allVisibleDirty = true;
    this.visibleBoundsDirty = true;
  };
  function setFlagGlobal(flag, value) {
    var vizflags = _vizflags;
    var i = 0, iEnd = vizflags.length;
    if (value) {
      for (;i < iEnd;i++) {
        vizflags[i] = vizflags[i] | flag;
      }
    } else {
      var notflag = ~flag;
      for (;i < iEnd;i++) {
        vizflags[i] = vizflags[i] & notflag;
      }
    }
  }
  this.setAllHighlighted = function(value) {
    setFlagGlobal(MESH_HIGHLIGHTED, value);
    this.visibleBoundsDirty = true;
  };
  this.setAllVisibility = function(value) {
    setFlagGlobal(MESH_VISIBLE, value);
    _allVisible = value;
    _allVisibleDirty = false;
    this.visibleBoundsDirty = true;
  };
  this.hideLines = function(hide) {
    var flag = MESH_HIDELINES;
    var vizflags = _vizflags;
    var i = 0, iEnd = vizflags.length;
    if (hide) {
      for (;i < iEnd;i++) {
        if (_vizmeshes[i] && _vizmeshes[i].isLine) {
          vizflags[i] = vizflags[i] | flag;
        }
      }
    } else {
      var notflag = ~flag;
      for (;i < iEnd;i++) {
        if (_vizmeshes[i] && _vizmeshes[i].isLine) {
          vizflags[i] = vizflags[i] & notflag;
        }
      }
    }
    _allVisibleDirty = true;
  };
  this.isFragVisible = function(frag) {
    return(_vizflags[frag] & 3) == 1;
  };
  this.areAllVisible = function() {
    if (_allVisibleDirty) {
      _allVisible = true;
      _allVisibleDirty = false;
      var vizflags = _vizflags;
      for (var i = 0, iEnd = vizflags.length;i < iEnd;i++) {
        if ((vizflags[i] & 1) == 0) {
          _allVisible = false;
          break;
        }
      }
    }
    return _allVisible;
  };
  this.getVisibleBounds = function(includeGhosted) {
    if (!this.visibleBoundsDirty && includeGhosted == _visibleBoundsIncludesGhosted) {
      return _visibleBounds;
    }
    _visibleBoundsIncludesGhosted = includeGhosted;
    var bounds = _visibleBounds;
    var box = _tmpBox;
    var vizflags = _vizflags;
    var vizmeshes = _vizmeshes;
    bounds.makeEmpty();
    for (var i = 0, iEnd = vizflags.length;i < iEnd;i++) {
      var f = vizflags[i];
      if (f & 1 || includeGhosted && f == 0) {
        var m = vizmeshes[i];
        if (m) {
          m.geometry.boundingBox.getTransformedBox(m.matrixWorld, box);
          bounds.union(box);
        }
      }
    }
    this.visibleBoundsDirty = false;
    return bounds;
  };
  this.rayIntersect = function(position, direction, ignoreTransparent) {
    _raycaster.set(position, direction);
    var intersects = _raycaster.intersectObjects(_geomScenes, true);
    var object = null;
    var intersectPoint = null;
    for (var i = 0;i < intersects.length;i++) {
      var obj = intersects[i].object;
      var isVisible = obj.visible;
      if (obj.fragId !== undefined) {
        isVisible = this.isFragVisible(obj.fragId);
      }
      if (isVisible) {
        if (ignoreTransparent && intersects[i].object.material.transparent) {
          continue;
        }
        object = intersects[i].object;
        intersectPoint = intersects[i].point;
        break;
      }
    }
    return[object, intersectPoint];
  };
  this.getRenderProgress = function() {
    return _currentScene / _geomScenes.length;
  };
  this.getVizmesh = function(fragId) {
    return _vizmeshes[fragId];
  };
  this.getSceneCount = function() {
    return _geomScenes.length;
  };
}
;function RenderContext() {
  var _renderer;
  var _canvas;
  var _depthMaterial;
  var _camera;
  var _worldRadius = 100;
  var _clearPass;
  var _saoBlurPass;
  var _saoPass;
  var _saoMipPass;
  var _saoMipFirstPass;
  var _fxaaPass;
  var _blendPass;
  var _saoBufferValid = false;
  var _depthTarget;
  var _depthMipMap = null;
  var _colorTarget = null;
  var _overlayTarget = null;
  var _postTarget1 = null;
  var _postTarget2 = null;
  var _idTarget = null;
  var _gamma = 1.7;
  var _exposureBias = 0;
  var _w, _h;
  var _readbackBuffer = new Uint8Array(4);
  var _white = {r:1, g:1, b:1};
  var _black = {r:0, g:0, b:0};
  var _blockMRT = false;
  var _settings = {antialias:true, sao:false, useHdrTarget:false, haveTwoSided:false, useSSAA:false, idbuffer:false};
  this.settings = _settings;
  this.init = function(thecanvas, w, h) {
    _blockMRT = window.navigator.userAgent.indexOf("Firefox") != -1 && window.navigator.userAgent.indexOf("Mac OS") != -1;
    _canvas = thecanvas;
    _w = w;
    _h = h;
    this.initPostPipeline(_settings.sao, _settings.antialias, false);
  };
  this.beginScene = function(prototypeScene, camera, needClear) {
    _camera = camera;
    _saoBufferValid = false;
    if (needClear) {
      _renderer.setClearColor(_black, 0);
      _renderer.clearTarget(_colorTarget, false, true, false);
      _clearPass.render(_renderer, _colorTarget, null);
    }
    if (_idTarget) {
      _renderer.setClearColor(_black, 0);
      _renderer.clearTarget(_idTarget, true, false, false);
    }
    if (_settings.sao) {
      if (needClear) {
        _renderer.setClearColor(_black, 0);
        _renderer.clearTarget(_depthTarget, true, false, false);
      }
      _saoPass.uniforms["cameraNear"].value = camera.near;
      _saoPass.uniforms["cameraFar"].value = camera.far;
      _saoMipFirstPass.uniforms["cameraNear"].value = camera.near;
      _saoMipFirstPass.uniforms["cameraInvNearFar"].value = 1 / (camera.near - camera.far);
      var P = camera.projectionMatrix.elements;
      _saoPass.uniforms["projInfo"].value.set(-2 / (_colorTarget.width * P[0]), -2 / (_colorTarget.height * P[5]), (1 - P[8]) / P[0], (1 - P[9]) / P[5]);
      var hack_scale = 0.25;
      _saoPass.uniforms["projScale"].value = hack_scale * 0.5 * (_colorTarget.height * P[5]);
    }
    this.renderScenePart(prototypeScene, false);
  };
  this.renderScenePart = function(scene, colorTargetOnly) {
    _saoBufferValid = false;
    if (this.hasMRT()) {
      if (_settings.idbuffer) {
        _renderer.render(scene, _camera, [_colorTarget, _idTarget]);
      } else {
        if (_settings.sao) {
          _renderer.render(scene, _camera, [_colorTarget, _depthTarget]);
        } else {
          _renderer.render(scene, _camera, _colorTarget);
        }
      }
    } else {
      _renderer.render(scene, _camera, _colorTarget);
      if (_settings.sao && !colorTargetOnly) {
        var oldMat = scene.overrideMaterial;
        scene.overrideMaterial = _depthMaterial;
        _renderer.render(scene, _camera, _depthTarget);
        scene.overrideMaterial = oldMat;
      }
    }
  };
  this.clearAllOverlays = function() {
    _renderer.clearTarget(_overlayTarget, true, false, false);
  };
  this.renderOverlays = function(overlays) {
    var haveOverlays = 0;
    for (var key in overlays) {
      if (!overlays.hasOwnProperty(key)) {
        continue;
      }
      var p = overlays[key];
      var s = p.scene;
      var c = p.camera ? p.camera : _camera;
      if (s.children.length) {
        if (!haveOverlays) {
          haveOverlays = 1;
          _renderer.setClearColor(_black, 0);
          _renderer.clearTarget(_overlayTarget, true, false, false);
        }
        if (p.materialPre) {
          s.overrideMaterial = p.materialPre;
          _renderer.render(s, c, _overlayTarget, false);
        }
        if (p.materialPost) {
          s.overrideMaterial = p.materialPost;
          _renderer.context.depthFunc(_renderer.context.GREATER);
          _renderer.render(s, c, _overlayTarget, false);
          _renderer.context.depthFunc(_renderer.context.LEQUAL);
        }
        s.overrideMaterial = null;
      }
    }
    _blendPass.uniforms["useOverlay"].value = haveOverlays;
  };
  this.composeFinalFrame = function(skipAOPass) {
    if (!skipAOPass && _settings.sao) {
      if (!_saoBufferValid) {
        if (_depthMipMap) {
          var prevMip = _depthMipMap[0];
          _saoMipFirstPass.uniforms["resolution"].value.set(1 / prevMip.width, 1 / prevMip.height);
          _saoMipFirstPass.render(_renderer, prevMip, _depthTarget);
          for (var i = 1;i < _depthMipMap.length;i++) {
            var curMip = _depthMipMap[i];
            _saoMipPass.uniforms["resolution"].value.set(1 / curMip.width, 1 / curMip.height);
            _saoMipPass.render(_renderer, curMip, prevMip);
            prevMip = curMip;
          }
        }
        _saoPass.render(_renderer, _postTarget2, _colorTarget);
        _saoBlurPass.uniforms["axis"].value.set(1, 0);
        _saoBlurPass.render(_renderer, _postTarget1, _postTarget2);
        _saoBlurPass.uniforms["axis"].value.set(0, 1);
        _saoBlurPass.render(_renderer, _postTarget2, _postTarget1);
        _saoBufferValid = true;
      }
      _blendPass.uniforms["useAO"].value = 1;
    } else {
      _blendPass.uniforms["useAO"].value = 0;
    }
    if (_fxaaPass) {
      _blendPass.render(_renderer, _postTarget1, _colorTarget);
      _fxaaPass.render(_renderer, null, _postTarget1);
    } else {
      _blendPass.render(_renderer, null, _colorTarget);
    }
    _renderer.endFrame();
  };
  this.setSize = function(w, h, force) {
    _w = w;
    _h = h;
    _renderer.setSize(w, h);
    var sw = 0 | w * _renderer.devicePixelRatio;
    var sh = 0 | h * _renderer.devicePixelRatio;
    _settings.logicalWidth = w;
    _settings.logicalHeight = h;
    _settings.deviceWidth = sw;
    _settings.deviceHeight = sh;
    var usingSSAA = false;
    if (_settings.useSSAA) {
      if (_settings.antialias) {
        sw *= 3 / _renderer.devicePixelRatio;
        sh *= 3 / _renderer.devicePixelRatio;
        var w = 1;
        while (w < sw) {
          w *= 2;
        }
        var h = 1;
        while (h < sh) {
          h *= 2;
        }
        sw = w;
        sh = h;
      }
      usingSSAA = true;
      force = true;
    }
    if (force || (!_colorTarget || (_colorTarget.width != sw || _colorTarget.height != sh))) {
      _colorTarget = new THREE.WebGLRenderTarget(sw, sh, {minFilter:usingSSAA ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBFormat, type:_settings.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType, stencilBuffer:false, generateMipmaps:usingSSAA});
      _overlayTarget = new THREE.WebGLRenderTarget(sw, sh, {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat, stencilBuffer:false});
      _overlayTarget.shareDepthFrom = _colorTarget;
      _depthTarget = null;
      _postTarget1 = null;
      _postTarget2 = null;
      _depthMipMap = [];
      if (_settings.antialias || _settings.sao) {
        _postTarget1 = new THREE.WebGLRenderTarget(sw, sh, {minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, format:THREE.RGBAFormat, stencilBuffer:false, depthBuffer:false});
      }
    }
    if (_settings.sao) {
      if (force || (!_depthTarget || (_depthTarget.width != sw || _depthTarget.height != sh))) {
        _depthTarget = new THREE.WebGLRenderTarget(sw, sh, {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBFormat, type:THREE.FloatType, stencilBuffer:false});
        _depthTarget.shareDepthFrom = _colorTarget;
        _depthMipMap = [];
        for (var j = 0;j < 5;j++) {
          var mip = new THREE.WebGLRenderTarget(0 | sw / (2 << j), 0 | sh / (2 << j), {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBAFormat, depthBuffer:false, stencilBuffer:false});
          mip.generateMipmaps = false;
          _depthMipMap.push(mip);
          _saoPass.uniforms["tDepth_mip" + (j + 1)].value = mip;
        }
        _renderer.verifyMRTWorks([_colorTarget, _depthTarget]);
        _postTarget2 = _postTarget1.clone();
      }
      _idTarget = null;
    }
    if (_settings.idbuffer) {
      if (force || (!_idTarget || (_idTarget.width != sw || _idTarget.height != sh))) {
        _idTarget = new THREE.WebGLRenderTarget(sw, sh, {minFilter:THREE.NearestFilter, magFilter:THREE.NearestFilter, format:THREE.RGBFormat, type:THREE.UnsignedByteType, stencilBuffer:false, generateMipmaps:usingSSAA});
        _idTarget.shareDepthFrom = _colorTarget;
        _renderer.verifyMRTWorks([_colorTarget, _idTarget]);
        _depthTarget = null;
        _depthMipMap = null;
      }
    }
    if (_saoPass) {
      _saoPass.uniforms["size"].value.set(sw, sh);
      _saoPass.uniforms["tDepth"].value = _depthTarget;
      _saoBlurPass.uniforms["size"].value.set(sw, sh);
      _saoBlurPass.uniforms["resolution"].value.set(1 / sw, 1 / sh);
    }
    if (_fxaaPass) {
      _fxaaPass.uniforms["resolution"].value.set(1 / sw, 1 / sh);
    }
    _blendPass.uniforms["tOverlay"].value = _overlayTarget;
    _blendPass.uniforms["tAO"].value = _postTarget2;
    _blendPass.uniforms["useAO"].value = _settings.sao ? 1 : 0;
    _blendPass.uniforms["resolution"].value.set(1 / sw, 1 / sh);
    _blendPass.uniforms["tID"].value = _idTarget;
  };
  this.getMaxAnisotropy = function() {
    return _renderer.getMaxAnisotropy();
  };
  this.hasMRT = function() {
    return!_blockMRT && _renderer.supportsMRT();
  };
  this.initPostPipeline = function(useSAO, useFXAA, useIDBuffer) {
    _settings.sao = useSAO && !_isIE11;
    _settings.antialias = useFXAA && !_isIE11;
    _settings.idbuffer = useIDBuffer;
    if (useIDBuffer) {
      _settings.sao = false;
    }
    function setNoDepthNoBlend(material) {
      material.blending = THREE.NoBlending;
      material.depthWrite = false;
      material.depthTest = false;
    }
    if (!_renderer) {
      var dpr = window.devicePixelRatio;
      if (!dpr) {
        dpr = 1;
      }
      var params = {canvas:_canvas, antialias:false, alpha:false, premultipliedAlpha:false, preserveDrawingBuffer:true, stencil:false, depth:false, devicePixelRatio:dpr};
      _renderer = new FireflyWebGLRenderer(params);
      this.screenCaptureRenderer = _renderer;
      _renderer.autoClear = false;
      _renderer.sortObjects = false;
    }
    if (_settings.sao) {
      if (!_saoPass) {
        var depthShader = NormalsShader;
        _depthMaterial = new THREE.ShaderMaterial({fragmentShader:depthShader.fragmentShader, vertexShader:depthShader.vertexShader, uniforms:THREE.UniformsUtils.clone(depthShader.uniforms)});
        _depthMaterial.blending = THREE.NoBlending;
        if (_settings.haveTwoSided) {
          _depthMaterial.side = THREE.DoubleSide;
        }
        _saoPass = new THREE.ShaderPass(SAOShader);
        setNoDepthNoBlend(_saoPass.material);
        _saoBlurPass = new THREE.ShaderPass(SAOBlurShader);
        setNoDepthNoBlend(_saoBlurPass.material);
        _saoMipFirstPass = new THREE.ShaderPass(SAOMinifyFirstShader);
        setNoDepthNoBlend(_saoMipFirstPass.material);
        _saoMipPass = new THREE.ShaderPass(SAOMinifyShader);
        setNoDepthNoBlend(_saoMipPass.material);
      }
    }
    if (_settings.antialias) {
      if (!_fxaaPass) {
        _fxaaPass = new THREE.ShaderPass(FXAAShader);
        setNoDepthNoBlend(_fxaaPass.material);
      }
    } else {
      _fxaaPass = null;
    }
    if (!_blendPass) {
      _blendPass = new THREE.ShaderPass(BlendShader);
      setNoDepthNoBlend(_blendPass.material);
    }
    if (!_clearPass) {
      _clearPass = new THREE.ShaderPass(BackgroundShader);
      setNoDepthNoBlend(_clearPass.material);
    }
    this.setSize(_w, _h);
  };
  this.setClearColors = function(colorTop, colorBot) {
    _clearPass.uniforms["color2"].value.copy(colorTop);
    if (colorBot) {
      _clearPass.uniforms["color1"].value.copy(colorBot);
    } else {
      _clearPass.uniforms["color1"].value.set(0, 0, 0, 1);
    }
  };
  this.setAOOptions = function(radius, intensity) {
    if (_saoPass) {
      if (radius !== undefined) {
        _saoPass.uniforms["radius"].value = radius;
      }
      if (intensity !== undefined) {
        _saoPass.uniforms["intensity"].value = intensity;
      }
      _saoBufferValid = false;
    }
  };
  this.setGamma = function(gamma) {
    if (_blendPass) {
      _gamma = gamma;
      _blendPass.uniforms["gamma"].value = 1 / gamma;
    }
  };
  this.getGamma = function() {
    return _gamma;
  };
  this.setExposureBias = function(bias, lightMultiplier) {
    if (_blendPass) {
      _exposureBias = bias;
      _blendPass.uniforms["exposureBias"].value = Math.pow(2, bias);
      _clearPass.uniforms["luminance"].value = Math.pow(2, -bias);
    }
  };
  this.getExposureBias = function() {
    return _exposureBias;
  };
  this.getWhiteScale = function() {
    return _blendPass.uniforms["whiteScale"].value;
  };
  this.setTonemapMethod = function(value) {
    if (_blendPass) {
      if (value == 0) {
        if (_settings.useHdrTarget) {
          _settings.useHdrTarget = false;
          this.setSize(_w, _h, true);
        }
        _renderer.gammaInput = false;
      } else {
        if (!_settings.useHdrTarget) {
          _settings.useHdrTarget = true;
          this.setSize(_w, _h, true);
        }
        _renderer.gammaInput = true;
      }
      _blendPass.uniforms["toneMapMethod"].value = value;
    }
    if (_clearPass) {
      _clearPass.uniforms["linearize"].value = value == 0 ? 0 : 1;
    }
  };
  this.getToneMapMethod = function() {
    return _blendPass.uniforms["toneMapMethod"].value;
  };
  this.toggleTwoSided = function(isTwoSided) {
    if (_settings.haveTwoSided != isTwoSided) {
      if (_depthMaterial) {
        _depthMaterial.side = isTwoSided ? THREE.DoubleSide : THREE.FrontSide;
        _depthMaterial.needsUpdate = true;
      }
    }
    _settings.haveTwoSided = isTwoSided;
  };
  this.idAtPixel = function(vpx, vpy) {
    if (!_idTarget) {
      return 0;
    }
    var px = (vpx + 1) * 0.5 * _idTarget.width;
    var py = (vpy + 1) * 0.5 * _idTarget.height;
    _renderer.readPixels(_idTarget, px, py, 1, 1, _readbackBuffer);
    return _readbackBuffer[2] << 16 | _readbackBuffer[1] << 8 | _readbackBuffer[0];
  };
  this.highlightObjectViewport = function(vpx, vpy) {
    var objId = this.idAtPixel(vpx, vpy);
    if (objId == 0) {
      _readbackBuffer[0] = _readbackBuffer[1] = _readbackBuffer[2] = _readbackBuffer[3] = 0;
    }
    _blendPass.uniforms["objID"].value = objId;
    _blendPass.uniforms["objIDv3"].value.set(_readbackBuffer[0] / 255, _readbackBuffer[1] / 255, _readbackBuffer[2] / 255);
  };
}
;FXAAShader = {uniforms:{"tDiffuse":{type:"t", value:null}, "resolution":{type:"v2", value:new THREE.Vector2(1 / 1024, 1 / 512)}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "#define FXAA_SPAN_MAX     8.0", "#define FXAA_EDGE_THRESHOLD_MIN (1.0/24.0)", "#define FXAA_EDGE_THRESHOLD (1.0/8.0)", 
"#define FXAA_SEARCH_THRESHOLD (1.0/4.0)", "#define FXAA_SEARCH_STEPS 24", "#define FXAA_SUBPIX_TRIM (1.0/4.0)", "#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))", "#define FXAA_SUBPIX_CAP (3.0/4.0)", "vec4 getColor(sampler2D tex, vec2 uv) {", "vec4 c = texture2D(tex, uv);", "return c;", "}", "float FxaaLuma(vec3 rgb) {", "return rgb.y * (0.587/0.299) + rgb.x; }", "vec4 FxaaFilterReturn(vec4 rgba) {", "return rgba;}", "vec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {", "return (vec3(-amountOfA) * b) +", 
"((a * vec3(amountOfA)) + b); }", "vec4 FxaaTex(sampler2D tex, vec2 pos) {", "return getColor(tex, pos.xy);}", "vec4 FxaaTexOff(sampler2D tex, vec2 pos, vec2 offset, vec2 resolution) {", "vec2 uv = pos.xy + offset * resolution;", "return getColor(tex, uv);}", "void main() {", "vec3 rgbN = FxaaTexOff( tDiffuse, vUv, vec2(0.0,-1.0), resolution ).xyz;", "vec3 rgbE = FxaaTexOff( tDiffuse, vUv, vec2(1.0, 0.0), resolution ).xyz;", "vec3 rgbW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,0.0), resolution ).xyz;", 
"vec3 rgbS = FxaaTexOff( tDiffuse, vUv, vec2(0.0, 1.0), resolution ).xyz;", "vec4 rgbaM = FxaaTex( tDiffuse, vUv);", "vec3 rgbM  = rgbaM.xyz;", "float lumaN = FxaaLuma(rgbN);", "float lumaE = FxaaLuma(rgbE);", "float lumaW = FxaaLuma(rgbW);", "float lumaS = FxaaLuma(rgbS);", "float lumaM = FxaaLuma(rgbM);", "float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));", "float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));", "float range = rangeMax - rangeMin;", "if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {", 
"gl_FragColor = FxaaFilterReturn(rgbaM); return;}", "vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;", "float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;", "float rangeL = abs(lumaL - lumaM);", "float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;", "blendL = min(FXAA_SUBPIX_CAP, blendL);", "vec3 rgbNW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,-1.0), resolution ).xyz;", "vec3 rgbNE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,-1.0), resolution ).xyz;", "vec3 rgbSW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,1.0), resolution ).xyz;", 
"vec3 rgbSE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,1.0), resolution ).xyz;", "float opacity  = rgbaM.w;", "rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);", "rgbL *= vec3(1.0/9.0);", "float lumaNW = FxaaLuma( rgbNW);", "float lumaNE = FxaaLuma( rgbNE);", "float lumaSW = FxaaLuma( rgbSW);", "float lumaSE = FxaaLuma( rgbSE);", "float edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +", "abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +", "abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));", 
"float edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +", "abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +", "abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));", "bool horzSpan = edgeHorz >= edgeVert;", "float lengthSign = horzSpan ? -resolution.y : -resolution.x;", "if(!horzSpan) lumaN = lumaW;", "if(!horzSpan) lumaS = lumaE;", "float gradientN = abs(lumaN - lumaM);", "float gradientS = abs(lumaS - lumaM);", "lumaN = (lumaN + lumaM) * 0.5;", "lumaS = (lumaS + lumaM) * 0.5;", 
"bool pairN = gradientN >= gradientS;", "if(!pairN) lumaN = lumaS;", "if(!pairN) gradientN = gradientS;", "if(!pairN) lengthSign *= -1.0;", "vec2 posN;", "posN.x = vUv.x + (horzSpan ? 0.0 : lengthSign * 0.5);", "posN.y = vUv.y + (horzSpan ? lengthSign * 0.5 : 0.0);", "gradientN *= FXAA_SEARCH_THRESHOLD;", "vec2 posP = posN;", "vec2 offNP = horzSpan ? vec2(resolution.x, 0.0) : vec2(0.0, resolution.y);", "float lumaEndN = lumaN;", "float lumaEndP = lumaN;", "bool doneN = false;", "bool doneP = false;", 
"posN += offNP * vec2(-1.0, -1.0);", "posP += offNP * vec2( 1.0,  1.0);", "for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {", "if(!doneN) lumaEndN = FxaaLuma(FxaaTex( tDiffuse, posN.xy).xyz);", "if(!doneP) lumaEndP = FxaaLuma(FxaaTex( tDiffuse, posP.xy).xyz);", "doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);", "doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);", "if(doneN && doneP) break;", "if(!doneN) posN -= offNP;", "if(!doneP) posP += offNP; }", "float dstN = horzSpan ? vUv.x - posN.x : vUv.y - posN.y;", 
"float dstP = horzSpan ? posP.x - vUv.x : posP.y - vUv.y;", "bool directionN = dstN < dstP;", "lumaEndN = directionN ? lumaEndN : lumaEndP;", "if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))", "lengthSign = 0.0;", "float spanLength = (dstP + dstN);", "dstN = directionN ? dstN : dstP;", "float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;", "vec3 rgbF = FxaaTex(tDiffuse, vec2(", "vUv.x + (horzSpan ? 0.0 : subPixelOffset),", "vUv.y + (horzSpan ? subPixelOffset : 0.0))).xyz;", 
"gl_FragColor = FxaaFilterReturn(vec4(FxaaLerp3(rgbL, rgbF, blendL), opacity));", "}"].join("\n")};
TonemapShaderChunk = ["float luminance_post(vec3 rgb) {", "return dot(rgb, vec3(0.299, 0.587, 0.114));", "}", "float luminance_pre(vec3 rgb) {", "return dot(rgb, vec3(0.212671, 0.715160, 0.072169));", "}", "vec3 xyz2rgb(vec3 xyz) {", "vec3 R = vec3( 3.240479, -1.537150, -0.498535);", "vec3 G = vec3(-0.969256,  1.875992,  0.041556);", "vec3 B = vec3( 0.055648, -0.204043,  1.057311);", "vec3 rgb;", "rgb.b = dot(xyz, B);", "rgb.g = dot(xyz, G);", "rgb.r = dot(xyz, R);", "return rgb;", "}", "vec3 rgb2xyz(vec3 rgb) {", 
"vec3 X = vec3(0.412453, 0.35758, 0.180423);", "vec3 Y = vec3(0.212671, 0.71516, 0.0721688);", "vec3 Z = vec3(0.0193338, 0.119194, 0.950227);", "vec3 xyz;", "xyz.x = dot(rgb, X);", "xyz.y = dot(rgb, Y);", "xyz.z = dot(rgb, Z);", "return xyz;", "}", "vec3 xyz2xyY(vec3 xyz) {", "float sum = xyz.x + xyz.y + xyz.z;", "sum = 1.0 / sum;", "vec3 xyY;", "xyY.z = xyz.y;", "xyY.x = xyz.x * sum;", "xyY.y = xyz.y * sum;", "return xyY;", "}", "vec3 xyY2xyz(vec3 xyY) {", "float x = xyY.x;", "float y = xyY.y;", 
"float Y = xyY.z;", "vec3 xyz;", "xyz.y = Y;", "xyz.x = x * (Y / y);", "xyz.z = (1.0 - x - y) * (Y / y);", "return xyz;", "}", "vec3 toneMapUncharted2(vec3 x)", "{", "float A = 0.22;", "float B = 0.30;", "float C = 0.10;", "float D = 0.20;", "float E = 0.01;", "float F = 0.30;", "return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;", "}", "vec3 toneMapReinhard(vec3 rgb, float scale, float Lmax) {", "float L = luminance_pre(rgb);", "float sL = L * scale;", "float tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);", 
"rgb *= tmL;", "return rgb;", "}", "vec3 toneMapReinhardYxy(vec3 rgb, float scale, float Lmax) {", "vec3 xyY = xyz2xyY(rgb2xyz(rgb));", "float L = xyY.z;", "float sL = L * scale;", "float tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);", "xyY.z *= tmL;", "return xyz2rgb(xyY2xyz(xyY));", "}", "vec3 toneMapExpRgb(vec3 rgb) {", "rgb = vec3(1.0) - vec3(exp(rgb * vec3(exposure)));", "return rgb;", "}", "float TonemapMin = -2.152529302052785809;", "float TonemapMax = 1.163792197947214113;", "vec3 log10(vec3 x) { return log(x) * (1.0 / log(10.0));}", 
"float toneMapCanon(float x) {", "float x2 = x  * x;", "float x3 = x  * x2;", "float x4 = x2 * x2;", "float x5 = x2 * x3;", "float x6 = x3 * x3;", "vec3 coeff1 = vec3( 23.921, -70.678,  71.943);", "vec4 coeff2 = vec4(-29.707,  5.9189, -0.4027, 0.0071);", "return dot(coeff1, vec3(x6, x5, x4)) + dot(coeff2, vec4(x3, x2, x, 1.0));", "}"].join("\n");
BlendShader = {uniforms:{"tDiffuse":{type:"t", value:null}, "tAO":{type:"t", value:null}, "useAO":{type:"i", value:0}, "tOverlay":{type:"t", value:null}, "useOverlay":{type:"i", value:0}, "tID":{type:"t", value:null}, "objID":{type:"i", value:0}, "objIDv3":{type:"v3", value:new THREE.Vector3(0, 0, 0)}, "resolution":{type:"v2", value:new THREE.Vector2(1 / 1024, 1 / 512)}, "gamma":{type:"f", value:1 / 1}, "whiteScale":{type:"f", value:1}, "exposureBias":{type:"f", value:1}, "toneMapMethod":{type:"i", 
value:0}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["uniform sampler2D tDiffuse;", "uniform sampler2D tAO;", "uniform int useAO;", "uniform sampler2D tOverlay;", "uniform int useOverlay;", "uniform vec2 resolution;", "uniform float whiteScale;", "uniform float gamma;", "uniform float exposureBias;", "uniform int toneMapMethod;", "uniform int objID;", "uniform vec3 objIDv3;", 
"uniform sampler2D tID;", "varying vec2 vUv;", "float exposure = log(1.0 - 0.6) / (whiteScale * 0.5);", TonemapShaderChunk, "vec4 fetchOverlayTexel(vec2 uv, vec2 offset) {", "return texture2D(tOverlay, uv + resolution * offset);", "}", "vec4 overlayEdgeDetect(vec2 vUv) {", "int has_zero = 0;", "vec4 center;", "vec4 non_zero_pixel;", "float max_alpha = 0.0;", "for (int j=-1; j<=1; j++) {", "for (int i=-1; i<=1; i++) {", "vec4 c = fetchOverlayTexel(vUv, vec2(i, j));", "max_alpha = max(max_alpha, c.a);", 
"if (i==0 && j==0)", "center = c;", "if (c.a == 0.0)", "has_zero++;", "else", "non_zero_pixel = c;", "}", "}", "if (has_zero != 0 && has_zero != 9)", "{", "if (center == vec4(0.0))", "center = non_zero_pixel;", "float maxComponent = max(center.r, max(center.g, center.b));", "center.rgb /= maxComponent;", "center.rgb = sqrt(center.rgb);", "center.a = 0.5 + 0.5 * max_alpha * 0.125 * float(has_zero);", "}", "if (has_zero == 0) {", "center.a = -center.a;", "}", "return center;", "}", "void main() {", 
"vec4 texel = texture2D( tDiffuse, vUv );", "float ao = (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;", "texel.rgb *= ao;", "if (toneMapMethod == 1) {", "texel.rgb *= exposureBias / whiteScale;", "} else if (toneMapMethod == 2) {", "texel.rgb = toneMapReinhard(texel.rgb, exposureBias, whiteScale);", "} else if (toneMapMethod == 3) {", "texel.rgb = toneMapUncharted2(texel.rgb * exposureBias);", "texel.rgb *= 1.0 / toneMapUncharted2(vec3(whiteScale));", "} else if (toneMapMethod == 4) {", "texel.rgb = toneMapExpRgb(texel.rgb * exposureBias);", 
"} else if (toneMapMethod == 5) {", "vec3 indexColor = log10(max(vec3(0.000000001), texel.rgb * exposureBias));", "indexColor = min(vec3(1.0), max(vec3(0.0), (indexColor.rgb - TonemapMin) / (TonemapMax - TonemapMin)));", "texel.rgb = vec3(toneMapCanon(indexColor.r), toneMapCanon(indexColor.g), toneMapCanon(indexColor.b));", "}", "texel.rgb = pow(texel.rgb, vec3(gamma));", "if (useOverlay!=0) {", "vec4 overlay = overlayEdgeDetect(vUv);", "if (overlay.a < 0.0) {", "overlay.a = -overlay.a;", "if (overlay.a >= 0.99) {", 
"overlay.a = 0.75;", "texel.rgb = vec3(luminance_post(texel.rgb));", "}", "}", "texel.rgb = mix(texel.rgb, pow(overlay.rgb, vec3(gamma)), overlay.a);", "}", "if (objID != 0) {", "vec4 idAtPixel = texture2D(tID, vUv);", "vec3 idDelta = abs(idAtPixel.rgb - objIDv3.rgb);", "if (max(max(idDelta.r, idDelta.g), idDelta.b) < 1e-3) {", "texel.rgb = mix(texel.rgb, vec3(1.0,1.0,0.0), 0.25);", "}", "}", "gl_FragColor = texel;", "}"].join("\n")};
THREE.ShaderPass = function(shader, textureID) {
  this.textureID = textureID !== undefined ? textureID : "tDiffuse";
  this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
  this.material = new THREE.ShaderMaterial({uniforms:this.uniforms, vertexShader:shader.vertexShader, fragmentShader:shader.fragmentShader});
  this.renderToScreen = false;
  this.enabled = true;
  this.needsSwap = true;
  this.clear = false;
  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var triangle = new THREE.BufferGeometry;
  var p = new Float32Array(9);
  p[0] = -1;
  p[1] = -1;
  p[2] = 0;
  p[3] = 3;
  p[4] = -1;
  p[5] = 0;
  p[6] = -1;
  p[7] = 3;
  p[8] = 0;
  var uv = new Float32Array(6);
  uv[0] = 0;
  uv[1] = 0;
  uv[2] = 2;
  uv[3] = 0;
  uv[4] = 0;
  uv[5] = 2;
  triangle.attributes.position = {itemSize:3, array:p};
  triangle.attributes.uv = {itemSize:2, array:uv};
  this.quad = new THREE.Mesh(triangle, this.material);
  this.scene = new THREE.Scene;
  this.scene.add(this.quad);
};
THREE.ShaderPass.prototype = {render:function(renderer, writeBuffer, readBuffer, delta) {
  if (this.uniforms[this.textureID]) {
    this.uniforms[this.textureID].value = readBuffer;
  }
  if (this.renderToScreen || !writeBuffer) {
    renderer.render(this.scene, this.camera);
  } else {
    renderer.render(this.scene, this.camera, writeBuffer, this.clear);
  }
}};
SAOShader = {uniforms:{"tDepth":{type:"t", value:null}, "size":{type:"v2", value:new THREE.Vector2(512, 512)}, "cameraNear":{type:"f", value:1}, "cameraFar":{type:"f", value:100}, "radius":{type:"f", value:10}, "bias":{type:"f", value:0.01}, "projScale":{type:"f", value:500}, "projInfo":{type:"v4", value:new THREE.Vector4(0, 0, 0, 0)}, "intensity":{type:"f", value:0.75}, "tDepth_mip1":{type:"t", value:null}, "tDepth_mip2":{type:"t", value:null}, "tDepth_mip3":{type:"t", value:null}, "tDepth_mip4":{type:"t", 
value:null}, "tDepth_mip5":{type:"t", value:null}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["#extension GL_OES_standard_derivatives : enable", "#define USE_MIPMAP 1", "uniform float cameraNear;", "uniform float cameraFar;", "uniform vec2 size;", "uniform float lumInfluence;", "varying vec2 vUv;", "#define NUM_SAMPLES (17)", "#define LOG_MAX_OFFSET (3)", "#define MAX_MIP_LEVEL (5)", 
"#define NUM_SPIRAL_TURNS (7)", "uniform float           projScale;", "uniform sampler2D tDepth;", "#ifdef USE_MIPMAP", "uniform sampler2D tDepth_mip1;", "uniform sampler2D tDepth_mip2;", "uniform sampler2D tDepth_mip3;", "uniform sampler2D tDepth_mip4;", "uniform sampler2D tDepth_mip5;", "#endif", "uniform float radius;", "uniform float bias;", "uniform float intensity;", "float intensityDivR6 = intensity / pow(radius, 6.0);", "vec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){", 
"float alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));", "float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;", "ssR = alpha;", "return vec2(cos(angle), sin(angle));", "}", "float CSZToKey(float z) {", "return clamp(z * (1.0 / -cameraFar), 0.0, 1.0);", "}", "void packKey(float key, out vec2 p) {", "float temp = floor(key * 256.0);", "p.x = temp * (1.0 / 256.0);", "p.y = key * 256.0 - temp;", "}", "float unpackDepth( const in vec4 rgba_depth ) {", "float depth = dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );", 
"if (depth == 0.0)", "return -cameraFar * 1.0e10;", "return depth * (cameraNear - cameraFar) - cameraNear;", "}", "uniform vec4 projInfo;", "vec3 reconstructCSPosition(vec2 S, float z) {", "return vec3((S.xy * projInfo.xy + projInfo.zw) * z, z);", "}", "vec3 reconstructCSFaceNormal(vec3 C) {", "return normalize(cross(dFdy(C), dFdx(C)));", "}", "vec3 reconstructNonUnitCSFaceNormal(vec3 C) {", "return cross(dFdy(C), dFdx(C));", "}", "vec2 sizeM1 = vec2(1.0/(size.x), 1.0/(size.y));", "vec3 getPosition(ivec2 ssP, float depth) {", 
"vec3 P;", "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);", "return P;", "}", "vec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {", "ivec2 ssP = ivec2(ssR * unitOffset) + ssC;", "vec3 P;", "vec2 screenUV = (vec2(ssP) + vec2(0.5)) * sizeM1;", "#ifdef USE_MIPMAP", "int mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));", "if (mipLevel == 0) {", "P.z = texture2D(tDepth, screenUV).z;", "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;", "}", 
"else if (mipLevel == 1)", "P.z = unpackDepth(texture2D(tDepth_mip1, screenUV));", "else if (mipLevel == 2)", "P.z = unpackDepth(texture2D(tDepth_mip2, screenUV));", "else if (mipLevel == 3)", "P.z = unpackDepth(texture2D(tDepth_mip3, screenUV));", "else if (mipLevel == 4)", "P.z = unpackDepth(texture2D(tDepth_mip4, screenUV));", "else if (mipLevel == 5)", "P.z = unpackDepth(texture2D(tDepth_mip5, screenUV));", "#else", "P.z = texture2D(tDepth, screenUV).z;", "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;", 
"#endif", "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);", "return P;", "}", "float radius2 = radius * radius;", "float invRadius2 = 1.0 / radius2;", "float sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {", "float ssR;", "vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);", "ssR *= ssDiskRadius;", "vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);", "vec3 v = Q - C;", "float vv = dot(v, v);", 
"float vn = dot(v, n_C);", "const float epsilon = 0.01;", "float f = max(radius2 - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);", "}", "const bool useNoise = true;", "vec2 rand( const vec2 coord ) {", "vec2 noise;", "if ( useNoise ) {", "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );", "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );", "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );", "} else {", "float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );", 
"float gg = fract( coord.t * ( size.y / 2.0 ) );", "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;", "}", "return ( noise * 2.0  - 1.0 );", "}", "float getRandomAngle(vec2 pos) {", "vec2 rnd = rand(pos);", "return atan(rnd.y, rnd.x);", "}", "void main() {", "ivec2 ssC = ivec2(gl_FragCoord.xy);", "vec4 nrmz = texture2D(tDepth, vUv);", "if (nrmz.z == 0.0) {", "gl_FragColor.r = 1.0;", "gl_FragColor.a = 0.0;", "packKey(1.0, gl_FragColor.gb);", "return;", "}", "vec3 C = getPosition(ssC, nrmz.z);", 
"packKey(CSZToKey(C.z), gl_FragColor.gb);", "float randomPatternRotationAngle = getRandomAngle(vUv);", "vec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));", "float ssDiskRadius = -projScale * radius / C.z;", "float sum = 0.0;", "for (int i = 0; i < NUM_SAMPLES; ++i) {", "sum += sampleAO(ssC, C, n_C, ssDiskRadius, i, randomPatternRotationAngle);", "}", "float A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));", "if (abs(dFdx(C.z)) < 0.02) {", "A -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);", 
"}", "if (abs(dFdy(C.z)) < 0.02) {", "A -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);", "}", "gl_FragColor.r = A;", "gl_FragColor.a = 1.0;", "}"].join("\n")};
SAOBlurShader = {uniforms:{"tDiffuse":{type:"t", value:null}, "size":{type:"v2", value:new THREE.Vector2(512, 512)}, "resolution":{type:"v2", value:new THREE.Vector2(1 / 512, 1 / 512)}, "axis":{type:"v2", value:new THREE.Vector2(1, 0)}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["#define EDGE_SHARPNESS     (1.0)", "#define SCALE               (2)", "#define R                   (4)", 
"#define VALUE_TYPE        float", "#define VALUE_COMPONENTS   r", "#define VALUE_IS_KEY       0", "#define KEY_COMPONENTS     gb", "#if __VERSION__ >= 330", "const float gaussian[R + 1] =", "float[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0", "#endif", "uniform sampler2D   tDiffuse;", "uniform vec2 size;", "uniform vec2 resolution;", "uniform vec2       axis;", "ivec2 axisi = ivec2(axis);", "#define  result         gl_FragColor.VALUE_COMPONENTS", "#define  keyPassThrough gl_FragColor.KEY_COMPONENTS", 
"float unpackKey(vec2 p) {", "return p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);", "}", "varying vec2 vUv;", "void main() {", "#   if __VERSION__ < 330", "float gaussian[R + 1];", "#       if R == 3", "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0", "#       elif R == 4", "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0", "#       elif R == 6", 
"gaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;", "#       endif", "#   endif", "ivec2 ssC = ivec2(gl_FragCoord.xy);", "vec4 temp = texture2D(tDiffuse, vUv);", "gl_FragColor.gb = temp.KEY_COMPONENTS;", "gl_FragColor.a = temp.a;", "VALUE_TYPE sum = temp.VALUE_COMPONENTS;", "if (temp.a == 0.0) {", "result = sum;", "return;", "}", "float key = unpackKey(keyPassThrough);", "float BASE = gaussian[0];", 
"float totalWeight = BASE;", "sum *= totalWeight;", "for (int r = -R; r <= R; ++r) {", "if (r != 0) {", "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;", "temp = texture2D(tDiffuse, ssUV);", "float      tapKey = unpackKey(temp.KEY_COMPONENTS);", "VALUE_TYPE value  = temp.VALUE_COMPONENTS;", "float weight = 0.3 + gaussian[r<0?-r:r];", "float dz = tapKey - key;", "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));", "sum += value * weight;", "totalWeight += weight;", "}", "}", 
"const float epsilon = 0.0001;", "result = sum / (totalWeight + epsilon);", "}"].join("\n")};
SAOMinifyFirstShader = {uniforms:{"tDiffuse":{type:"t", value:null}, "cameraNear":{type:"f", value:1}, "cameraInvNearFar":{type:"f", value:100}, "resolution":{type:"v2", value:new THREE.Vector2(1 / 512, 1 / 512)}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "uniform float cameraNear;", "uniform float cameraInvNearFar;", 
"varying vec2 vUv;", "vec4 packDepth( const in float depth ) {", "vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;", "enc = fract(enc);", "enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);", "return enc;", "}", "void main() {", "vec2 ssP = vec2(gl_FragCoord.xy);", "ssP = ssP * 2.0 + mod(ssP, 2.0);", "ssP = (ssP + 0.5) * resolution * 0.5;", "float depth = texture2D(tDiffuse, ssP).z;", "if (depth != 0.0)", "depth = (depth + cameraNear) * cameraInvNearFar;", "gl_FragColor = packDepth(depth);", 
"}"].join("\n")};
SAOMinifyShader = {uniforms:{"tDiffuse":{type:"t", value:null}, "resolution":{type:"v2", value:new THREE.Vector2(1 / 512, 1 / 512)}}, vertexShader:["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "vec2 ssP = vec2(gl_FragCoord.xy);", "ssP = ssP * 2.0 + mod(ssP, 2.0);", "ssP = (ssP + 0.5) * resolution * 0.5;", 
"gl_FragColor = texture2D(tDiffuse, ssP);", "}"].join("\n")};
NormalsShader = {uniforms:{}, vertexShader:["varying vec3 vNormal;", "varying float depth;", "void main() {", "vNormal = normalize( normalMatrix * normal );", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "depth = mvPosition.z;", "vec4 p_Position = projectionMatrix * mvPosition;", "gl_Position = p_Position;", "}"].join("\n"), fragmentShader:["varying vec3 vNormal;", "varying float depth;", "void main() {", "vec3 n = vNormal;", "n = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "n = normalize( n );", 
"gl_FragColor = vec4(n.x, n.y, depth, 1.0);", "}"].join("\n")};
BackgroundShader = {uniforms:{"color1":{type:"v4", value:new THREE.Vector4(1 / 255, 2 / 255, 3 / 255, 1)}, "color2":{type:"v4", value:new THREE.Vector4(41 / 255, 76 / 255, 120 / 255, 1)}, "luminance":{type:"f", value:1}, "linearize":{type:"i", value:1}}, vertexShader:["uniform vec4 color1;", "uniform vec4 color2;", "uniform float luminance;", "uniform int linearize;", "varying vec4 vcolor;", "void main() {", "if (uv.y == 0.0)", "vcolor = color1;", "else", "vcolor = color2;", "if (linearize != 0)", 
"vcolor *= vcolor;", "vcolor *= luminance;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader:["const vec4 c0 = vec4(1.0, 13.0, 4.0, 16.0);", "const vec4 c1 = vec4(9.0, 5.0, 12.0, 8.0);", "const vec4 c2 = vec4(3.0, 15.0, 2.0, 14.0);", "const vec4 c3 = vec4(11.0, 7.0, 10.0, 6.0);", "varying vec4 vcolor;", "void main() {", "vec4 c = vcolor;", "int i = int(mod(float(gl_FragCoord.x), 4.0));", "int j = int(mod(float(gl_FragCoord.y), 4.0));", 
"vec4 col;", "if (i==0) col = c0; else if (i==1) col = c1; else if (i==2) col = c2; else col = c3;", "float bias;", "if (j==0) bias = col.x; else if (j==1) bias = col.y; else if (j==2) bias = col.z; else bias = col.w;", "c.xyz += bias * (1.0/(17.0*256.0));", "gl_FragColor = c;", "}"].join("\n")};
LineShader = {uniforms:{"pixelsPerUnit":{type:"f", value:1}, "unitsPerPixel":{type:"f", value:1}, "highlightId":{type:"v4", value:new THREE.Vector4(0, 0, 0, 0)}, "tLayerMask":{type:"t", value:null}, "tRaster":{type:"t", value:null}}, attributes:{"flags4b":0, "color4b":0, "dbId4b":0, "extraParams":0}, defines:{}, vertexShader:["#define TAU 6.28318530718", "#define PI 3.14159265358979", "#define HALF_PI 1.57079632679", "#define VBB_LINE_SEGMENT     16.0", "#define VBB_ARC_CIRCULAR     32.0", "#define VBB_ARC_ELLIPTICAL   48.0", 
"#define VBB_TEX_QUAD         64.0", "#define VBB_SEG_START_RIGHT  1.0", "#define VBB_SEG_START_LEFT   2.0", "#define VBB_SEG_END_RIGHT    3.0", "#define VBB_SEG_END_LEFT     4.0", "attribute vec4 color4b;", "attribute vec4 dbId4b;", "attribute vec4 flags4b;", "attribute vec4 extraParams;", "uniform float pixelsPerUnit;", "uniform float unitsPerPixel;", "varying vec4 outColor;", "varying vec4 dbId;", "varying vec2 centralVertex;", "varying vec2 offsetPosition;", "varying vec4 multipurpose;", "uniform sampler2D tLayerMask;", 
"varying float halfWidth;", "void strokeLineSegment(float vertexId) {", "float distanceAlong = uv.x;", "bool isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT);", "float isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;", "float angleTransverse = position.z + isLeftSide * HALF_PI;", "multipurpose.y = distanceAlong;", "float st = sin(angleTransverse);", "float ct = cos(angleTransverse);", "float moveDist = halfWidth + 0.5 * unitsPerPixel;", "vec2 offset = vec2(ct, st) * moveDist;", 
"offsetPosition.xy += offset;", "multipurpose.z = 0.0;", "if (isStartCapVertex) {", "offsetPosition.xy += isLeftSide * vec2(-offset.y, offset.x);", "centralVertex.xy += isLeftSide * vec2(-offset.y, offset.x);", "multipurpose.x = -moveDist;", "}", "else {", "vec2 along = vec2(cos(position.z), sin(position.z));", "offsetPosition.xy += distanceAlong * along;", "centralVertex.xy += distanceAlong * along;", "offsetPosition.xy += isLeftSide * vec2(offset.y, -offset.x);", "centralVertex.xy += isLeftSide * vec2(offset.y, -offset.x);", 
"multipurpose.x = multipurpose.y + moveDist;", "}", "}", "void strokeTexQuad(float vertexId) {", "float distanceAlong = uv.x;", "bool isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT);", "float isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;", "float angleTransverse = position.z + isLeftSide * HALF_PI;", "multipurpose.y = distanceAlong;", "float st = sin(angleTransverse);", "float ct = cos(angleTransverse);", "float moveDist = halfWidth;", "vec2 offset = vec2(ct, st) * moveDist;", 
"offsetPosition.xy += offset;", "multipurpose.z = 1.0;", "halfWidth = 0.0;", "if (isStartCapVertex) {", "offsetPosition.xy += isLeftSide * vec2(0.0, offset.x);", "multipurpose.x = 0.0;", "multipurpose.y = max(0.0, isLeftSide);", "}", "else {", "vec2 along = vec2(cos(position.z), sin(position.z));", "offsetPosition.xy += distanceAlong * along;", "centralVertex.xy += distanceAlong * along;", "offsetPosition.xy += isLeftSide * vec2(0.0, -offset.x);", "multipurpose.x = 1.0;", "multipurpose.y = max(0.0, isLeftSide);", 
"}", "}", "void strokeCircularArc(float vertexId) {", "vec2 angles = vec2(position.z, uv.x);", "float r = extraParams.x;", "bool isStart = (vertexId < VBB_SEG_END_RIGHT);", "bool isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT);", "vec2 minPt;", "vec2 maxPt;", "vec2 endsX = vec2(position.x) + r * cos(angles);", "vec2 endsY = vec2(position.y) + r * sin(angles);", "minPt = maxPt = vec2(endsX.x, endsY.x);", "minPt = min(minPt, vec2(endsX.y, endsY.y));", "maxPt = max(maxPt, vec2(endsX.y, endsY.y));", 
"float start = angles.x;", "float end = angles.y;", "if (end > start) {", "if (start < (0.5 * PI) && end > (0.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y + r));", "maxPt = max(maxPt, vec2(position.x, position.y + r));", "}", "if (start < PI && end > PI) {", "minPt = min(minPt, vec2(position.x - r, position.y));", "maxPt = max(maxPt, vec2(position.x - r, position.y));", "}", "if (start < (1.5 * PI) && end > (1.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y - r));", "maxPt = max(maxPt, vec2(position.x, position.y - r));", 
"}", "}", "else {", "minPt = min(minPt, vec2(position.x + r, position.y));", "maxPt = max(maxPt, vec2(position.x + r, position.y));", "if (start < (0.5 * PI) || end > (0.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y + r));", "maxPt = max(maxPt, vec2(position.x, position.y + r));", "}", "if (start < PI || end > PI) {", "minPt = min(minPt, vec2(position.x - r, position.y));", "maxPt = max(maxPt, vec2(position.x - r, position.y));", "}", "if (start < (1.5 * PI) || end > (1.5 * PI)) {", 
"minPt = min(minPt, vec2(position.x, position.y - r));", "maxPt = max(maxPt, vec2(position.x, position.y - r));", "}", "}", "minPt -= halfWidth + 0.5 * unitsPerPixel;", "maxPt += halfWidth + 0.5 * unitsPerPixel;", "if (isStart)", "offsetPosition.x = minPt.x;", "else", "offsetPosition.x = maxPt.x;", "if (isLeft)", "offsetPosition.y = minPt.y;", "else", "offsetPosition.y = maxPt.y;", "multipurpose.x = angles.x;", "multipurpose.y = -r;", "multipurpose.z = angles.y;", "multipurpose.w = -r;", "}", "void strokeEllipticalArc(float vertexId) {", 
"vec2 angles = vec2(position.z, uv.x);", "float isStart = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;", "float isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? -1.0 : 1.0;", "float major = extraParams.x;", "float minor = extraParams.y;", "vec2 minPt;", "vec2 maxPt;", "vec2 endsX = vec2(position.x) + major * cos(angles);", "vec2 endsY = vec2(position.y) + minor * sin(angles);", "minPt = maxPt = vec2(endsX.x, endsY.x);", "minPt = min(minPt, vec2(endsX.y, endsY.y));", "maxPt = max(maxPt, vec2(endsX.y, endsY.y));", 
"float start = angles.x;", "float end = angles.y;", "if (end > start) {", "if (start < (0.5 * PI) && end > (0.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y + minor));", "maxPt = max(maxPt, vec2(position.x, position.y + minor));", "}", "if (start < PI && end > PI) {", "minPt = min(minPt, vec2(position.x - major, position.y));", "maxPt = max(maxPt, vec2(position.x - major, position.y));", "}", "if (start < (1.5 * PI) && end > (1.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y - minor));", 
"maxPt = max(maxPt, vec2(position.x, position.y - minor));", "}", "}", "else {", "minPt = min(minPt, vec2(position.x + major, position.y));", "maxPt = max(maxPt, vec2(position.x + major, position.y));", "if (start < (0.5 * PI) || end > (0.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y + minor));", "maxPt = max(maxPt, vec2(position.x, position.y + minor));", "}", "if (start < PI || end > PI) {", "minPt = min(minPt, vec2(position.x - major, position.y));", "maxPt = max(maxPt, vec2(position.x - major, position.y));", 
"}", "if (start < (1.5 * PI) || end > (1.5 * PI)) {", "minPt = min(minPt, vec2(position.x, position.y - minor));", "maxPt = max(maxPt, vec2(position.x, position.y - minor));", "}", "}", "minPt -= halfWidth + 0.5 * unitsPerPixel;", "maxPt += halfWidth + 0.5 * unitsPerPixel;", "if (isStart < 0.0)", "offsetPosition.x = minPt.x;", "else", "offsetPosition.x = maxPt.x;", "if (isLeft < 0.0)", "offsetPosition.y = minPt.y;", "else", "offsetPosition.y = maxPt.y;", "multipurpose.x = angles.x;", "multipurpose.y = -major;", 
"multipurpose.z = angles.y;", "multipurpose.w = minor;", "}", "void main() {", "offsetPosition = position.xy;", "centralVertex = position.xy;", "vec4 layerBit = texture2D(tLayerMask, flags4b.ba / 255.0);", "if (layerBit.r == 0.0) {", "outColor = vec4(0.0);", "}", "else {", "float vertexId = mod(flags4b.x, 16.0);", "float geomType = flags4b.x - vertexId;", "float lineWeight = uv.y;", "if (lineWeight > 0.0) {", "if (lineWeight * pixelsPerUnit < 0.33)", "lineWeight = 0.33 * unitsPerPixel;", "}", "else {", 
"lineWeight = abs(lineWeight);", "}", "halfWidth = lineWeight;", "outColor = color4b;", "dbId = dbId4b;", "if (geomType == VBB_LINE_SEGMENT)", "strokeLineSegment(vertexId);", "else if (geomType == VBB_ARC_CIRCULAR)", "strokeCircularArc(vertexId);", "else if (geomType == VBB_ARC_ELLIPTICAL)", "strokeEllipticalArc(vertexId);", "else if (geomType == VBB_TEX_QUAD)", "strokeTexQuad(vertexId);", "else", "halfWidth = 0.0;", "}", "gl_Position = projectionMatrix * modelViewMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );", 
"}"].join("\n"), fragmentShader:["#extension GL_OES_standard_derivatives : enable", "#define TAU 6.28318530718", "#define PI 3.14159265358979", "uniform float pixelsPerUnit;", "uniform float unitsPerPixel;", "float aaRange = 0.5 * unitsPerPixel;", "uniform sampler2D tRaster;", "varying vec4 outColor;", "varying vec4 dbId;", "#ifdef MRT_ID_BUFFER", "#extension GL_EXT_draw_buffers : enable", "#define gl_FragColor gl_FragData[0]", "#endif", "varying vec2 centralVertex;", "varying vec2 offsetPosition;", 
"varying vec4 multipurpose;", "varying float halfWidth;", "float curveGaussian(float r, float width) {", "float amt = clamp(abs(r / (width * 1.0)), 0.0, 1.0);", "amt = max(amt - 0.0, 0.0);", "float exponent = amt * 3.5;", "exponent *= -exponent;", "return clamp(exp(exponent), 0.0, 1.0);", "}", "void fillLineSegment() {", "float radius = halfWidth;", "float parametricDistance = multipurpose.x;", "float segmentLength = multipurpose.y;", "if (parametricDistance < 0.0) {", "radius = sqrt(max(0.0, radius * radius - parametricDistance * parametricDistance));", 
"} else if (parametricDistance >= segmentLength) {", "float d = parametricDistance - segmentLength;", "radius = sqrt(max(0.0, radius * radius - d * d));", "}", "float dist = distance(centralVertex, offsetPosition);", "float range =  dist - radius;", "if (range > aaRange) {", "discard;", "}", "else if (range < -aaRange) {", "gl_FragColor = outColor;", "}", "else {", "gl_FragColor = outColor;", "gl_FragColor.a = curveGaussian(range+aaRange, 2.0 * unitsPerPixel);", "}", "}", "void fillCircularArc() {", 
"float dist = distance(centralVertex, offsetPosition);", "float radius = abs(multipurpose.y);", "float range =  abs(dist - radius);", "if (range > aaRange + halfWidth) {", "discard;", "}", "vec2 angles = multipurpose.xz;", "vec2 direction = offsetPosition - centralVertex;", "float angle = atan(direction.y, direction.x);", "if (angles.x > angles.y)", "angles.x -= TAU;", "else if (angle < 0.0)", "angle += TAU;", "if (angle > angles.x && angle < angles.y) {", "if (range < halfWidth - aaRange) {", "gl_FragColor = outColor;", 
"}", "else {", "gl_FragColor = outColor;", "gl_FragColor.a = curveGaussian(range-halfWidth+aaRange, 2.0 * unitsPerPixel);", "}", "}", "else {", "discard;", "}", "}", "float DistancePointEllipseApprox(vec2 e, vec2 pos) { ", "vec2 dx = dFdx(pos);", "vec2 dy = dFdy(pos);", "vec2 esqr = e * e;", "vec2 possqr = pos * pos;", "vec2 posDivEsqr = pos / esqr;", "vec2 pos2DivE2 = pos * posDivEsqr;", "vec2 dPos = 2.0 * posDivEsqr;", "vec2 dPosx = dPos * dx;", "vec2 dPosy = dPos * dy;", "vec2 dfdxy = vec2(dPosx.x + dPosx.y, dPosy.x + dPosy.y);", 
"float sd = (pos2DivE2.x + pos2DivE2.y - 1.0) / length(dfdxy);", "return abs(sd) * unitsPerPixel * 0.745;", "}", "float DistancePointEllipseSpecial (vec2 e, vec2 y, out vec2 x, float width, float aaRange) {", "float dist;", "vec2 esqr = e * e;", "vec2 ey = e * y;", "float t0 = -esqr[1] + ey[1];", "float t1 = -esqr[1] + length(ey);", "float t;", "vec2 r;", "for (int i = 0; i < 6; ++i) {", "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);", "r = ey / (vec2(t) + esqr);", "vec2 rsq = r * r;", "float f = rsq[0] + rsq[1] - 1.0;", 
"float fsign = sign(f);", "t0 = mix(t0, t, max(0.0, fsign));", "t1 = mix(t1, t, max(0.0, -fsign));", "}", "x = e * r;", "dist = distance(x, y);", "if (dist > max(2.0 * (width + aaRange), e[0] * 0.05))", "return dist;", "for (int i = 0; i < 6; ++i) {", "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);", "r = ey / (vec2(t) + esqr);", "vec2 rsq = r * r;", "float f = rsq[0] + rsq[1] - 1.0;", "float fsign = sign(f);", "t0 = mix(t0, t, max(0.0, fsign));", "t1 = mix(t1, t, max(0.0, -fsign));", "}", "x = e * r;", "dist = distance(x, y);", 
"float ecc = 1.0 +  0.1 * e[0] / e[1];", "if (dist > max(ecc * (width + aaRange), e[0] * 0.001))", "return dist;", "if (dist < (width - aaRange) / ecc)", "return dist;", "for (int i = 0; i < 10; ++i) {", "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);", "r = ey / (vec2(t) + esqr);", "vec2 rsq = r * r;", "float f = rsq[0] + rsq[1] - 1.0;", "float fsign = sign(f);", "t0 = mix(t0, t, max(0.0, fsign));", "t1 = mix(t1, t, max(0.0, -fsign));", "}", "x = e * r;", "dist = distance(x, y);", "return dist;", "}", "float DistancePointEllipse(vec2 e, vec2 y, out vec2 locX, float width, float aaRange) {", 
"vec2 locE, locY;", "float diff = sign(e[0] - e[1]);", "vec2 swizzle = vec2(max(diff, 0.0), -min(diff, 0.0));", "locE.x = dot(e, swizzle.xy);", "locE.y = dot(e, swizzle.yx);", "locY.x = dot(y, swizzle.xy);", "locY.y = dot(y, swizzle.yx);", "vec2 refl = sign(locY);", "locY *= refl;", "vec2 x;", "float distance = DistancePointEllipseSpecial(locE, locY, x, width, aaRange);", "x *= refl;", "locX.x = dot(x, swizzle.xy);", "locX.y = dot(x, swizzle.yx);", "return distance;", "}", "void fillEllipticalArc() {", 
"vec2 radii = abs(multipurpose.yw);", "vec2 dir = offsetPosition - centralVertex;", "float lenDirSq = dot(dir, dir);", "float minRad = min(radii.x, radii.y) - (halfWidth + aaRange);", "if (lenDirSq < minRad * minRad)", "discard;", "vec2 pos;", "float range = DistancePointEllipse(radii, dir, pos, halfWidth, aaRange);", "if (range > halfWidth + aaRange)", "discard;", "float ar = radii[0] / radii[1];", "vec2 angles = multipurpose.xz;", "float angle = atan(ar * pos.y, pos.x);", "if (angles.x > angles.y)", 
"angles.x -= TAU;", "else if (angle < 0.0)", "angle += TAU;", "if (angle > angles.x && angle < angles.y) {", "if (range < halfWidth - aaRange) {", "gl_FragColor = outColor;", "}", "else {", "gl_FragColor = outColor;", "gl_FragColor.a = curveGaussian(range-halfWidth+aaRange, 2.0 * unitsPerPixel);", "}", "}", "else {", "discard;", "}", "}", "void main() {", "if (outColor.a == 0.0) {", "discard;", "}", "if (halfWidth == 0.0) {", "if (multipurpose.z != 0.0)", "gl_FragColor = texture2D(tRaster, multipurpose.xy);", 
"else", "gl_FragColor = outColor;", "}", "else if (multipurpose.y >= 0.0)", "fillLineSegment();", "else if (multipurpose.y == multipurpose.w)", "fillCircularArc();", "else", "fillEllipticalArc();", "#ifdef MRT_ID_BUFFER", "gl_FragData[1] = vec4(dbId.rgb, 1.0);", "#elif defined(ID_COLOR)", "outColor = vec4(dbId.rgba);", "#endif", "}"].join("\n")};
FireflyWebGLRenderer = function(parameters) {
  console.log("THREE.WebGLRenderer", THREE.REVISION);
  parameters = parameters || {};
  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement("canvas"), _precision = parameters.precision !== undefined ? parameters.precision : "highp", _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _stencil = parameters.stencil !== undefined ? parameters.stencil : 
  true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : true, _clearColor = new THREE.Color(0), _clearAlpha = 0;
  this.domElement = _canvas;
  this.context = null;
  this.devicePixelRatio = parameters.devicePixelRatio !== undefined ? parameters.devicePixelRatio : self.devicePixelRatio !== undefined ? self.devicePixelRatio : 1;
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.autoUpdateObjects = true;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.shadowMapEnabled = false;
  this.shadowMapAutoUpdate = true;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapDebug = false;
  this.shadowMapCascade = false;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = true;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {memory:{programs:0, geometries:0, textures:0}, render:{calls:0, vertices:0, faces:0, points:0}};
  var _this = this, _programs = [], _programs_counter = 0, _currentProgram = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryGroupHash = null, _currentCamera = null, _geometryGroupCounter = 0, _usedTextureUnits = 0, _oldDoubleSided = -1, _oldFlipSided = -1, _oldBlending = -1, _oldBlendEquation = -1, _oldBlendSrc = -1, _oldBlendDst = -1, _oldDepthTest = -1, _oldDepthWrite = -1, _oldPolygonOffset = null, _oldPolygonOffsetFactor = null, _oldPolygonOffsetUnits = null, _oldLineWidth = 
  null, _viewportX = 0, _viewportY = 0, _viewportWidth = _canvas.width, _viewportHeight = _canvas.height, _currentWidth = 0, _currentHeight = 0, _enabledAttributes = [], _dynamicBuffers = {}, _frustum = new THREE.Frustum, _projScreenMatrix = new THREE.Matrix4, _viewInverseEnv = new THREE.Matrix4, _vector3 = new THREE.Vector3, _direction = new THREE.Vector3, _lightsNeedUpdate = true, _lights = {ambient:[0, 0, 0], directional:{length:0, colors:new Array, positions:new Array}, point:{length:0, colors:new Array, 
  positions:new Array, distances:new Array}, spot:{length:0, colors:new Array, positions:new Array, distances:new Array, directions:new Array, anglesCos:new Array, exponents:new Array}, hemi:{length:0, skyColors:new Array, groundColors:new Array, positions:new Array}};
  var _gl;
  var _glExtensionTextureFloat;
  var _glExtensionTextureHalfFloat;
  var _glExtensionTextureFloatLinear;
  var _glExtensionStandardDerivatives;
  var _glExtensionTextureFilterAnisotropic;
  var _glExtensionCompressedTextureS3TC;
  var _glExtensionDrawBuffers;
  var _glExtensionElementIndexUint;
  var _drawBuffersWorks = false;
  initGL();
  setDefaultGLState();
  this.context = _gl;
  var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
  var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
  var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter(_glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;
  var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS) : [];
  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
  var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_FLOAT);
  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
  var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_FLOAT);
  var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_INT);
  var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_INT);
  var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.LOW_INT);
  var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_INT);
  var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_INT);
  var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.LOW_INT);
  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
  if (_precision === "highp" && !highpAvailable) {
    if (mediumpAvailable) {
      _precision = "mediump";
      console.warn("WebGLRenderer: highp not supported, using mediump");
    } else {
      _precision = "lowp";
      console.warn("WebGLRenderer: highp and mediump not supported, using lowp");
    }
  }
  if (_precision === "mediump" && !mediumpAvailable) {
    _precision = "lowp";
    console.warn("WebGLRenderer: mediump not supported, using lowp");
  }
  this.getContext = function() {
    return _gl;
  };
  this.supportsVertexTextures = function() {
    return _supportsVertexTextures;
  };
  this.supportsFloatTextures = function() {
    return _glExtensionTextureFloat;
  };
  this.supportsStandardDerivatives = function() {
    return _glExtensionStandardDerivatives;
  };
  this.supportsCompressedTextureS3TC = function() {
    return _glExtensionCompressedTextureS3TC;
  };
  this.supportsMRT = function() {
    return _drawBuffersWorks;
  };
  this.getMaxAnisotropy = function() {
    return _maxAnisotropy;
  };
  this.getPrecision = function() {
    return _precision;
  };
  this.setSize = function(width, height, updateStyle) {
    _canvas.width = width * this.devicePixelRatio;
    _canvas.height = height * this.devicePixelRatio;
    if (this.devicePixelRatio !== 1 && updateStyle !== false) {
      _canvas.style.width = width + "px";
      _canvas.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.setViewport = function(x, y, width, height) {
    _viewportX = x * this.devicePixelRatio;
    _viewportY = y * this.devicePixelRatio;
    _viewportWidth = width * this.devicePixelRatio;
    _viewportHeight = height * this.devicePixelRatio;
    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
  };
  this.setScissor = function(x, y, width, height) {
    _gl.scissor(x, y, width, height);
  };
  this.enableScissorTest = function(enable) {
    enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
  };
  this.setClearColor = function(color, alpha) {
    _clearColor.set(color);
    _clearAlpha = alpha !== undefined ? alpha : 1;
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  };
  this.setClearColorHex = function(hex, alpha) {
    console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");
    this.setClearColor(hex, alpha);
  };
  this.getClearColor = function() {
    return _clearColor;
  };
  this.getClearAlpha = function() {
    return _clearAlpha;
  };
  this.clear = function(color, depth, stencil) {
    var bits = 0;
    if (color === undefined || color) {
      bits |= _gl.COLOR_BUFFER_BIT;
    }
    if (depth === undefined || depth) {
      bits |= _gl.DEPTH_BUFFER_BIT;
    }
    if (stencil === undefined || stencil) {
      bits |= _gl.STENCIL_BUFFER_BIT;
    }
    _gl.clear(bits);
  };
  this.clearColor = function() {
    _gl.clear(_gl.COLOR_BUFFER_BIT);
  };
  this.clearDepth = function() {
    _gl.clear(_gl.DEPTH_BUFFER_BIT);
  };
  this.clearStencil = function() {
    _gl.clear(_gl.STENCIL_BUFFER_BIT);
  };
  this.clearTarget = function(renderTarget, color, depth, stencil) {
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  this.addPostPlugin = function(plugin) {
    plugin.init(this);
    this.renderPluginsPost.push(plugin);
  };
  this.addPrePlugin = function(plugin) {
    plugin.init(this);
    this.renderPluginsPre.push(plugin);
  };
  this.updateShadowMap = function(scene, camera) {
    _currentProgram = null;
    _oldBlending = -1;
    _oldDepthTest = -1;
    _oldDepthWrite = -1;
    _currentGeometryGroupHash = -1;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    _oldDoubleSided = -1;
    _oldFlipSided = -1;
    this.shadowMapPlugin.update(scene, camera);
  };
  function createLineBuffers(geometry) {
    geometry.__webglVertexBuffer = _gl.createBuffer();
    geometry.__webglColorBuffer = _gl.createBuffer();
    geometry.__webglLineDistanceBuffer = _gl.createBuffer();
    _this.info.memory.geometries++;
  }
  function createMeshBuffers(geometryGroup) {
    geometryGroup.__webglVertexBuffer = _gl.createBuffer();
    geometryGroup.__webglNormalBuffer = _gl.createBuffer();
    geometryGroup.__webglTangentBuffer = _gl.createBuffer();
    geometryGroup.__webglColorBuffer = _gl.createBuffer();
    geometryGroup.__webglUVBuffer = _gl.createBuffer();
    geometryGroup.__webglUV2Buffer = _gl.createBuffer();
    geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
    geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
    geometryGroup.__webglFaceBuffer = _gl.createBuffer();
    geometryGroup.__webglLineBuffer = _gl.createBuffer();
    var m, ml;
    _this.info.memory.geometries++;
  }
  var onGeometryDispose = function(event) {
    var geometry = event.target;
    geometry.removeEventListener("dispose", onGeometryDispose);
    deallocateGeometry(geometry);
  };
  var onTextureDispose = function(event) {
    var texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    _this.info.memory.textures--;
  };
  var onRenderTargetDispose = function(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    _this.info.memory.textures--;
  };
  var onMaterialDispose = function(event) {
    var material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  };
  var deleteBuffers = function(geometry) {
    if (geometry.__webglVertexBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglVertexBuffer);
    }
    if (geometry.__webglNormalBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglNormalBuffer);
    }
    if (geometry.__webglTangentBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglTangentBuffer);
    }
    if (geometry.__webglColorBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglColorBuffer);
    }
    if (geometry.__webglUVBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglUVBuffer);
    }
    if (geometry.__webglUV2Buffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglUV2Buffer);
    }
    if (geometry.__webglSkinIndicesBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglSkinIndicesBuffer);
    }
    if (geometry.__webglSkinWeightsBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglSkinWeightsBuffer);
    }
    if (geometry.__webglFaceBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglFaceBuffer);
    }
    if (geometry.__webglLineBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglLineBuffer);
    }
    if (geometry.__webglLineDistanceBuffer !== undefined) {
      _gl.deleteBuffer(geometry.__webglLineDistanceBuffer);
    }
    if (geometry.__webglCustomAttributesList !== undefined) {
      for (var id in geometry.__webglCustomAttributesList) {
        _gl.deleteBuffer(geometry.__webglCustomAttributesList[id].buffer);
      }
    }
    _this.info.memory.geometries--;
  };
  var deallocateGeometry = function(geometry) {
    geometry.__webglInit = undefined;
    if (geometry instanceof THREE.BufferGeometry) {
      if (geometry.vbbuffer !== undefined) {
        _gl.deleteBuffer(geometry.vbbuffer);
      }
      var attributes = geometry.attributes;
      for (var key in attributes) {
        if (attributes[key].buffer !== undefined) {
          _gl.deleteBuffer(attributes[key].buffer);
        }
      }
      _this.info.memory.geometries--;
    } else {
      if (geometry.geometryGroups !== undefined) {
        for (var g in geometry.geometryGroups) {
          var geometryGroup = geometry.geometryGroups[g];
          deleteBuffers(geometryGroup);
        }
      } else {
        deleteBuffers(geometry);
      }
    }
  };
  var deallocateTexture = function(texture) {
    if (texture.image && texture.image.__webglTextureCube) {
      _gl.deleteTexture(texture.image.__webglTextureCube);
    } else {
      if (!texture.__webglInit) {
        return;
      }
      texture.__webglInit = false;
      _gl.deleteTexture(texture.__webglTexture);
    }
  };
  var deallocateRenderTarget = function(renderTarget) {
    if (!renderTarget || !renderTarget.__webglTexture) {
      return;
    }
    _gl.deleteTexture(renderTarget.__webglTexture);
    _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
    _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
  };
  var deallocateMaterial = function(material) {
    var program = material.program;
    if (program === undefined) {
      return;
    }
    material.program = undefined;
    var i, il, programInfo;
    var deleteProgram = false;
    for (i = 0, il = _programs.length;i < il;i++) {
      programInfo = _programs[i];
      if (programInfo.program === program) {
        programInfo.usedTimes--;
        if (programInfo.usedTimes === 0) {
          deleteProgram = true;
        }
        break;
      }
    }
    if (deleteProgram === true) {
      var newPrograms = [];
      for (i = 0, il = _programs.length;i < il;i++) {
        programInfo = _programs[i];
        if (programInfo.program !== program) {
          newPrograms.push(programInfo);
        }
      }
      _programs = newPrograms;
      _gl.deleteProgram(program);
      _this.info.memory.programs--;
    }
  };
  function initCustomAttributes(geometry, object) {
    var nvertices = geometry.vertices.length;
    var material = object.material;
    if (material.attributes) {
      if (geometry.__webglCustomAttributesList === undefined) {
        geometry.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var attribute = material.attributes[a];
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === "v2") {
            size = 2;
          } else {
            if (attribute.type === "v3") {
              size = 3;
            } else {
              if (attribute.type === "v4") {
                size = 4;
              } else {
                if (attribute.type === "c") {
                  size = 3;
                }
              }
            }
          }
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          attribute.needsUpdate = true;
        }
        geometry.__webglCustomAttributesList.push(attribute);
      }
    }
  }
  function initLineBuffers(geometry, object) {
    var nvertices = geometry.vertices.length;
    geometry.__vertexArray = new Float32Array(nvertices * 3);
    geometry.__colorArray = new Float32Array(nvertices * 3);
    geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
    geometry.__webglLineCount = nvertices;
    initCustomAttributes(geometry, object);
  }
  function initMeshBuffers(geometryGroup, object) {
    var geometry = object.geometry, faces3 = geometryGroup.faces3, nvertices = faces3.length * 3, ntris = faces3.length * 1, nlines = faces3.length * 3, material = getBufferMaterial(object, geometryGroup), uvType = bufferGuessUVType(material), normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material);
    geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
    if (normalType) {
      geometryGroup.__normalArray = new Float32Array(nvertices * 3);
    }
    if (geometry.hasTangents) {
      geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
    }
    if (vertexColorType) {
      geometryGroup.__colorArray = new Float32Array(nvertices * 3);
    }
    if (uvType) {
      if (geometry.faceVertexUvs.length > 0) {
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
      }
      if (geometry.faceVertexUvs.length > 1) {
        geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
      }
    }
    if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
      geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
      geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
    }
    geometryGroup.__faceArray = new Uint16Array(ntris * 3);
    geometryGroup.__lineArray = new Uint16Array(nlines * 2);
    var m, ml;
    geometryGroup.__webglFaceCount = ntris * 3;
    geometryGroup.__webglLineCount = nlines * 2;
    if (material.attributes) {
      if (geometryGroup.__webglCustomAttributesList === undefined) {
        geometryGroup.__webglCustomAttributesList = [];
      }
      for (var a in material.attributes) {
        var originalAttribute = material.attributes[a];
        var attribute = {};
        for (var property in originalAttribute) {
          attribute[property] = originalAttribute[property];
        }
        if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
          attribute.__webglInitialized = true;
          var size = 1;
          if (attribute.type === "v2") {
            size = 2;
          } else {
            if (attribute.type === "v3") {
              size = 3;
            } else {
              if (attribute.type === "v4") {
                size = 4;
              } else {
                if (attribute.type === "c") {
                  size = 3;
                }
              }
            }
          }
          attribute.size = size;
          attribute.array = new Float32Array(nvertices * size);
          attribute.buffer = _gl.createBuffer();
          attribute.buffer.belongsToAttribute = a;
          originalAttribute.needsUpdate = true;
          attribute.__original = originalAttribute;
        }
        geometryGroup.__webglCustomAttributesList.push(attribute);
      }
    }
    geometryGroup.__inittedArrays = true;
  }
  function getBufferMaterial(object, geometryGroup) {
    return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
  }
  function materialNeedsSmoothNormals(material) {
    return material && (material.shading !== undefined && material.shading === THREE.SmoothShading);
  }
  function bufferGuessNormalType(material) {
    if (material instanceof THREE.MeshBasicMaterial && !material.envMap || material instanceof THREE.MeshDepthMaterial) {
      return false;
    }
    if (materialNeedsSmoothNormals(material)) {
      return THREE.SmoothShading;
    } else {
      return THREE.FlatShading;
    }
  }
  function bufferGuessVertexColorType(material) {
    if (material.vertexColors) {
      return material.vertexColors;
    }
    return false;
  }
  function bufferGuessUVType(material) {
    if (material.map || (material.lightMap || (material.bumpMap || (material.normalMap || (material.specularMap || material instanceof THREE.ShaderMaterial))))) {
      return true;
    }
    return false;
  }
  function initDirectBuffers(geometry) {
    if (geometry.streamingDraw) {
      if (!geometry.streamingIndex) {
        var index = geometry.attributes["index"];
        if (index) {
          index.buffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, index.array, _gl.STATIC_DRAW);
        }
      }
      return;
    }
    if (geometry.vb) {
      geometry.vbbuffer = _gl.createBuffer();
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.vbbuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, geometry.vb, _gl.STATIC_DRAW);
    }
    var a, attribute, type;
    for (a in geometry.attributes) {
      attribute = geometry.attributes[a];
      if (attribute.array) {
        if (a === "index") {
          type = _gl.ELEMENT_ARRAY_BUFFER;
        } else {
          type = _gl.ARRAY_BUFFER;
        }
        attribute.buffer = _gl.createBuffer();
        _gl.bindBuffer(type, attribute.buffer);
        _gl.bufferData(type, attribute.array, _gl.STATIC_DRAW);
      }
    }
  }
  function setLineBuffers(geometry, hint) {
    var v, c, d, vertex, offset, color, vertices = geometry.vertices, colors = geometry.colors, lineDistances = geometry.lineDistances, vl = vertices.length, cl = colors.length, dl = lineDistances.length, vertexArray = geometry.__vertexArray, colorArray = geometry.__colorArray, lineDistanceArray = geometry.__lineDistanceArray, dirtyVertices = geometry.verticesNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, dirtyLineDistances = geometry.lineDistancesNeedUpdate, customAttributes = geometry.__webglCustomAttributesList, 
    i, il, a, ca, cal, value, customAttribute;
    if (dirtyVertices) {
      for (v = 0;v < vl;v++) {
        vertex = vertices[v];
        offset = v * 3;
        vertexArray[offset] = vertex.x;
        vertexArray[offset + 1] = vertex.y;
        vertexArray[offset + 2] = vertex.z;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors) {
      for (c = 0;c < cl;c++) {
        color = colors[c];
        offset = c * 3;
        colorArray[offset] = color.r;
        colorArray[offset + 1] = color.g;
        colorArray[offset + 2] = color.b;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
    }
    if (dirtyLineDistances) {
      for (d = 0;d < dl;d++) {
        lineDistanceArray[d] = lineDistances[d];
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length;i < il;i++) {
        customAttribute = customAttributes[i];
        if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices")) {
          offset = 0;
          cal = customAttribute.value.length;
          if (customAttribute.size === 1) {
            for (ca = 0;ca < cal;ca++) {
              customAttribute.array[ca] = customAttribute.value[ca];
            }
          } else {
            if (customAttribute.size === 2) {
              for (ca = 0;ca < cal;ca++) {
                value = customAttribute.value[ca];
                customAttribute.array[offset] = value.x;
                customAttribute.array[offset + 1] = value.y;
                offset += 2;
              }
            } else {
              if (customAttribute.size === 3) {
                if (customAttribute.type === "c") {
                  for (ca = 0;ca < cal;ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.r;
                    customAttribute.array[offset + 1] = value.g;
                    customAttribute.array[offset + 2] = value.b;
                    offset += 3;
                  }
                } else {
                  for (ca = 0;ca < cal;ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    offset += 3;
                  }
                }
              } else {
                if (customAttribute.size === 4) {
                  for (ca = 0;ca < cal;ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    customAttribute.array[offset + 3] = value.w;
                    offset += 4;
                  }
                }
              }
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
        }
      }
    }
  }
  function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
    if (!geometryGroup.__inittedArrays) {
      return;
    }
    var normalType = bufferGuessNormalType(material), vertexColorType = bufferGuessVertexColorType(material), uvType = bufferGuessUVType(material), needsSmoothNormals = normalType === THREE.SmoothShading;
    var f, fl, fi, face, vertexNormals, faceNormal, normal, vertexColors, faceColor, vertexTangents, uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4, c1, c2, c3, c4, sw1, sw2, sw3, sw4, si1, si2, si3, si4, sa1, sa2, sa3, sa4, sb1, sb2, sb3, sb4, m, ml, i, il, vn, uvi, uv2i, vk, vkl, vka, nka, chf, faceVertexNormals, a, vertexIndex = 0, offset = 0, offset_uv = 0, offset_uv2 = 0, offset_face = 0, offset_normal = 0, offset_tangent = 0, offset_line = 0, offset_color = 0, offset_custom = 0, offset_customSrc = 
    0, value, vertexArray = geometryGroup.__vertexArray, uvArray = geometryGroup.__uvArray, uv2Array = geometryGroup.__uv2Array, normalArray = geometryGroup.__normalArray, tangentArray = geometryGroup.__tangentArray, colorArray = geometryGroup.__colorArray, customAttributes = geometryGroup.__webglCustomAttributesList, customAttribute, faceArray = geometryGroup.__faceArray, lineArray = geometryGroup.__lineArray, geometry = object.geometry, dirtyVertices = geometry.verticesNeedUpdate, dirtyElements = 
    geometry.elementsNeedUpdate, dirtyUvs = geometry.uvsNeedUpdate, dirtyNormals = geometry.normalsNeedUpdate, dirtyTangents = geometry.tangentsNeedUpdate, dirtyColors = geometry.colorsNeedUpdate, vertices = geometry.vertices, chunk_faces3 = geometryGroup.faces3, obj_faces = geometry.faces, obj_uvs = geometry.faceVertexUvs[0], obj_uvs2 = geometry.faceVertexUvs[1], obj_colors = geometry.colors;
    if (dirtyVertices) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        face = obj_faces[chunk_faces3[f]];
        v1 = vertices[face.a];
        v2 = vertices[face.b];
        v3 = vertices[face.c];
        vertexArray[offset] = v1.x;
        vertexArray[offset + 1] = v1.y;
        vertexArray[offset + 2] = v1.z;
        vertexArray[offset + 3] = v2.x;
        vertexArray[offset + 4] = v2.y;
        vertexArray[offset + 5] = v2.z;
        vertexArray[offset + 6] = v3.x;
        vertexArray[offset + 7] = v3.y;
        vertexArray[offset + 8] = v3.z;
        offset += 9;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
    }
    if (dirtyColors && vertexColorType) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexColors = face.vertexColors;
        faceColor = face.color;
        if (vertexColors.length === 3 && vertexColorType === THREE.VertexColors) {
          c1 = vertexColors[0];
          c2 = vertexColors[1];
          c3 = vertexColors[2];
        } else {
          c1 = faceColor;
          c2 = faceColor;
          c3 = faceColor;
        }
        colorArray[offset_color] = c1.r;
        colorArray[offset_color + 1] = c1.g;
        colorArray[offset_color + 2] = c1.b;
        colorArray[offset_color + 3] = c2.r;
        colorArray[offset_color + 4] = c2.g;
        colorArray[offset_color + 5] = c2.b;
        colorArray[offset_color + 6] = c3.r;
        colorArray[offset_color + 7] = c3.g;
        colorArray[offset_color + 8] = c3.b;
        offset_color += 9;
      }
      if (offset_color > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
      }
    }
    if (dirtyTangents && geometry.hasTangents) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexTangents = face.vertexTangents;
        t1 = vertexTangents[0];
        t2 = vertexTangents[1];
        t3 = vertexTangents[2];
        tangentArray[offset_tangent] = t1.x;
        tangentArray[offset_tangent + 1] = t1.y;
        tangentArray[offset_tangent + 2] = t1.z;
        tangentArray[offset_tangent + 3] = t1.w;
        tangentArray[offset_tangent + 4] = t2.x;
        tangentArray[offset_tangent + 5] = t2.y;
        tangentArray[offset_tangent + 6] = t2.z;
        tangentArray[offset_tangent + 7] = t2.w;
        tangentArray[offset_tangent + 8] = t3.x;
        tangentArray[offset_tangent + 9] = t3.y;
        tangentArray[offset_tangent + 10] = t3.z;
        tangentArray[offset_tangent + 11] = t3.w;
        offset_tangent += 12;
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
    }
    if (dirtyNormals && normalType) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        face = obj_faces[chunk_faces3[f]];
        vertexNormals = face.vertexNormals;
        faceNormal = face.normal;
        if (vertexNormals.length === 3 && needsSmoothNormals) {
          for (i = 0;i < 3;i++) {
            vn = vertexNormals[i];
            normalArray[offset_normal] = vn.x;
            normalArray[offset_normal + 1] = vn.y;
            normalArray[offset_normal + 2] = vn.z;
            offset_normal += 3;
          }
        } else {
          for (i = 0;i < 3;i++) {
            normalArray[offset_normal] = faceNormal.x;
            normalArray[offset_normal + 1] = faceNormal.y;
            normalArray[offset_normal + 2] = faceNormal.z;
            offset_normal += 3;
          }
        }
      }
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
    }
    if (dirtyUvs && (obj_uvs && uvType)) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        fi = chunk_faces3[f];
        uv = obj_uvs[fi];
        if (uv === undefined) {
          continue;
        }
        for (i = 0;i < 3;i++) {
          uvi = uv[i];
          uvArray[offset_uv] = uvi.x;
          uvArray[offset_uv + 1] = uvi.y;
          offset_uv += 2;
        }
      }
      if (offset_uv > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
      }
    }
    if (dirtyUvs && (obj_uvs2 && uvType)) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        fi = chunk_faces3[f];
        uv2 = obj_uvs2[fi];
        if (uv2 === undefined) {
          continue;
        }
        for (i = 0;i < 3;i++) {
          uv2i = uv2[i];
          uv2Array[offset_uv2] = uv2i.x;
          uv2Array[offset_uv2 + 1] = uv2i.y;
          offset_uv2 += 2;
        }
      }
      if (offset_uv2 > 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
      }
    }
    if (dirtyElements) {
      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
        faceArray[offset_face] = vertexIndex;
        faceArray[offset_face + 1] = vertexIndex + 1;
        faceArray[offset_face + 2] = vertexIndex + 2;
        offset_face += 3;
        lineArray[offset_line] = vertexIndex;
        lineArray[offset_line + 1] = vertexIndex + 1;
        lineArray[offset_line + 2] = vertexIndex;
        lineArray[offset_line + 3] = vertexIndex + 2;
        lineArray[offset_line + 4] = vertexIndex + 1;
        lineArray[offset_line + 5] = vertexIndex + 2;
        offset_line += 6;
        vertexIndex += 3;
      }
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
    }
    if (customAttributes) {
      for (i = 0, il = customAttributes.length;i < il;i++) {
        customAttribute = customAttributes[i];
        if (!customAttribute.__original.needsUpdate) {
          continue;
        }
        offset_custom = 0;
        offset_customSrc = 0;
        if (customAttribute.size === 1) {
          if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
            for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
              face = obj_faces[chunk_faces3[f]];
              customAttribute.array[offset_custom] = customAttribute.value[face.a];
              customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
              customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
              offset_custom += 3;
            }
          } else {
            if (customAttribute.boundTo === "faces") {
              for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                value = customAttribute.value[chunk_faces3[f]];
                customAttribute.array[offset_custom] = value;
                customAttribute.array[offset_custom + 1] = value;
                customAttribute.array[offset_custom + 2] = value;
                offset_custom += 3;
              }
            }
          }
        } else {
          if (customAttribute.size === 2) {
            if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
              for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                face = obj_faces[chunk_faces3[f]];
                v1 = customAttribute.value[face.a];
                v2 = customAttribute.value[face.b];
                v3 = customAttribute.value[face.c];
                customAttribute.array[offset_custom] = v1.x;
                customAttribute.array[offset_custom + 1] = v1.y;
                customAttribute.array[offset_custom + 2] = v2.x;
                customAttribute.array[offset_custom + 3] = v2.y;
                customAttribute.array[offset_custom + 4] = v3.x;
                customAttribute.array[offset_custom + 5] = v3.y;
                offset_custom += 6;
              }
            } else {
              if (customAttribute.boundTo === "faces") {
                for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v2.x;
                  customAttribute.array[offset_custom + 3] = v2.y;
                  customAttribute.array[offset_custom + 4] = v3.x;
                  customAttribute.array[offset_custom + 5] = v3.y;
                  offset_custom += 6;
                }
              }
            }
          } else {
            if (customAttribute.size === 3) {
              var pp;
              if (customAttribute.type === "c") {
                pp = ["r", "g", "b"];
              } else {
                pp = ["x", "y", "z"];
              }
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              } else {
                if (customAttribute.boundTo === "faces") {
                  for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                    value = customAttribute.value[chunk_faces3[f]];
                    v1 = value;
                    v2 = value;
                    v3 = value;
                    customAttribute.array[offset_custom] = v1[pp[0]];
                    customAttribute.array[offset_custom + 1] = v1[pp[1]];
                    customAttribute.array[offset_custom + 2] = v1[pp[2]];
                    customAttribute.array[offset_custom + 3] = v2[pp[0]];
                    customAttribute.array[offset_custom + 4] = v2[pp[1]];
                    customAttribute.array[offset_custom + 5] = v2[pp[2]];
                    customAttribute.array[offset_custom + 6] = v3[pp[0]];
                    customAttribute.array[offset_custom + 7] = v3[pp[1]];
                    customAttribute.array[offset_custom + 8] = v3[pp[2]];
                    offset_custom += 9;
                  }
                } else {
                  if (customAttribute.boundTo === "faceVertices") {
                    for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                      value = customAttribute.value[chunk_faces3[f]];
                      v1 = value[0];
                      v2 = value[1];
                      v3 = value[2];
                      customAttribute.array[offset_custom] = v1[pp[0]];
                      customAttribute.array[offset_custom + 1] = v1[pp[1]];
                      customAttribute.array[offset_custom + 2] = v1[pp[2]];
                      customAttribute.array[offset_custom + 3] = v2[pp[0]];
                      customAttribute.array[offset_custom + 4] = v2[pp[1]];
                      customAttribute.array[offset_custom + 5] = v2[pp[2]];
                      customAttribute.array[offset_custom + 6] = v3[pp[0]];
                      customAttribute.array[offset_custom + 7] = v3[pp[1]];
                      customAttribute.array[offset_custom + 8] = v3[pp[2]];
                      offset_custom += 9;
                    }
                  }
                }
              }
            } else {
              if (customAttribute.size === 4) {
                if (customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices") {
                  for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                    face = obj_faces[chunk_faces3[f]];
                    v1 = customAttribute.value[face.a];
                    v2 = customAttribute.value[face.b];
                    v3 = customAttribute.value[face.c];
                    customAttribute.array[offset_custom] = v1.x;
                    customAttribute.array[offset_custom + 1] = v1.y;
                    customAttribute.array[offset_custom + 2] = v1.z;
                    customAttribute.array[offset_custom + 3] = v1.w;
                    customAttribute.array[offset_custom + 4] = v2.x;
                    customAttribute.array[offset_custom + 5] = v2.y;
                    customAttribute.array[offset_custom + 6] = v2.z;
                    customAttribute.array[offset_custom + 7] = v2.w;
                    customAttribute.array[offset_custom + 8] = v3.x;
                    customAttribute.array[offset_custom + 9] = v3.y;
                    customAttribute.array[offset_custom + 10] = v3.z;
                    customAttribute.array[offset_custom + 11] = v3.w;
                    offset_custom += 12;
                  }
                } else {
                  if (customAttribute.boundTo === "faces") {
                    for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                      value = customAttribute.value[chunk_faces3[f]];
                      v1 = value;
                      v2 = value;
                      v3 = value;
                      customAttribute.array[offset_custom] = v1.x;
                      customAttribute.array[offset_custom + 1] = v1.y;
                      customAttribute.array[offset_custom + 2] = v1.z;
                      customAttribute.array[offset_custom + 3] = v1.w;
                      customAttribute.array[offset_custom + 4] = v2.x;
                      customAttribute.array[offset_custom + 5] = v2.y;
                      customAttribute.array[offset_custom + 6] = v2.z;
                      customAttribute.array[offset_custom + 7] = v2.w;
                      customAttribute.array[offset_custom + 8] = v3.x;
                      customAttribute.array[offset_custom + 9] = v3.y;
                      customAttribute.array[offset_custom + 10] = v3.z;
                      customAttribute.array[offset_custom + 11] = v3.w;
                      offset_custom += 12;
                    }
                  } else {
                    if (customAttribute.boundTo === "faceVertices") {
                      for (f = 0, fl = chunk_faces3.length;f < fl;f++) {
                        value = customAttribute.value[chunk_faces3[f]];
                        v1 = value[0];
                        v2 = value[1];
                        v3 = value[2];
                        customAttribute.array[offset_custom] = v1.x;
                        customAttribute.array[offset_custom + 1] = v1.y;
                        customAttribute.array[offset_custom + 2] = v1.z;
                        customAttribute.array[offset_custom + 3] = v1.w;
                        customAttribute.array[offset_custom + 4] = v2.x;
                        customAttribute.array[offset_custom + 5] = v2.y;
                        customAttribute.array[offset_custom + 6] = v2.z;
                        customAttribute.array[offset_custom + 7] = v2.w;
                        customAttribute.array[offset_custom + 8] = v3.x;
                        customAttribute.array[offset_custom + 9] = v3.y;
                        customAttribute.array[offset_custom + 10] = v3.z;
                        customAttribute.array[offset_custom + 11] = v3.w;
                        offset_custom += 12;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
      }
    }
    if (dispose) {
      delete geometryGroup.__inittedArrays;
      delete geometryGroup.__colorArray;
      delete geometryGroup.__normalArray;
      delete geometryGroup.__tangentArray;
      delete geometryGroup.__uvArray;
      delete geometryGroup.__uv2Array;
      delete geometryGroup.__faceArray;
      delete geometryGroup.__vertexArray;
      delete geometryGroup.__lineArray;
      delete geometryGroup.__skinIndexArray;
      delete geometryGroup.__skinWeightArray;
    }
  }
  function setupMeshVertexAttributes(material, programAttributes, geometry, startIndex) {
    var attributeItem, attributePointer, attributeName;
    var hasNonInterleaved = false;
    if (geometry.vb) {
      if (geometry.streamingDraw) {
        var buffer = _dynamicBuffers["interleavedVB"];
        if (!buffer) {
          buffer = _gl.createBuffer();
          _dynamicBuffers["interleavedVB"] = buffer;
        }
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
        _gl.bufferData(_gl.ARRAY_BUFFER, geometry.vb, _gl.STREAM_DRAW);
      } else {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.vbbuffer);
      }
      var stride = geometry.vbstride;
      for (attributeName in programAttributes) {
        if (attributeName == "index") {
          continue;
        }
        attributePointer = programAttributes[attributeName];
        attributeItem = geometry.attributes[attributeName];
        if (attributePointer >= 0) {
          if (attributeItem) {
            if (attributeItem.itemOffset !== undefined) {
              var type = _gl.FLOAT;
              if (attributeItem.hasOwnProperty("bytesPerItem") && attributeItem.bytesPerItem == 1) {
                type = _gl.UNSIGNED_BYTE;
              }
              enableAttribute(attributePointer);
              _gl.vertexAttribPointer(attributePointer, attributeItem.itemSize, type, attributeItem.normalize, stride * 4, (attributeItem.itemOffset + startIndex * stride) * 4);
            } else {
              hasNonInterleaved = true;
            }
          }
        }
      }
    } else {
      hasNonInterleaved = true;
    }
    if (!hasNonInterleaved) {
      return;
    }
    for (attributeName in programAttributes) {
      if (attributeName == "index") {
        continue;
      }
      attributePointer = programAttributes[attributeName];
      attributeItem = geometry.attributes[attributeName];
      if (attributePointer >= 0) {
        if (attributeItem) {
          if (attributeItem.itemOffset === undefined) {
            if (geometry.streamingDraw) {
              var buffer = _dynamicBuffers[attributeName];
              if (!buffer) {
                buffer = _gl.createBuffer();
                _dynamicBuffers[attributeName] = buffer;
              }
              _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
              _gl.bufferData(_gl.ARRAY_BUFFER, attributeItem.array, _gl.DYNAMIC_DRAW);
            } else {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
            }
            var type = _gl.FLOAT;
            if (attributeItem.hasOwnProperty("bytesPerItem") && attributeItem.bytesPerItem == 1) {
              type = _gl.UNSIGNED_BYTE;
            }
            enableAttribute(attributePointer);
            _gl.vertexAttribPointer(attributePointer, attributeItem.itemSize, type, attributeItem.normalize, 0, startIndex * attributeItem.itemSize * 4);
          }
        } else {
          if (material.defaultAttributeValues) {
            if (material.defaultAttributeValues[attributeName].length === 2) {
              _gl.vertexAttrib2fv(attributePointer, material.defaultAttributeValues[attributeName]);
            } else {
              if (material.defaultAttributeValues[attributeName].length === 3) {
                _gl.vertexAttrib3fv(attributePointer, material.defaultAttributeValues[attributeName]);
              }
            }
          }
        }
      }
    }
  }
  function setDirectBuffers(geometry, hint, dispose) {
    if (geometry.streamingDraw) {
      return;
    }
    var attributes = geometry.attributes;
    var vbNeedsUpdate = false;
    var attributeName, attributeItem;
    for (attributeName in attributes) {
      attributeItem = attributes[attributeName];
      if (attributeItem.needsUpdate) {
        if (attributeName === "index") {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint);
        } else {
          if (attributeItem.array) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, attributeItem.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, attributeItem.array, hint);
          } else {
            vbNeedsUpdate = true;
          }
        }
        attributeItem.needsUpdate = false;
      }
      if (dispose && attributeItem.freeCPUBuffers) {
        attributeItem.array = null;
      }
    }
    if (vbNeedsUpdate) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.vbbuffer);
      _gl.bufferData(_gl.ARRAY_BUFFER, geometry.vb, hint);
      if (dispose && geometry.freeCPUBuffers) {
        geometry.vb = null;
      }
    }
  }
  this.renderBufferDirect = function(camera, lights, fog, material, geometry, object) {
    if (material.visible === false) {
      return;
    }
    var program = setProgram(camera, lights, fog, material, object);
    var programAttributes = program.attributes;
    var geometryAttributes = geometry.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryHash = geometry.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (object instanceof THREE.Mesh) {
      var index = geometryAttributes["index"];
      if (index) {
        var offsets = geometry.offsets;
        if (offsets && offsets.length > 1) {
          updateBuffers = true;
        }
        var i = 0;
        do {
          var startIndex, startOffset, count;
          if (offsets) {
            startIndex = offsets[i].index;
            startOffset = offsets[i].start;
            count = offsets[i].count;
          } else {
            startIndex = 0;
            startOffset = 0;
            count = index.array.length;
          }
          if (updateBuffers) {
            setupMeshVertexAttributes(material, programAttributes, geometry, startIndex);
            if (!index.buffer && geometry.streamingDraw) {
              var buffer = _dynamicBuffers["index"];
              if (!buffer) {
                buffer = _gl.createBuffer();
                _dynamicBuffers["index"] = buffer;
              }
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, null);
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, buffer);
              _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, index.array, _gl.DYNAMIC_DRAW);
            } else {
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
            }
          }
          _gl.drawElements(geometry.isLines ? _gl.LINES : _gl.TRIANGLES, count, _gl.UNSIGNED_SHORT, startOffset * 2);
        } while (offsets && ++i < offsets.length);
      } else {
        if (updateBuffers) {
          setupMeshVertexAttributes(material, programAttributes, geometry, startIndex);
        }
        var position = geometry.attributes["position"];
        _gl.drawArrays(geometry.isLines ? _gl.LINE_STRIP : _gl.TRIANGLES, 0, position.array.length / 3);
      }
    } else {
      console.log("Only THREE.Mesh can be rendered by the Firefly renderer. Use THREE.Mesh to draw lines.");
    }
  };
  this.renderBuffer = function(camera, lights, fog, material, geometryGroup, object) {
    if (material.visible === false) {
      return;
    }
    var linewidth, a, attribute, i, il;
    var program = setProgram(camera, lights, fog, material, object);
    var attributes = program.attributes;
    var updateBuffers = false, wireframeBit = material.wireframe ? 1 : 0, geometryGroupHash = geometryGroup.id * 16777215 + program.id * 2 + wireframeBit;
    if (geometryGroupHash !== _currentGeometryGroupHash) {
      _currentGeometryGroupHash = geometryGroupHash;
      updateBuffers = true;
    }
    if (updateBuffers) {
      disableAttributes();
    }
    if (!material.morphTargets && attributes.position >= 0) {
      if (updateBuffers) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
        enableAttribute(attributes.position);
        _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
      }
    }
    if (updateBuffers) {
      if (geometryGroup.__webglCustomAttributesList) {
        for (i = 0, il = geometryGroup.__webglCustomAttributesList.length;i < il;i++) {
          attribute = geometryGroup.__webglCustomAttributesList[i];
          if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
            enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
            _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
          }
        }
      }
      if (attributes.color >= 0) {
        if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
          enableAttribute(attributes.color);
          _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
        } else {
          if (material.defaultAttributeValues) {
            _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
          }
        }
      }
      if (attributes.normal >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
        enableAttribute(attributes.normal);
        _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.tangent >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
        enableAttribute(attributes.tangent);
        _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
      }
      if (attributes.uv >= 0) {
        if (object.geometry.faceVertexUvs[0]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
          enableAttribute(attributes.uv);
          _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        } else {
          if (material.defaultAttributeValues) {
            _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
          }
        }
      }
      if (attributes.uv2 >= 0) {
        if (object.geometry.faceVertexUvs[1]) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
          enableAttribute(attributes.uv2);
          _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
        } else {
          if (material.defaultAttributeValues) {
            _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
          }
        }
      }
      if (attributes.lineDistance >= 0) {
        _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
        enableAttribute(attributes.lineDistance);
        _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
      }
    }
    if (object instanceof THREE.Mesh) {
      if (material.wireframe) {
        setLineWidth(material.wireframeLinewidth);
        if (updateBuffers) {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
        }
        _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0);
      } else {
        if (updateBuffers) {
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
        }
        _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0);
      }
    } else {
      if (object instanceof THREE.Line) {
        var primitives = object.type === THREE.LineStrip ? _gl.LINE_STRIP : _gl.LINES;
        setLineWidth(material.linewidth);
        _gl.drawArrays(primitives, 0, geometryGroup.__webglLineCount);
      }
    }
  };
  function enableAttribute(attribute) {
    if (!_enabledAttributes[attribute]) {
      _gl.enableVertexAttribArray(attribute);
      _enabledAttributes[attribute] = true;
    }
  }
  function disableAttributes() {
    for (var i = 0, iEnd = _enabledAttributes.length;i < iEnd;i++) {
      if (_enabledAttributes[i]) {
        _gl.disableVertexAttribArray(i);
        _enabledAttributes[i] = false;
      }
    }
  }
  function painterSortStable(a, b) {
    if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function numericalSort(a, b) {
    return b[0] - a[0];
  }
  this.render = function(scene, camera, renderTarget, forceClear) {
    if (camera instanceof THREE.Camera === false) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    var i, il, webglObject, object, renderList, lights = scene.__lights, fog = scene.fog;
    _currentMaterialId = -1;
    _lightsNeedUpdate = true;
    if (scene.autoUpdate === true) {
      scene.updateMatrixWorld();
    }
    if (camera.parent === undefined) {
      camera.updateMatrixWorld();
    }
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    if (camera.worldUpTransform) {
      _viewInverseEnv.multiplyMatrices(camera.worldUpTransform, camera.matrixWorld);
    } else {
      _viewInverseEnv.copy(camera.matrixWorld);
    }
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    if (this.autoUpdateObjects) {
      this.initWebGLObjects(scene);
    }
    renderPlugins(this.renderPluginsPre, scene, camera);
    this.setRenderTarget(renderTarget);
    if (this.autoClear || forceClear) {
      this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
    }
    renderList = scene.__webglObjects;
    for (i = 0, il = renderList.length;i < il;i++) {
      webglObject = renderList[i];
      object = webglObject.object;
      webglObject.id = i;
      webglObject.render = false;
      if (object.visible) {
        if (!(object instanceof THREE.Mesh) || (!object.frustumCulled || _frustum.intersectsObject(object))) {
          setupMatrices(object, camera);
          unrollBufferMaterial(webglObject);
          webglObject.render = true;
          if (this.sortObjects === true) {
            if (object.renderDepth !== null) {
              webglObject.z = object.renderDepth;
            } else {
              _vector3.setFromMatrixPosition(object.matrixWorld);
              _vector3.applyProjection(_projScreenMatrix);
              webglObject.z = _vector3.z;
            }
          }
        }
      }
    }
    if (this.sortObjects) {
      renderList.sort(painterSortStable);
    }
    if (scene.overrideMaterial) {
      var material = scene.overrideMaterial;
      this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
      this.setDepthTest(material.depthTest);
      this.setDepthWrite(material.depthWrite);
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      renderObjects(scene.__webglObjects, false, "", camera, lights, fog, true, material);
    } else {
      var material = null;
      this.setBlending(THREE.NoBlending);
      renderObjects(scene.__webglObjects, true, "opaque", camera, lights, fog, false, material);
      renderObjects(scene.__webglObjects, false, "transparent", camera, lights, fog, true, material);
    }
    renderPlugins(this.renderPluginsPost, scene, camera);
    if (renderTarget && (renderTarget.generateMipmaps && (renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter))) {
      updateRenderTargetMipmap(renderTarget);
    }
    this.setDepthTest(true);
    this.setDepthWrite(true);
  };
  this.endFrame = function() {
  };
  function renderPlugins(plugins, scene, camera) {
    if (!plugins.length) {
      return;
    }
    for (var i = 0, il = plugins.length;i < il;i++) {
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
      plugins[i].render(scene, camera, _currentWidth, _currentHeight);
      _currentProgram = null;
      _currentCamera = null;
      _oldBlending = -1;
      _oldDepthTest = -1;
      _oldDepthWrite = -1;
      _oldDoubleSided = -1;
      _oldFlipSided = -1;
      _currentGeometryGroupHash = -1;
      _currentMaterialId = -1;
      _lightsNeedUpdate = true;
    }
  }
  function renderObjects(renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial) {
    var webglObject, object, buffer, material, start, end, delta;
    if (reverse) {
      start = renderList.length - 1;
      end = -1;
      delta = -1;
    } else {
      start = 0;
      end = renderList.length;
      delta = 1;
    }
    for (var i = start;i !== end;i += delta) {
      webglObject = renderList[i];
      if (webglObject.render) {
        object = webglObject.object;
        buffer = webglObject.buffer;
        if (overrideMaterial) {
          material = overrideMaterial;
        } else {
          material = webglObject[materialType];
          if (!material) {
            continue;
          }
          if (useBlending) {
            _this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          }
          _this.setDepthTest(material.depthTest);
          _this.setDepthWrite(material.depthWrite);
          setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        _this.setMaterialFaces(material);
        if (buffer instanceof THREE.BufferGeometry) {
          _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
        } else {
          _this.renderBuffer(camera, lights, fog, material, buffer, object);
        }
      }
    }
  }
  function unrollBufferMaterial(globject) {
    var object = globject.object;
    var buffer = globject.buffer;
    var geometry = object.geometry;
    var material = object.material;
    if (material instanceof THREE.MeshFaceMaterial) {
      var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;
      material = material.materials[materialIndex];
      if (material.transparent) {
        globject.transparent = material;
        globject.opaque = null;
      } else {
        globject.opaque = material;
        globject.transparent = null;
      }
    } else {
      if (material) {
        if (material.transparent) {
          globject.transparent = material;
          globject.opaque = null;
        } else {
          globject.opaque = material;
          globject.transparent = null;
        }
      }
    }
  }
  function sortFacesByMaterial(geometry, material) {
    var f, fl, face, materialIndex, vertices, groupHash, hash_map = {};
    var numMorphTargets = geometry.morphTargets.length;
    var numMorphNormals = geometry.morphNormals.length;
    var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;
    geometry.geometryGroups = {};
    for (f = 0, fl = geometry.faces.length;f < fl;f++) {
      face = geometry.faces[f];
      materialIndex = usesFaceMaterial ? face.materialIndex : 0;
      if (hash_map[materialIndex] === undefined) {
        hash_map[materialIndex] = {"hash":materialIndex, "counter":0};
      }
      groupHash = hash_map[materialIndex].hash + "_" + hash_map[materialIndex].counter;
      if (geometry.geometryGroups[groupHash] === undefined) {
        geometry.geometryGroups[groupHash] = {"faces3":[], "materialIndex":materialIndex, "vertices":0, "numMorphTargets":numMorphTargets, "numMorphNormals":numMorphNormals};
      }
      vertices = 3;
      if (geometry.geometryGroups[groupHash].vertices + vertices > 65535) {
        hash_map[materialIndex].counter += 1;
        groupHash = hash_map[materialIndex].hash + "_" + hash_map[materialIndex].counter;
        if (geometry.geometryGroups[groupHash] === undefined) {
          geometry.geometryGroups[groupHash] = {"faces3":[], "materialIndex":materialIndex, "vertices":0, "numMorphTargets":numMorphTargets, "numMorphNormals":numMorphNormals};
        }
      }
      geometry.geometryGroups[groupHash].faces3.push(f);
      geometry.geometryGroups[groupHash].vertices += vertices;
    }
    geometry.geometryGroupsList = [];
    for (var g in geometry.geometryGroups) {
      geometry.geometryGroups[g].id = _geometryGroupCounter++;
      geometry.geometryGroupsList.push(geometry.geometryGroups[g]);
    }
  }
  this.initWebGLObjects = function(scene) {
    if (!scene.__webglObjects) {
      scene.__webglObjects = [];
    }
    while (scene.__objectsAdded.length) {
      addObject(scene.__objectsAdded[0], scene);
      scene.__objectsAdded.splice(0, 1);
    }
    while (scene.__objectsRemoved.length) {
      removeObject(scene.__objectsRemoved[0], scene);
      scene.__objectsRemoved.splice(0, 1);
    }
    for (var o = 0, ol = scene.__webglObjects.length;o < ol;o++) {
      var object = scene.__webglObjects[o].object;
      if (object.__webglInit === undefined) {
        if (object.__webglActive !== undefined) {
          removeObject(object, scene);
        }
        addObject(object, scene);
      }
      updateObject(object);
    }
  };
  function addObject(object, scene) {
    var g, geometry, material, geometryGroup;
    if (object.__webglInit === undefined) {
      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4;
      object._normalMatrix = new THREE.Matrix3;
      if (object.geometry !== undefined && object.geometry.__webglInit === undefined) {
        object.geometry.__webglInit = true;
        object.geometry.addEventListener("dispose", onGeometryDispose);
      }
      geometry = object.geometry;
      if (geometry === undefined) {
      } else {
        if (geometry instanceof THREE.BufferGeometry) {
          initDirectBuffers(geometry);
        } else {
          if (object instanceof THREE.Mesh) {
            material = object.material;
            if (geometry.geometryGroups === undefined) {
              sortFacesByMaterial(geometry, material);
            }
            for (g in geometry.geometryGroups) {
              geometryGroup = geometry.geometryGroups[g];
              if (!geometryGroup.__webglVertexBuffer) {
                createMeshBuffers(geometryGroup);
                initMeshBuffers(geometryGroup, object);
                geometry.verticesNeedUpdate = true;
                geometry.morphTargetsNeedUpdate = true;
                geometry.elementsNeedUpdate = true;
                geometry.uvsNeedUpdate = true;
                geometry.normalsNeedUpdate = true;
                geometry.tangentsNeedUpdate = true;
                geometry.colorsNeedUpdate = true;
              }
            }
          } else {
            if (object instanceof THREE.Line) {
              if (!geometry.__webglVertexBuffer) {
                createLineBuffers(geometry);
                initLineBuffers(geometry, object);
                geometry.verticesNeedUpdate = true;
                geometry.colorsNeedUpdate = true;
                geometry.lineDistancesNeedUpdate = true;
              }
            }
          }
        }
      }
    }
    if (object.__webglActive === undefined) {
      if (object instanceof THREE.Mesh) {
        geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
          addBuffer(scene.__webglObjects, geometry, object);
        } else {
          if (geometry instanceof THREE.Geometry) {
            for (g in geometry.geometryGroups) {
              geometryGroup = geometry.geometryGroups[g];
              addBuffer(scene.__webglObjects, geometryGroup, object);
            }
          }
        }
      } else {
        if (object instanceof THREE.Line) {
          geometry = object.geometry;
          addBuffer(scene.__webglObjects, geometry, object);
        }
      }
      object.__webglActive = true;
    }
  }
  function addBuffer(objlist, buffer, object) {
    objlist.push({id:null, buffer:buffer, object:object, opaque:null, transparent:null, z:0});
  }
  function updateObject(object) {
    var geometry = object.geometry, geometryGroup, customAttributesDirty, material;
    if (geometry instanceof THREE.BufferGeometry) {
      setDirectBuffers(geometry, _gl.DYNAMIC_DRAW, geometry.freeCPUBuffers);
    } else {
      if (object instanceof THREE.Mesh) {
        for (var i = 0, il = geometry.geometryGroupsList.length;i < il;i++) {
          geometryGroup = geometry.geometryGroupsList[i];
          material = getBufferMaterial(object, geometryGroup);
          if (geometry.buffersNeedUpdate) {
            initMeshBuffers(geometryGroup, object);
          }
          customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || (geometry.morphTargetsNeedUpdate || (geometry.elementsNeedUpdate || (geometry.uvsNeedUpdate || (geometry.normalsNeedUpdate || (geometry.colorsNeedUpdate || (geometry.tangentsNeedUpdate || customAttributesDirty))))))) {
            setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, geometry.freeCPUBuffers, material);
          }
        }
        geometry.verticesNeedUpdate = false;
        geometry.morphTargetsNeedUpdate = false;
        geometry.elementsNeedUpdate = false;
        geometry.uvsNeedUpdate = false;
        geometry.normalsNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.tangentsNeedUpdate = false;
        geometry.buffersNeedUpdate = false;
        material.attributes && clearCustomAttributes(material);
      } else {
        if (object instanceof THREE.Line) {
          material = getBufferMaterial(object, geometry);
          customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || (geometry.colorsNeedUpdate || (geometry.lineDistancesNeedUpdate || customAttributesDirty))) {
            setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
          }
          geometry.verticesNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.lineDistancesNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        }
      }
    }
  }
  function areCustomAttributesDirty(material) {
    for (var a in material.attributes) {
      if (material.attributes[a].needsUpdate) {
        return true;
      }
    }
    return false;
  }
  function clearCustomAttributes(material) {
    for (var a in material.attributes) {
      material.attributes[a].needsUpdate = false;
    }
  }
  function removeObject(object, scene) {
    if (object instanceof THREE.Mesh || object instanceof THREE.Line) {
      removeInstances(scene.__webglObjects, object);
    }
    delete object.__webglActive;
  }
  function removeInstances(objlist, object) {
    for (var o = objlist.length - 1;o >= 0;o--) {
      if (objlist[o].object === object) {
        objlist.splice(o, 1);
      }
    }
  }
  function removeInstancesDirect(objlist, object) {
    for (var o = objlist.length - 1;o >= 0;o--) {
      if (objlist[o] === object) {
        objlist.splice(o, 1);
      }
    }
  }
  this.initMaterial = function(material, lights, fog, object) {
    material.addEventListener("dispose", onMaterialDispose);
    var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;
    if (material instanceof THREE.MeshDepthMaterial) {
      shaderID = "depth";
    } else {
      if (material instanceof THREE.MeshNormalMaterial) {
        console.log("MeshNormalMaterial is turned off.");
      } else {
        if (material instanceof THREE.MeshBasicMaterial) {
          shaderID = "basic";
        } else {
          if (material instanceof THREE.MeshLambertMaterial) {
            console.log("MeshLambertMaterial is turned off.");
          } else {
            if (material instanceof THREE.MeshPhongMaterial) {
              shaderID = "phong";
            } else {
              if (material instanceof THREE.LineBasicMaterial) {
                shaderID = "basic";
              } else {
                if (material instanceof THREE.LineDashedMaterial) {
                  shaderID = "dashed";
                }
              }
            }
          }
        }
      }
    }
    if (shaderID) {
      setMaterialShaders(material, THREE.ShaderLib[shaderID]);
    }
    maxLightCount = allocateLights(lights);
    maxShadows = allocateShadows(lights);
    maxBones = 0;
    parameters = {map:!!material.map, envMap:!!material.envMap, irradianceMap:!!material.irradianceMap, envIsSpherical:material.envMap && material.envMap.mapping instanceof THREE.SphericalReflectionMapping, envLogLuv:material.envMap && material.envMap.LogLuv, irrLogLuv:material.irradianceMap && material.irradianceMap.LogLuv, lightMap:!!material.lightMap, bumpMap:_glExtensionStandardDerivatives && !!material.bumpMap, normalMap:_glExtensionStandardDerivatives && !!material.normalMap, specularMap:!!material.specularMap, 
    vertexColors:material.vertexColors, fog:fog, useFog:material.fog, fogExp:fog instanceof THREE.FogExp2, sizeAttenuation:material.sizeAttenuation, maxDirLights:maxLightCount.directional, maxPointLights:maxLightCount.point, maxSpotLights:maxLightCount.spot, maxHemiLights:maxLightCount.hemi, maxShadows:maxShadows, shadowMapEnabled:this.shadowMapEnabled && object.receiveShadow, shadowMapType:this.shadowMapType, shadowMapDebug:this.shadowMapDebug, shadowMapCascade:this.shadowMapCascade, alphaTest:material.alphaTest, 
    metal:material.metal, clearcoat:material.clearcoat, wrapAround:material.wrapAround, doubleSided:material.side === THREE.DoubleSide, flipSided:material.side === THREE.BackSide, mrtNormals:_drawBuffersWorks && material.mrtNormals};
    material.program = buildProgram(shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName);
    var attributes = material.program.attributes;
    material.uniformsList = [];
    for (u in material.uniforms) {
      material.uniformsList.push([material.uniforms[u], u]);
    }
  };
  function setMaterialShaders(material, shaders) {
    material.uniforms = THREE.UniformsUtils.clone(shaders.uniforms);
    material.vertexShader = shaders.vertexShader;
    material.fragmentShader = shaders.fragmentShader;
  }
  function setProgram(camera, lights, fog, material, object) {
    _usedTextureUnits = 0;
    if (material.needsUpdate) {
      if (material.program) {
        deallocateMaterial(material);
      }
      _this.initMaterial(material, lights, fog, object);
      material.needsUpdate = false;
    }
    var refreshMaterial = false;
    var program = material.program, p_uniforms = program.uniforms, m_uniforms = material.uniforms;
    if (program !== _currentProgram) {
      _gl.useProgram(program);
      _currentProgram = program;
      refreshMaterial = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshMaterial || camera !== _currentCamera) {
      _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
      if (camera !== _currentCamera) {
        _currentCamera = camera;
      }
    }
    if (refreshMaterial) {
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material instanceof THREE.MeshPhongMaterial || (material instanceof THREE.MeshLambertMaterial || material.lights)) {
        if (_lightsNeedUpdate) {
          setupLights(program, lights);
          _lightsNeedUpdate = false;
        }
        refreshUniformsLights(m_uniforms, _lights);
      }
      if (material instanceof THREE.MeshBasicMaterial || (material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial)) {
        refreshUniformsCommon(m_uniforms, material);
      }
      if (material instanceof THREE.LineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
      } else {
        if (material instanceof THREE.LineDashedMaterial) {
          refreshUniformsLine(m_uniforms, material);
          refreshUniformsDash(m_uniforms, material);
        } else {
          if (material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
          } else {
            if (material instanceof THREE.MeshLambertMaterial) {
              refreshUniformsLambert(m_uniforms, material);
            } else {
              if (material instanceof THREE.MeshDepthMaterial) {
                m_uniforms.mNear.value = camera.near;
                m_uniforms.mFar.value = camera.far;
                m_uniforms.opacity.value = material.opacity;
              } else {
                if (material instanceof THREE.MeshNormalMaterial) {
                  m_uniforms.opacity.value = material.opacity;
                }
              }
            }
          }
        }
      }
      if (object.receiveShadow && !material._shadowPass) {
        refreshUniformsShadow(m_uniforms, lights);
      }
      loadUniformsGeneric(program, material.uniformsList);
      if (material instanceof THREE.ShaderMaterial || (material instanceof THREE.MeshPhongMaterial || material.envMap)) {
        if (p_uniforms.cameraPosition !== null) {
          _vector3.setFromMatrixPosition(camera.matrixWorld);
          _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
        }
      }
      if (material instanceof THREE.MeshPhongMaterial || (material instanceof THREE.MeshLambertMaterial || (material instanceof THREE.ShaderMaterial || material.skinning))) {
        if (p_uniforms.viewMatrix !== null) {
          _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
        }
        if (p_uniforms.viewMatrixInverse !== null) {
          _gl.uniformMatrix4fv(p_uniforms.viewMatrixInverse, false, _viewInverseEnv.elements);
        }
      }
    }
    loadUniformsMatrices(p_uniforms, object);
    if (p_uniforms.modelMatrix !== null) {
      _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
    }
    return program;
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (_this.gammaInput) {
      uniforms.diffuse.value.copyGammaToLinear(material.color);
    } else {
      uniforms.diffuse.value.copy(material.color);
    }
    uniforms.map.value = material.map;
    uniforms.lightMap.value = material.lightMap;
    uniforms.specularMap.value = material.specularMap;
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
    }
    var uvScaleMap;
    var uvScaleMapBump;
    if (material.map) {
      uvScaleMap = material.map;
    } else {
      if (material.specularMap) {
        uvScaleMap = material.specularMap;
      }
    }
    if (uvScaleMap !== undefined) {
      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;
      uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    if (material.normalMap) {
      uvScaleMapBump = material.normalMap;
    } else {
      if (material.bumpMap) {
        uvScaleMapBump = material.bumpMap;
      }
    }
    if (uvScaleMapBump !== undefined) {
      var offset = uvScaleMapBump.offset;
      var repeat = uvScaleMapBump.repeat;
      uniforms.offsetRepeatBump.value.set(offset.x, offset.y, repeat.x, repeat.y);
    }
    uniforms.envMap.value = material.envMap;
    if (uniforms.irradianceMap) {
      uniforms.irradianceMap.value = material.irradianceMap;
    }
    if (_this.gammaInput) {
      uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
    } else {
      uniforms.reflectivity.value = material.reflectivity;
    }
    uniforms.refractionRatio.value = material.refractionRatio;
    uniforms.combine.value = material.combine;
    uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog instanceof THREE.Fog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else {
      if (fog instanceof THREE.FogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.shininess.value = material.shininess;
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
      uniforms.specular.value.copyGammaToLinear(material.specular);
    } else {
      uniforms.ambient.value.copy(material.ambient);
      uniforms.emissive.value.copy(material.emissive);
      uniforms.specular.value.copy(material.specular);
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (_this.gammaInput) {
      uniforms.ambient.value.copyGammaToLinear(material.ambient);
      uniforms.emissive.value.copyGammaToLinear(material.emissive);
    } else {
      uniforms.ambient.value.copy(material.ambient);
      uniforms.emissive.value.copy(material.emissive);
    }
    if (material.wrapAround) {
      uniforms.wrapRGB.value.copy(material.wrapRGB);
    }
  }
  function refreshUniformsLights(uniforms, lights) {
    uniforms.ambientLightColor.value = lights.ambient;
    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;
    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;
  }
  function refreshUniformsShadow(uniforms, lights) {
    if (uniforms.shadowMatrix) {
      var j = 0;
      for (var i = 0, il = lights.length;i < il;i++) {
        var light = lights[i];
        if (!light.castShadow) {
          continue;
        }
        if (light instanceof THREE.SpotLight || light instanceof THREE.DirectionalLight && !light.shadowCascade) {
          uniforms.shadowMap.value[j] = light.shadowMap;
          uniforms.shadowMapSize.value[j] = light.shadowMapSize;
          uniforms.shadowMatrix.value[j] = light.shadowMatrix;
          uniforms.shadowDarkness.value[j] = light.shadowDarkness;
          uniforms.shadowBias.value[j] = light.shadowBias;
          j++;
        }
      }
    }
  }
  function loadUniformsMatrices(uniforms, object) {
    _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
    if (uniforms.normalMatrix) {
      _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
    }
  }
  function getTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= _maxTextures) {
      console.warn("WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  function loadUniformsGeneric(program, uniforms) {
    var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;
    for (j = 0, jl = uniforms.length;j < jl;j++) {
      location = program.uniforms[uniforms[j][1]];
      if (!location) {
        continue;
      }
      uniform = uniforms[j][0];
      type = uniform.type;
      value = uniform.value;
      if (type === "i") {
        _gl.uniform1i(location, value);
      } else {
        if (type === "f") {
          _gl.uniform1f(location, value);
        } else {
          if (type === "v2") {
            _gl.uniform2f(location, value.x, value.y);
          } else {
            if (type === "v3") {
              _gl.uniform3f(location, value.x, value.y, value.z);
            } else {
              if (type === "v4") {
                _gl.uniform4f(location, value.x, value.y, value.z, value.w);
              } else {
                if (type === "c") {
                  _gl.uniform3f(location, value.r, value.g, value.b);
                } else {
                  if (type === "iv1") {
                    _gl.uniform1iv(location, value);
                  } else {
                    if (type === "iv") {
                      _gl.uniform3iv(location, value);
                    } else {
                      if (type === "fv1") {
                        _gl.uniform1fv(location, value);
                      } else {
                        if (type === "fv") {
                          if (value.length) {
                            _gl.uniform3fv(location, value);
                          }
                        } else {
                          if (type === "v2v") {
                            if (uniform._array === undefined) {
                              uniform._array = new Float32Array(2 * value.length);
                            }
                            for (i = 0, il = value.length;i < il;i++) {
                              offset = i * 2;
                              uniform._array[offset] = value[i].x;
                              uniform._array[offset + 1] = value[i].y;
                            }
                            _gl.uniform2fv(location, uniform._array);
                          } else {
                            if (type === "v3v") {
                              if (uniform._array === undefined) {
                                uniform._array = new Float32Array(3 * value.length);
                              }
                              for (i = 0, il = value.length;i < il;i++) {
                                offset = i * 3;
                                uniform._array[offset] = value[i].x;
                                uniform._array[offset + 1] = value[i].y;
                                uniform._array[offset + 2] = value[i].z;
                              }
                              _gl.uniform3fv(location, uniform._array);
                            } else {
                              if (type === "v4v") {
                                if (uniform._array === undefined) {
                                  uniform._array = new Float32Array(4 * value.length);
                                }
                                for (i = 0, il = value.length;i < il;i++) {
                                  offset = i * 4;
                                  uniform._array[offset] = value[i].x;
                                  uniform._array[offset + 1] = value[i].y;
                                  uniform._array[offset + 2] = value[i].z;
                                  uniform._array[offset + 3] = value[i].w;
                                }
                                _gl.uniform4fv(location, uniform._array);
                              } else {
                                if (type === "m4") {
                                  if (uniform._array === undefined) {
                                    uniform._array = new Float32Array(16);
                                  }
                                  value.flattenToArray(uniform._array);
                                  _gl.uniformMatrix4fv(location, false, uniform._array);
                                } else {
                                  if (type === "m4v") {
                                    if (uniform._array === undefined) {
                                      uniform._array = new Float32Array(16 * value.length);
                                    }
                                    for (i = 0, il = value.length;i < il;i++) {
                                      value[i].flattenToArrayOffset(uniform._array, i * 16);
                                    }
                                    _gl.uniformMatrix4fv(location, false, uniform._array);
                                  } else {
                                    if (type === "t") {
                                      texture = value;
                                      textureUnit = getTextureUnit();
                                      _gl.uniform1i(location, textureUnit);
                                      if (!texture) {
                                        continue;
                                      }
                                      if (texture.image instanceof Array && texture.image.length === 6) {
                                        setCubeTexture(texture, textureUnit);
                                      } else {
                                        _this.setTexture(texture, textureUnit);
                                      }
                                    } else {
                                      if (type === "tv") {
                                        if (uniform._array === undefined) {
                                          uniform._array = [];
                                        }
                                        for (i = 0, il = uniform.value.length;i < il;i++) {
                                          uniform._array[i] = getTextureUnit();
                                        }
                                        _gl.uniform1iv(location, uniform._array);
                                        for (i = 0, il = uniform.value.length;i < il;i++) {
                                          texture = uniform.value[i];
                                          textureUnit = uniform._array[i];
                                          if (!texture) {
                                            continue;
                                          }
                                          _this.setTexture(texture, textureUnit);
                                        }
                                      } else {
                                        console.warn("THREE.WebGLRenderer: Unknown uniform type: " + type);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  function setupMatrices(object, camera) {
    object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
  }
  function setColorGamma(array, offset, color, intensitySq) {
    array[offset] = color.r * color.r * intensitySq;
    array[offset + 1] = color.g * color.g * intensitySq;
    array[offset + 2] = color.b * color.b * intensitySq;
  }
  function setColorLinear(array, offset, color, intensity) {
    array[offset] = color.r * intensity;
    array[offset + 1] = color.g * intensity;
    array[offset + 2] = color.b * intensity;
  }
  function setupLights(program, lights) {
    var l, ll, light, n, r = 0, g = 0, b = 0, color, skyColor, groundColor, intensity, intensitySq, position, distance, zlights = _lights, dirColors = zlights.directional.colors, dirPositions = zlights.directional.positions, pointColors = zlights.point.colors, pointPositions = zlights.point.positions, pointDistances = zlights.point.distances, spotColors = zlights.spot.colors, spotPositions = zlights.spot.positions, spotDistances = zlights.spot.distances, spotDirections = zlights.spot.directions, 
    spotAnglesCos = zlights.spot.anglesCos, spotExponents = zlights.spot.exponents, hemiSkyColors = zlights.hemi.skyColors, hemiGroundColors = zlights.hemi.groundColors, hemiPositions = zlights.hemi.positions, dirLength = 0, pointLength = 0, spotLength = 0, hemiLength = 0, dirCount = 0, pointCount = 0, spotCount = 0, hemiCount = 0, dirOffset = 0, pointOffset = 0, spotOffset = 0, hemiOffset = 0;
    for (l = 0, ll = lights.length;l < ll;l++) {
      light = lights[l];
      if (light.onlyShadow) {
        continue;
      }
      color = light.color;
      intensity = light.intensity;
      distance = light.distance;
      if (light instanceof THREE.AmbientLight) {
        if (!light.visible) {
          continue;
        }
        if (_this.gammaInput) {
          r += color.r * color.r;
          g += color.g * color.g;
          b += color.b * color.b;
        } else {
          r += color.r;
          g += color.g;
          b += color.b;
        }
      } else {
        if (light instanceof THREE.DirectionalLight) {
          dirCount += 1;
          if (!light.visible) {
            continue;
          }
          _direction.setFromMatrixPosition(light.matrixWorld);
          _vector3.setFromMatrixPosition(light.target.matrixWorld);
          _direction.sub(_vector3);
          _direction.normalize();
          if (_direction.x === 0 && (_direction.y === 0 && _direction.z === 0)) {
            continue;
          }
          dirOffset = dirLength * 3;
          dirPositions[dirOffset] = _direction.x;
          dirPositions[dirOffset + 1] = _direction.y;
          dirPositions[dirOffset + 2] = _direction.z;
          if (_this.gammaInput) {
            setColorGamma(dirColors, dirOffset, color, intensity * intensity);
          } else {
            setColorLinear(dirColors, dirOffset, color, intensity);
          }
          dirLength += 1;
        } else {
          if (light instanceof THREE.PointLight) {
            pointCount += 1;
            if (!light.visible) {
              continue;
            }
            pointOffset = pointLength * 3;
            if (_this.gammaInput) {
              setColorGamma(pointColors, pointOffset, color, intensity * intensity);
            } else {
              setColorLinear(pointColors, pointOffset, color, intensity);
            }
            _vector3.setFromMatrixPosition(light.matrixWorld);
            pointPositions[pointOffset] = _vector3.x;
            pointPositions[pointOffset + 1] = _vector3.y;
            pointPositions[pointOffset + 2] = _vector3.z;
            pointDistances[pointLength] = distance;
            pointLength += 1;
          } else {
            if (light instanceof THREE.SpotLight) {
              spotCount += 1;
              if (!light.visible) {
                continue;
              }
              spotOffset = spotLength * 3;
              if (_this.gammaInput) {
                setColorGamma(spotColors, spotOffset, color, intensity * intensity);
              } else {
                setColorLinear(spotColors, spotOffset, color, intensity);
              }
              _vector3.setFromMatrixPosition(light.matrixWorld);
              spotPositions[spotOffset] = _vector3.x;
              spotPositions[spotOffset + 1] = _vector3.y;
              spotPositions[spotOffset + 2] = _vector3.z;
              spotDistances[spotLength] = distance;
              _direction.copy(_vector3);
              _vector3.setFromMatrixPosition(light.target.matrixWorld);
              _direction.sub(_vector3);
              _direction.normalize();
              spotDirections[spotOffset] = _direction.x;
              spotDirections[spotOffset + 1] = _direction.y;
              spotDirections[spotOffset + 2] = _direction.z;
              spotAnglesCos[spotLength] = Math.cos(light.angle);
              spotExponents[spotLength] = light.exponent;
              spotLength += 1;
            } else {
              if (light instanceof THREE.HemisphereLight) {
                hemiCount += 1;
                if (!light.visible) {
                  continue;
                }
                _direction.setFromMatrixPosition(light.matrixWorld);
                _direction.normalize();
                if (_direction.x === 0 && (_direction.y === 0 && _direction.z === 0)) {
                  continue;
                }
                hemiOffset = hemiLength * 3;
                hemiPositions[hemiOffset] = _direction.x;
                hemiPositions[hemiOffset + 1] = _direction.y;
                hemiPositions[hemiOffset + 2] = _direction.z;
                skyColor = light.color;
                groundColor = light.groundColor;
                if (_this.gammaInput) {
                  intensitySq = intensity * intensity;
                  setColorGamma(hemiSkyColors, hemiOffset, skyColor, intensitySq);
                  setColorGamma(hemiGroundColors, hemiOffset, groundColor, intensitySq);
                } else {
                  setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
                  setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
                }
                hemiLength += 1;
              }
            }
          }
        }
      }
    }
    for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3);l < ll;l++) {
      dirColors[l] = 0;
    }
    for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3);l < ll;l++) {
      pointColors[l] = 0;
    }
    for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3);l < ll;l++) {
      spotColors[l] = 0;
    }
    for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3);l < ll;l++) {
      hemiSkyColors[l] = 0;
    }
    for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3);l < ll;l++) {
      hemiGroundColors[l] = 0;
    }
    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;
    zlights.ambient[0] = r;
    zlights.ambient[1] = g;
    zlights.ambient[2] = b;
  }
  this.setFaceCulling = function(cullFace, frontFaceDirection) {
    if (cullFace === THREE.CullFaceNone) {
      _gl.disable(_gl.CULL_FACE);
    } else {
      if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      if (cullFace === THREE.CullFaceBack) {
        _gl.cullFace(_gl.BACK);
      } else {
        if (cullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.FRONT);
        } else {
          _gl.cullFace(_gl.FRONT_AND_BACK);
        }
      }
      _gl.enable(_gl.CULL_FACE);
    }
  };
  this.setMaterialFaces = function(material) {
    var doubleSided = material.side === THREE.DoubleSide;
    var flipSided = material.side === THREE.BackSide;
    if (_oldDoubleSided !== doubleSided) {
      if (doubleSided) {
        _gl.disable(_gl.CULL_FACE);
      } else {
        _gl.enable(_gl.CULL_FACE);
      }
      _oldDoubleSided = doubleSided;
    }
    if (_oldFlipSided !== flipSided) {
      if (flipSided) {
        _gl.frontFace(_gl.CW);
      } else {
        _gl.frontFace(_gl.CCW);
      }
      _oldFlipSided = flipSided;
    }
  };
  this.setDepthTest = function(depthTest) {
    if (_oldDepthTest !== depthTest) {
      if (depthTest) {
        _gl.enable(_gl.DEPTH_TEST);
      } else {
        _gl.disable(_gl.DEPTH_TEST);
      }
      _oldDepthTest = depthTest;
    }
  };
  this.setDepthWrite = function(depthWrite) {
    if (_oldDepthWrite !== depthWrite) {
      _gl.depthMask(depthWrite);
      _oldDepthWrite = depthWrite;
    }
  };
  function setLineWidth(width) {
    if (width !== _oldLineWidth) {
      _gl.lineWidth(width);
      _oldLineWidth = width;
    }
  }
  function setPolygonOffset(polygonoffset, factor, units) {
    if (_oldPolygonOffset !== polygonoffset) {
      if (polygonoffset) {
        _gl.enable(_gl.POLYGON_OFFSET_FILL);
      } else {
        _gl.disable(_gl.POLYGON_OFFSET_FILL);
      }
      _oldPolygonOffset = polygonoffset;
    }
    if (polygonoffset && (_oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units)) {
      _gl.polygonOffset(factor, units);
      _oldPolygonOffsetFactor = factor;
      _oldPolygonOffsetUnits = units;
    }
  }
  this.setBlending = function(blending, blendEquation, blendSrc, blendDst) {
    if (blending !== _oldBlending) {
      if (blending === THREE.NoBlending) {
        _gl.disable(_gl.BLEND);
      } else {
        if (blending === THREE.AdditiveBlending) {
          _gl.enable(_gl.BLEND);
          _gl.blendEquation(_gl.FUNC_ADD);
          _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE);
        } else {
          if (blending === THREE.SubtractiveBlending) {
            _gl.enable(_gl.BLEND);
            _gl.blendEquation(_gl.FUNC_ADD);
            _gl.blendFunc(_gl.ZERO, _gl.ONE_MINUS_SRC_COLOR);
          } else {
            if (blending === THREE.MultiplyBlending) {
              _gl.enable(_gl.BLEND);
              _gl.blendEquation(_gl.FUNC_ADD);
              _gl.blendFunc(_gl.ZERO, _gl.SRC_COLOR);
            } else {
              if (blending === THREE.CustomBlending) {
                _gl.enable(_gl.BLEND);
              } else {
                _gl.enable(_gl.BLEND);
                _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
                _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
              }
            }
          }
        }
      }
      _oldBlending = blending;
    }
    if (blending === THREE.CustomBlending) {
      if (blendEquation !== _oldBlendEquation) {
        _gl.blendEquation(paramThreeToGL(blendEquation));
        _oldBlendEquation = blendEquation;
      }
      if (blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst) {
        _gl.blendFunc(paramThreeToGL(blendSrc), paramThreeToGL(blendDst));
        _oldBlendSrc = blendSrc;
        _oldBlendDst = blendDst;
      }
    } else {
      _oldBlendEquation = null;
      _oldBlendSrc = null;
      _oldBlendDst = null;
    }
  };
  function generateDefines(defines) {
    var value, chunk, chunks = [];
    for (var d in defines) {
      value = defines[d];
      if (value === false) {
        continue;
      }
      chunk = "#define " + d + " " + value;
      chunks.push(chunk);
    }
    return chunks.join("\n");
  }
  function buildProgram(shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName) {
    var p, pl, d, program, code;
    var chunks = [];
    if (shaderID) {
      chunks.push(shaderID);
    } else {
      chunks.push(fragmentShader);
      chunks.push(vertexShader);
    }
    for (d in defines) {
      chunks.push(d);
      chunks.push(defines[d]);
    }
    for (p in parameters) {
      chunks.push(p);
      chunks.push(parameters[p]);
    }
    code = chunks.join();
    for (p = 0, pl = _programs.length;p < pl;p++) {
      var programInfo = _programs[p];
      if (programInfo.code === code) {
        programInfo.usedTimes++;
        return programInfo.program;
      }
    }
    var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === THREE.PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else {
      if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
        shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
      }
    }
    var customDefines = generateDefines(defines);
    program = _gl.createProgram();
    var prefix_vertex = ["precision " + _precision + " float;", "precision " + _precision + " int;", customDefines, _supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", _this.gammaInput ? "#define GAMMA_INPUT" : "", _this.gammaOutput ? "#define GAMMA_OUTPUT" : "", parameters.mrtNormals ? "#define MRT_NORMALS" : "", "#define MAX_DIR_LIGHTS " + parameters.maxDirLights, "#define MAX_POINT_LIGHTS " + parameters.maxPointLights, "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights, "#define MAX_HEMI_LIGHTS " + 
    parameters.maxHemiLights, "#define MAX_SHADOWS " + parameters.maxShadows, "#define MAX_BONES " + parameters.maxBones, parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.vertexColors ? 
    "#define USE_COLOR" : "", parameters.wrapAround ? "#define WRAP_AROUND" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", 
    "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "attribute vec2 uv2;", "#ifdef USE_COLOR", "attribute vec3 color;", "#endif", ""].join("\n");
    var prefix_fragment = ["precision " + _precision + " float;", "precision " + _precision + " int;", parameters.bumpMap || parameters.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", customDefines, "#define MAX_DIR_LIGHTS " + parameters.maxDirLights, "#define MAX_POINT_LIGHTS " + parameters.maxPointLights, "#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights, "#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights, "#define MAX_SHADOWS " + parameters.maxShadows, parameters.alphaTest ? 
    "#define ALPHATEST " + parameters.alphaTest : "", parameters.mrtNormals ? "#define MRT_NORMALS" : "", _this.gammaInput ? "#define GAMMA_INPUT" : "", _this.gammaOutput ? "#define GAMMA_OUTPUT" : "", parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", parameters.envLogLuv ? 
    "#define ENV_LOGLUV" : "", parameters.irrLogLuv ? "#define IRR_LOGLUV" : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.metal ? "#define METAL" : "", parameters.clearcoat ? "#define CLEARCOAT" : "", parameters.wrapAround ? "#define WRAP_AROUND" : "", parameters.doubleSided ? 
    "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_ENVMAP", "uniform mat4 viewMatrixInverse;", "#endif", ""].join("\n");
    var glVertexShader = getShader("vertex", prefix_vertex + vertexShader);
    var glFragmentShader = getShader("fragment", prefix_fragment + fragmentShader);
    _gl.attachShader(program, glVertexShader);
    _gl.attachShader(program, glFragmentShader);
    if (index0AttributeName) {
      _gl.bindAttribLocation(program, 0, index0AttributeName);
    }
    _gl.linkProgram(program);
    if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
      console.error("Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter(program, _gl.VALIDATE_STATUS) + ", gl error [" + _gl.getError() + "]");
      console.error("Program Info Log: " + _gl.getProgramInfoLog(program));
    }
    _gl.deleteShader(glFragmentShader);
    _gl.deleteShader(glVertexShader);
    program.uniforms = {};
    program.attributes = {};
    var identifiers, u, a, i;
    identifiers = ["viewMatrix", "modelViewMatrix", "projectionMatrix", "normalMatrix", "modelMatrix", "cameraPosition", "viewMatrixInverse"];
    for (u in uniforms) {
      identifiers.push(u);
    }
    cacheUniformLocations(program, identifiers);
    identifiers = ["position", "normal", "uv", "uv2", "color", "lineDistance"];
    for (a in attributes) {
      identifiers.push(a);
    }
    cacheAttributeLocations(program, identifiers);
    program.id = _programs_counter++;
    _programs.push({program:program, code:code, usedTimes:1});
    _this.info.memory.programs = _programs.length;
    return program;
  }
  function cacheUniformLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length;i < l;i++) {
      id = identifiers[i];
      program.uniforms[id] = _gl.getUniformLocation(program, id);
    }
  }
  function cacheAttributeLocations(program, identifiers) {
    var i, l, id;
    for (i = 0, l = identifiers.length;i < l;i++) {
      id = identifiers[i];
      program.attributes[id] = _gl.getAttribLocation(program, id);
    }
  }
  function addLineNumbers(string) {
    var chunks = string.split("\n");
    for (var i = 0, il = chunks.length;i < il;i++) {
      chunks[i] = i + 1 + ": " + chunks[i];
    }
    return chunks.join("\n");
  }
  function getShader(type, string) {
    var shader;
    if (type === "fragment") {
      shader = _gl.createShader(_gl.FRAGMENT_SHADER);
    } else {
      if (type === "vertex") {
        shader = _gl.createShader(_gl.VERTEX_SHADER);
      }
    }
    _gl.shaderSource(shader, string);
    _gl.compileShader(shader);
    if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
      console.error(_gl.getShaderInfoLog(shader));
      console.error(addLineNumbers(string));
      return null;
    }
    return shader;
  }
  function isPowerOfTwo(value) {
    return(value & value - 1) === 0;
  }
  function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
    if (isImagePowerOfTwo) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
    }
    if (_glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType) {
      if (texture.anisotropy > 1 || texture.__oldAnisotropy) {
        _gl.texParameterf(textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _maxAnisotropy));
        texture.__oldAnisotropy = texture.anisotropy;
      }
    }
  }
  this.setTexture = function(texture, slot) {
    if (texture.needsUpdate) {
      if (!texture.__webglInit) {
        texture.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        texture.__webglTexture = _gl.createTexture();
        _this.info.memory.textures++;
      }
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      var image = texture.image, isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
      setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
      var mipmap, mipmaps = texture.mipmaps;
      if (texture instanceof THREE.DataTexture) {
        if (mipmaps.length > 0 && isImagePowerOfTwo) {
          for (var i = 0, il = mipmaps.length;i < il;i++) {
            mipmap = mipmaps[i];
            _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
        } else {
          _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
        }
      } else {
        if (texture instanceof THREE.CompressedTexture) {
          for (var i = 0, il = mipmaps.length;i < il;i++) {
            mipmap = mipmaps[i];
            if (texture.format !== THREE.RGBAFormat) {
              _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        } else {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0, il = mipmaps.length;i < il;i++) {
              mipmap = mipmaps[i];
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
          }
        }
      }
      if (texture.generateMipmaps && isImagePowerOfTwo) {
        _gl.generateMipmap(_gl.TEXTURE_2D);
      }
      texture.needsUpdate = false;
      if (texture.onUpdate) {
        texture.onUpdate();
      }
    } else {
      _gl.activeTexture(_gl.TEXTURE0 + slot);
      _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
    }
  };
  function clampToMaxSize(image, maxSize) {
    if (image.width <= maxSize && image.height <= maxSize) {
      return image;
    }
    var maxDimension = Math.max(image.width, image.height);
    var newWidth = Math.floor(image.width * maxSize / maxDimension);
    var newHeight = Math.floor(image.height * maxSize / maxDimension);
    var canvas = document.createElement("canvas");
    canvas.width = newWidth;
    canvas.height = newHeight;
    var ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
    return canvas;
  }
  function setCubeTexture(texture, slot) {
    if (texture.image.length === 6) {
      if (texture.needsUpdate) {
        if (!texture.image.__webglTextureCube) {
          texture.addEventListener("dispose", onTextureDispose);
          texture.image.__webglTextureCube = _gl.createTexture();
          _this.info.memory.textures++;
        }
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture instanceof THREE.CompressedTexture;
        var cubeImage = [];
        for (var i = 0;i < 6;i++) {
          if (_this.autoScaleCubemaps && !isCompressed) {
            cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
          } else {
            cubeImage[i] = texture.image[i];
          }
        }
        var image = cubeImage[0], isImagePowerOfTwo = isPowerOfTwo(image.width) && isPowerOfTwo(image.height), glFormat = paramThreeToGL(texture.format), glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo && glType != _gl.FLOAT);
        for (var i = 0;i < 6;i++) {
          if (!isCompressed) {
            if (cubeImage[i].data) {
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length;j < jl;j++) {
              mipmap = mipmaps[j];
              if (texture.format !== THREE.RGBAFormat) {
                _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo) {
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
        }
        texture.needsUpdate = false;
        if (texture.onUpdate) {
          texture.onUpdate();
        }
      } else {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
      }
    }
  }
  this.initFrameBufferMRT = function(renderTargets, verifyFrameBufferWorks) {
    var primaryTarget = renderTargets[0];
    var clearState = false;
    if (primaryTarget && !primaryTarget.__webglFramebuffer) {
      if (primaryTarget.depthBuffer === undefined) {
        primaryTarget.depthBuffer = true;
      }
      if (primaryTarget.stencilBuffer === undefined) {
        primaryTarget.stencilBuffer = true;
      }
      primaryTarget.__webglFramebuffer = _gl.createFramebuffer();
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer);
      var renderbuffer;
      if (primaryTarget.shareDepthFrom) {
        renderbuffer = primaryTarget.__webglRenderbuffer = primaryTarget.shareDepthFrom.__webglRenderbuffer;
      } else {
        if (primaryTarget.depthBuffer && !primaryTarget.stencilBuffer) {
          renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, primaryTarget.width, primaryTarget.height);
        } else {
          if (primaryTarget.depthBuffer && primaryTarget.stencilBuffer) {
            renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, primaryTarget.width, primaryTarget.height);
          } else {
          }
        }
      }
      if (primaryTarget.depthBuffer && !primaryTarget.stencilBuffer) {
        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
      } else {
        if (primaryTarget.depthBuffer && primaryTarget.stencilBuffer) {
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
        }
      }
      clearState = true;
    }
    var tmpBuf = _currentFramebuffer;
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer);
    for (var i = 0;i < renderTargets.length;i++) {
      var rt = renderTargets[i];
      if (!rt.__webglTexture) {
        var isTargetPowerOfTwo = isPowerOfTwo(rt.width) && isPowerOfTwo(rt.height), glFormat = paramThreeToGL(rt.format), glType = paramThreeToGL(rt.type);
        rt.addEventListener("dispose", onRenderTargetDispose);
        rt.__webglTexture = _gl.createTexture();
        _this.info.memory.textures++;
        _gl.bindTexture(_gl.TEXTURE_2D, rt.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, rt, isTargetPowerOfTwo);
        _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, rt.width, rt.height, 0, glFormat, glType, null);
        if (isTargetPowerOfTwo && rt.generateMipmaps) {
          _gl.generateMipmap(_gl.TEXTURE_2D);
        }
      }
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, rt.__webglTexture, 0);
    }
    if (_drawBuffersWorks && renderTargets.length > 1) {
      _glExtensionDrawBuffers.drawBuffersWEBGL([_glExtensionDrawBuffers.COLOR_ATTACHMENT0_WEBGL, _glExtensionDrawBuffers.COLOR_ATTACHMENT1_WEBGL]);
    }
    if (verifyFrameBufferWorks) {
      var status = _gl.checkFramebufferStatus(_gl.FRAMEBUFFER);
      if (status !== _gl.FRAMEBUFFER_COMPLETE) {
        console.log("Can't use multiple render targets. Falling back to two passes. " + status);
        delete primaryTarget.__webglFramebuffer;
        verifyFrameBufferWorks = false;
      }
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, tmpBuf);
    if (clearState) {
      _gl.bindTexture(_gl.TEXTURE_2D, null);
      _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    return verifyFrameBufferWorks;
  };
  this.setRenderTarget = function(renderTargets) {
    var renderTarget;
    if (Array.isArray(renderTargets)) {
      this.initFrameBufferMRT(renderTargets);
      renderTarget = renderTargets[0];
    } else {
      if (renderTargets) {
        this.initFrameBufferMRT([renderTargets]);
        renderTarget = renderTargets;
      }
    }
    var framebuffer, width, height, vx, vy;
    if (renderTarget) {
      framebuffer = renderTarget.__webglFramebuffer;
      width = renderTarget.width;
      height = renderTarget.height;
      vx = 0;
      vy = 0;
    } else {
      framebuffer = null;
      width = _viewportWidth;
      height = _viewportHeight;
      vx = _viewportX;
      vy = _viewportY;
    }
    if (framebuffer !== _currentFramebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _gl.viewport(vx, vy, width, height);
      _currentFramebuffer = framebuffer;
    }
    _currentWidth = width;
    _currentHeight = height;
  };
  this.readPixels = function(target, x, y, w, h, buf) {
    this.setRenderTarget(target);
    _gl.readPixels(x, y, w, h, _gl.RGBA, _gl.UNSIGNED_BYTE, buf);
  };
  this.verifyMRTWorks = function(renderTargets) {
    if (_glExtensionDrawBuffers) {
      _drawBuffersWorks = this.initFrameBufferMRT(renderTargets, true);
    }
    return _drawBuffersWorks;
  };
  function updateRenderTargetMipmap(renderTarget) {
    _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
    _gl.generateMipmap(_gl.TEXTURE_2D);
    _gl.bindTexture(_gl.TEXTURE_2D, null);
  }
  function filterFallback(f) {
    if (f === THREE.NearestFilter || (f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter)) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function paramThreeToGL(p) {
    if (p === THREE.RepeatWrapping) {
      return _gl.REPEAT;
    }
    if (p === THREE.ClampToEdgeWrapping) {
      return _gl.CLAMP_TO_EDGE;
    }
    if (p === THREE.MirroredRepeatWrapping) {
      return _gl.MIRRORED_REPEAT;
    }
    if (p === THREE.NearestFilter) {
      return _gl.NEAREST;
    }
    if (p === THREE.NearestMipMapNearestFilter) {
      return _gl.NEAREST_MIPMAP_NEAREST;
    }
    if (p === THREE.NearestMipMapLinearFilter) {
      return _gl.NEAREST_MIPMAP_LINEAR;
    }
    if (p === THREE.LinearFilter) {
      return _gl.LINEAR;
    }
    if (p === THREE.LinearMipMapNearestFilter) {
      return _gl.LINEAR_MIPMAP_NEAREST;
    }
    if (p === THREE.LinearMipMapLinearFilter) {
      return _gl.LINEAR_MIPMAP_LINEAR;
    }
    if (p === THREE.UnsignedByteType) {
      return _gl.UNSIGNED_BYTE;
    }
    if (p === THREE.UnsignedShort4444Type) {
      return _gl.UNSIGNED_SHORT_4_4_4_4;
    }
    if (p === THREE.UnsignedShort5551Type) {
      return _gl.UNSIGNED_SHORT_5_5_5_1;
    }
    if (p === THREE.UnsignedShort565Type) {
      return _gl.UNSIGNED_SHORT_5_6_5;
    }
    if (p === THREE.ByteType) {
      return _gl.BYTE;
    }
    if (p === THREE.ShortType) {
      return _gl.SHORT;
    }
    if (p === THREE.UnsignedShortType) {
      return _gl.UNSIGNED_SHORT;
    }
    if (p === THREE.IntType) {
      return _gl.INT;
    }
    if (p === THREE.UnsignedIntType) {
      return _gl.UNSIGNED_INT;
    }
    if (p === THREE.FloatType) {
      return _gl.FLOAT;
    }
    if (p === THREE.HalfFloatType) {
      return 36193;
    }
    if (p === THREE.AlphaFormat) {
      return _gl.ALPHA;
    }
    if (p === THREE.RGBFormat) {
      return _gl.RGB;
    }
    if (p === THREE.RGBAFormat) {
      return _gl.RGBA;
    }
    if (p === THREE.LuminanceFormat) {
      return _gl.LUMINANCE;
    }
    if (p === THREE.LuminanceAlphaFormat) {
      return _gl.LUMINANCE_ALPHA;
    }
    if (p === THREE.AddEquation) {
      return _gl.FUNC_ADD;
    }
    if (p === THREE.SubtractEquation) {
      return _gl.FUNC_SUBTRACT;
    }
    if (p === THREE.ReverseSubtractEquation) {
      return _gl.FUNC_REVERSE_SUBTRACT;
    }
    if (p === THREE.ZeroFactor) {
      return _gl.ZERO;
    }
    if (p === THREE.OneFactor) {
      return _gl.ONE;
    }
    if (p === THREE.SrcColorFactor) {
      return _gl.SRC_COLOR;
    }
    if (p === THREE.OneMinusSrcColorFactor) {
      return _gl.ONE_MINUS_SRC_COLOR;
    }
    if (p === THREE.SrcAlphaFactor) {
      return _gl.SRC_ALPHA;
    }
    if (p === THREE.OneMinusSrcAlphaFactor) {
      return _gl.ONE_MINUS_SRC_ALPHA;
    }
    if (p === THREE.DstAlphaFactor) {
      return _gl.DST_ALPHA;
    }
    if (p === THREE.OneMinusDstAlphaFactor) {
      return _gl.ONE_MINUS_DST_ALPHA;
    }
    if (p === THREE.DstColorFactor) {
      return _gl.DST_COLOR;
    }
    if (p === THREE.OneMinusDstColorFactor) {
      return _gl.ONE_MINUS_DST_COLOR;
    }
    if (p === THREE.SrcAlphaSaturateFactor) {
      return _gl.SRC_ALPHA_SATURATE;
    }
    if (_glExtensionCompressedTextureS3TC !== undefined) {
      if (p === THREE.RGB_S3TC_DXT1_Format) {
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
      }
      if (p === THREE.RGBA_S3TC_DXT1_Format) {
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      }
      if (p === THREE.RGBA_S3TC_DXT3_Format) {
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      }
      if (p === THREE.RGBA_S3TC_DXT5_Format) {
        return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }
    return 0;
  }
  function allocateLights(lights) {
    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;
    for (var l = 0, ll = lights.length;l < ll;l++) {
      var light = lights[l];
      if (light.onlyShadow) {
        continue;
      }
      if (light instanceof THREE.DirectionalLight) {
        dirLights++;
      }
      if (light instanceof THREE.PointLight) {
        pointLights++;
      }
      if (light instanceof THREE.SpotLight) {
        spotLights++;
      }
      if (light instanceof THREE.HemisphereLight) {
        hemiLights++;
      }
    }
    return{"directional":dirLights, "point":pointLights, "spot":spotLights, "hemi":hemiLights};
  }
  function allocateShadows(lights) {
    var maxShadows = 0;
    for (var l = 0, ll = lights.length;l < ll;l++) {
      var light = lights[l];
      if (!light.castShadow) {
        continue;
      }
      if (light instanceof THREE.SpotLight) {
        maxShadows++;
      }
      if (light instanceof THREE.DirectionalLight && !light.shadowCascade) {
        maxShadows++;
      }
    }
    return maxShadows;
  }
  function initGL() {
    try {
      var attributes = {alpha:_alpha, premultipliedAlpha:_premultipliedAlpha, antialias:_antialias, stencil:_stencil, preserveDrawingBuffer:_preserveDrawingBuffer};
      _gl = _canvas.getContext("webgl", attributes) || _canvas.getContext("experimental-webgl", attributes);
      if (_gl === null) {
        throw "Error creating WebGL context.";
      }
    } catch (error) {
      console.error(error);
    }
    _glExtensionTextureFloat = _gl.getExtension("OES_texture_float");
    _glExtensionTextureHalfFloat = _gl.getExtension("OES_texture_half_float");
    _glExtensionTextureFloatLinear = _gl.getExtension("OES_texture_float_linear");
    _glExtensionStandardDerivatives = _gl.getExtension("OES_standard_derivatives");
    _glExtensionDrawBuffers = _gl.getExtension("WEBGL_draw_buffers");
    _glExtensionElementIndexUint = _gl.getExtension("OES_element_index_uint");
    _drawBuffersWorks = !!_glExtensionDrawBuffers;
    _glExtensionTextureFilterAnisotropic = _gl.getExtension("EXT_texture_filter_anisotropic") || (_gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || _gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic"));
    _glExtensionCompressedTextureS3TC = _gl.getExtension("WEBGL_compressed_texture_s3tc") || (_gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || _gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"));
    if (!_glExtensionTextureFloat) {
      console.log("THREE.WebGLRenderer: Float textures not supported.");
    }
    if (!_glExtensionTextureHalfFloat) {
      console.log("THREE.WebGLRenderer: Half float textures not supported.");
    }
    if (!_glExtensionStandardDerivatives) {
      console.log("THREE.WebGLRenderer: Standard derivatives not supported.");
    }
    if (!_glExtensionTextureFilterAnisotropic) {
      console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");
    }
    if (!_glExtensionCompressedTextureS3TC) {
      console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");
    }
    if (!_glExtensionDrawBuffers) {
      console.log("THREE.WebGLRenderer: Multiple render targets not supported.");
    }
    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function() {
        return{"rangeMin":1, "rangeMax":1, "precision":1};
      };
    }
  }
  function setDefaultGLState() {
    _gl.clearColor(0, 0, 0, 1);
    _gl.clearDepth(1);
    _gl.clearStencil(0);
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthFunc(_gl.LEQUAL);
    _gl.frontFace(_gl.CCW);
    _gl.cullFace(_gl.BACK);
    _gl.enable(_gl.CULL_FACE);
    _gl.enable(_gl.BLEND);
    _gl.blendEquation(_gl.FUNC_ADD);
    _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
    _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
    _gl.clearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
  }
  this.shadowMapPlugin = new THREE.ShadowMapPlugin;
  this.addPrePlugin(this.shadowMapPlugin);
};
AutodeskNamespace("Autodesk.Viewing.Private");
if (ENABLE_DEBUG === undefined) {
  var ENABLE_DEBUG = true
}
if (ENABLE_TRACE === undefined) {
  var ENABLE_TRACE = true
}
var ENABLE_AUTOCAM = true;
var MAX_FRAME_TIME = 1E3 / 20;
var MIN_FRAME_TIME = 1E3 / 30;
Autodesk.Viewing.Private.Viewer3DImpl = function(thecanvas, theapi) {
  var bg = this.BackgroundPresets = {"Fusion Grey":[230, 230, 230, 150, 150, 150], "Sky Blue":[200, 233, 255, 100, 116, 127], "Midnight":[41, 76, 120, 1, 2, 3], "White":[255, 255, 255, 255, 255, 255], "Dark Grey":[51, 51, 51, 51, 51, 51], "Infinity Pool":[164, 175, 179, 164, 175, 179], "Tranquility":[0, 84, 166, 0, 84, 166], "Grey Room":[129, 129, 129, 129, 129, 129], "Photo Booth":[237, 237, 237, 237, 237, 237], "Custom":[230, 230, 230, 150, 150, 150]};
  this.DefaultLightPreset = 1;
  this.currentLightPreset = this.DefaultLightPreset;
  this.LightPresets = [{name:"Simple Grey", path:null, tonemap:0, E_bias:0, directLightColor:[1, 0.84, 0.67], ambientColor:[0.8, 0.9, 1], lightMultiplier:1, bgColorGradient:bg["Fusion Grey"], brighterFade:false}, {name:"Sharp Highlights", path:"studio_01", tonemap:1, E_bias:-9.5, directLightColor:[1, 1, 1], ambientColor:[0, 0, 0], lightMultiplier:0, bgColorGradient:bg["Photo Booth"], brighterFade:true}, {name:"Dark Sky", path:"DarkSky", tonemap:3, E_bias:-2, directLightColor:[1, 1, 1], ambientColor:[0, 
  0, 0], lightMultiplier:2.5, bgColorGradient:bg["Dark Grey"], brighterFade:false}, {name:"Grey Room", path:"GreyRoom", tonemap:3, E_bias:1, directLightColor:[1, 1, 1], ambientColor:[0, 0, 0], lightMultiplier:0, bgColorGradient:bg["Grey Room"], brighterFade:true}, {name:"Photo Booth", path:"PhotoBooth", tonemap:3, E_bias:0, directLightColor:[1, 1, 1], ambientColor:[0.125, 0.125, 0.125], lightMultiplier:1, bgColorGradient:bg["Photo Booth"], brighterFade:true}, {name:"Tranquility", path:"TranquilityBlue", 
  tonemap:3, E_bias:-2, directLightColor:[1, 1, 1], ambientColor:[0, 0, 0], lightMultiplier:4, bgColorGradient:bg["Tranquility"], brighterFade:false}, {name:"Infinity Pool", path:"InfinityPool", tonemap:3, E_bias:-1, directLightColor:[1, 0.84, 0.67], ambientColor:[0, 0, 0], lightMultiplier:2.5, bgColorGradient:bg["Infinity Pool"], brighterFade:false}, {name:"Simple White", path:null, tonemap:0, E_bias:0, directLightColor:[1, 1, 1], ambientColor:[0.9, 0.9, 0.9], lightMultiplier:1, bgColorGradient:bg["White"], 
  saoRadius:0.06, saoIntensity:0.15, brighterFade:true}, {name:"Riverbank", path:"riverbank", tonemap:3, E_bias:-5.7, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"Contrast", path:"IDViz", tonemap:3, E_bias:0, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Midnight"], brighterFade:false}];
  var DebugEnvironments = [{name:"Plaza", path:"Plaza", tonemap:3, E_bias:-12.5, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"Field", path:"field", tonemap:3, E_bias:-2.9, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"Crossroads", path:"crossroads", tonemap:3, E_bias:-5.5, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"Seaport", 
  path:"seaport", tonemap:3, E_bias:-6.5, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"Glacier", path:"glacier", tonemap:3, E_bias:0, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Midnight"], brighterFade:false}, {name:"Boardwalk", path:"boardwalk", tonemap:3, E_bias:-7, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Sky Blue"], brighterFade:false}, {name:"RaaS Test Env", path:"Reflection", tonemap:3, 
  E_bias:0, directLightColor:[1, 1, 1], lightMultiplier:0, bgColorGradient:bg["Grey Room"], brighterFade:false}];
  if (ENABLE_DEBUG) {
    this.LightPresets = this.LightPresets.concat(DebugEnvironments);
  }
  this.canvas = thecanvas;
  this.api = theapi;
  this.svfloader = new Autodesk.Viewing.Private.SvfLoader(this);
  var w = thecanvas.clientWidth;
  var h = thecanvas.clientHeight;
  this.postProcess = false;
  this.renderer = new RenderContext;
  this.renderer.init(thecanvas, w, h);
  this.RENDER_NORMAL = 0;
  this.RENDER_HIGHLIGHTED = 1;
  this.RENDER_HIDDEN = 2;
  this.RENDER_FINISHED = 3;
  this.phase = this.RENDER_NORMAL;
  var VIEW_ANGLE = 45, NEAR = 0.1, FAR = 1E4;
  this.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, w / h, NEAR, FAR);
  this.cameraChangedEvent = {type:Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera:this.camera};
  this.scene = new THREE.Scene;
  this.scene.add(this.camera);
  this.overlayScenes = {};
  this.projector = new THREE.Projector;
  this.selectionMaterialBase = new THREE.MeshPhongMaterial({color:6724095, specular:526344, emissive:3361911, ambient:0, opacity:1, transparent:false});
  this.selectionMaterialTop = new THREE.MeshPhongMaterial({color:6724095, specular:526344, emissive:3361911, ambient:0, opacity:0.15, transparent:true});
  this.createOverlayScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);
  this.materials = {};
  this.texturesToUpdate = [];
  this.modelQueue = null;
  this.fadeMaterial = new THREE.MeshPhongMaterial({color:16777215, opacity:0.1, reflectivity:0, transparent:true});
  this.addMaterial("__fadeMaterial__", this.fadeMaterial, true);
  this.highlightMaterial = new THREE.MeshPhongMaterial({color:6724095, specular:526344, emissive:3361911, ambient:0, opacity:1, transparent:false});
  this.addMaterial("__highlightMaterial__", this.highlightMaterial, true);
  this.needsRender = false;
  this.needsClear = false;
  this.needsResize = false;
  this.moveDelay = 0;
  this.progressiveRender = true;
  this.maxFrameTime = MAX_FRAME_TIME;
  this.minFrameTime = MIN_FRAME_TIME;
  this.targetFrameRate = 2E3 / (MIN_FRAME_TIME + MAX_FRAME_TIME);
  if (ENABLE_AUTOCAM) {
    this.controls = new ViewController(this, this.api);
  } else {
    this.controls = new THREE.TrackballControls(this.camera, this.canvas);
    this.controls.rotateSpeed = 1;
    this.controls.zoomSpeed = 1;
    this.controls.panSpeed = 0.5;
    this.controls.dynamicDampingFactor = 0.5;
    this.controls.owner = this;
  }
  this.selector = new Autodesk.Viewing.Private.Selector(this);
  this.controls.setSelector(this.selector);
  this.visibilityManager = new Autodesk.Viewing.Private.VisibilityManager(this);
  var scope = this;
  this.useEnvMap = false;
  this.worldUp = new THREE.Vector3(0, 1, 0);
  this.showGhosting = true;
  this.showOverlaysWhileMoving = true;
  this.skipAOWhenMoving = false;
  this.lastTickMoved = false;
  this.setClearColors(230, 230, 230, 150, 150, 150);
  this.renderer.beginScene(this.scene, this.camera, true);
  this.renderer.composeFinalFrame();
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.constructor = Autodesk.Viewing.Private.Viewer3DImpl;
Autodesk.Viewing.Private.Viewer3DImpl.prototype.run = function() {
  var scope = this;
  this.reqid = 0;
  (function animloop(highResTimeStamp) {
    scope.reqid = window.requestAnimationFrame(animloop);
    scope.tick(highResTimeStamp);
  })();
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.toggleProgressive = function(value) {
  this.progressiveRender = value;
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.toggleGhosting = function(value) {
  this.showGhosting = value;
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.toggleOverlaysWhileMoving = function(value) {
  this.showOverlaysWhileMoving = value;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.togglePostProcess = function(useSAO, useFXAA, useIDBuffer) {
  this.postProcessOptions = [useSAO, useFXAA, useIDBuffer];
  this.renderer.initPostPipeline(useSAO, useFXAA, useIDBuffer);
  this.fireRenderOptionChanged();
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setOptimizeNavigation = function(value) {
  this.skipAOWhenMoving = value;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.tick = function(highResTimeStamp) {
  var stats = this.stats;
  if (stats) {
    stats.begin();
  }
  if (this.needsResize) {
    this.controls.handleResize();
    this.camera.aspect = this.newWidth / this.newHeight;
    this.renderer.setSize(this.newWidth, this.newHeight);
    this.needsRender = true;
    this.needsClear = true;
    this.overlayDirty = true;
    this.needsResize = false;
  }
  while (this.texturesToUpdate.length) {
    var def = this.texturesToUpdate.pop();
    for (var j = 0;j < def.mats.length;j++) {
      def.mats[j][def.slot] = def.tex;
      def.mats[j].needsUpdate = true;
      this.needsClear = true;
    }
  }
  var moved = this.controls.update() || (this.cameraUpdated || this.camera.dirty);
  var clearAllBuffers = moved || this.needsClear;
  this.cameraUpdated = false;
  this.overlayDirty = this.overlayDirty || moved;
  var loadDone = this.model && this.model.isLoadDone();
  var isBeginFrame = clearAllBuffers || this.needsRender;
  var q = this.modelQueue;
  var frameBudget = this.progressiveRender ? 0.5 * (this.maxFrameTime + this.minFrameTime) : 1E10;
  var frameRemaining = frameBudget;
  if (isBeginFrame) {
    if (loadDone && this.model.getData().fragments.length) {
      this.signalProgress(0, null);
    }
    this.updateCameraMatrices();
    this.renderer.beginScene(this.scene, this.camera, clearAllBuffers);
    if (moved) {
      this.api.fireEvent(this.cameraChangedEvent);
    }
    if (this.needGhostedPass) {
      q.setOverrideMaterial(null);
    }
    if (q) {
      if (this.selector.getSelectionLength() > 0) {
        this.phase = this.RENDER_HIGHLIGHTED;
        q.reset(this.camera);
        q.drawHighlightedObjectsOnly();
        q.setOverrideMaterial(this.highlightMaterial);
      } else {
        this.phase = this.RENDER_NORMAL;
        q.reset(this.camera);
        q.drawNormalObjectsOnly();
        q.setOverrideMaterial(null);
      }
    }
  }
  if (q && !q.isDone()) {
    var _this = this;
    function cb(scene) {
      _this.renderer.renderScenePart(scene, _this.phase !== _this.RENDER_NORMAL);
    }
    frameRemaining = q.renderSome(cb, frameRemaining);
    if (q.isDone() && this.phase === this.RENDER_HIGHLIGHTED) {
      this.phase = this.RENDER_NORMAL;
      q.reset(this.camera);
      q.drawNormalObjectsOnly();
      q.setOverrideMaterial(null);
      frameRemaining = q.renderSome(cb, frameRemaining);
    }
    if (!moved && !this.overlayDirty) {
      this.renderer.composeFinalFrame();
    }
    if (q.isDone()) {
      if (this.phase === this.RENDER_NORMAL && (!q.areAllVisible() && this.showGhosting)) {
        this.phase = this.RENDER_HIDDEN;
        q.reset(this.camera);
        q.drawHiddenObjectsOnly();
        q.setOverrideMaterial(this.fadeMaterial);
      } else {
        this.phase = this.RENDER_FINISHED;
        this.renderer.composeFinalFrame(moved && this.skipAOWhenMoving);
      }
      if (loadDone) {
        this.signalProgress(100, null);
      }
    } else {
      if (loadDone) {
        this.signalProgress(100 * q.getRenderProgress(), null);
      }
    }
  }
  if (this.overlayDirty) {
    if (q && q.isDone() || this.showOverlaysWhileMoving) {
      var lightsOn = this.lightsOn;
      if (!lightsOn) {
        this.toggleLights(true, true);
      }
      if (this.dir_light1) {
        var oldIntensity = this.dir_light1.intensity;
        this.dir_light1.intensity = 1;
      }
      this.renderer.renderOverlays(this.overlayScenes);
      if (!lightsOn) {
        this.toggleLights(false, true);
      }
      if (this.dir_light1) {
        this.dir_light1.intensity = oldIntensity;
      }
      this.overlayDirty = false;
    } else {
      this.renderer.clearAllOverlays();
    }
    this.renderer.composeFinalFrame(moved && this.skipAOWhenMoving);
  }
  if (frameRemaining < frameBudget && stats) {
    stats.end();
  }
  if (this.lastTickMoved && (!moved && this.skipAOWhenMoving)) {
    this.renderer.composeFinalFrame();
  }
  this.lastTickMoved = moved;
  this.needsRender = false;
  this.needsClear = false;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.updateCameraMatrices = function() {
  var camera = this.camera;
  camera.updateMatrixWorld();
  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  if (this.model) {
    var worldBox = this.getVisibleBounds(true, true);
    var tmpBox = new THREE.Box3;
    worldBox.getTransformedBox(camera.matrixWorldInverse, tmpBox);
    var dMin = -tmpBox.max.z;
    var dMax = -tmpBox.min.z;
    dMin = Math.max(dMin, Math.min(1, Math.abs(dMax - dMin) * 1E-4));
    dMax = Math.max(dMax, dMin);
    camera.near = dMin;
    camera.far = dMax;
    camera.updateProjectionMatrix();
    if (this.model.is2d()) {
      var groundPt = this.intersectGroundViewport(0, 0);
      var distance;
      if (groundPt) {
        distance = camera.position.distanceTo(groundPt);
      } else {
        distance = camera.position.distanceTo(worldBox.center());
      }
      var pixelsPerUnit = this.renderer.settings.deviceHeight / (2 * distance * Math.tan(camera.fov * 0.5));
      this.materials["__lineMaterial__"].uniforms["unitsPerPixel"].value = 1 / pixelsPerUnit;
      this.materials["__lineMaterial__"].uniforms["pixelsPerUnit"].value = pixelsPerUnit;
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.initLights = function(dist) {
  var lightIntensity = this.LightPresets[this.currentLightPreset].lightMultiplier;
  this.lightNode = new THREE.Object3D;
  this.dir_light1 = new THREE.DirectionalLight((new THREE.Color).setRGB(1, 1, 1), lightIntensity);
  this.dir_light1.position.set(-1, 0, 1);
  this.dir_light1.position.multiplyScalar(dist * 1E3);
  this.lightNode.add(this.dir_light1);
  this.amb_light = new THREE.AmbientLight((new THREE.Color).setRGB(1, 1, 1));
  this.scene.add(this.amb_light);
  this.toggleLights(lightIntensity != 0);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.toggleLights = function(state, isForOverlay) {
  if (state && !this.lightsOn) {
    this.scene.add(this.amb_light);
    this.camera.add(this.lightNode);
    this.lightsOn = true;
  } else {
    if (!state && this.lightsOn) {
      if (this.amb_light) {
        this.scene.remove(this.amb_light);
      }
      if (this.lightNode) {
        this.camera.remove(this.lightNode);
      }
      this.lightsOn = false;
    }
  }
  var preset = this.LightPresets[this.currentLightPreset];
  if (this.lightsOn) {
    if (isForOverlay && this.amb_light) {
      this.amb_light.color.setRGB(preset.directLightColor[0] * 0.5, preset.directLightColor[1] * 0.5, preset.directLightColor[2] * 0.5);
    } else {
      if (preset.ambientColor && this.amb_light) {
        this.amb_light.color.setRGB(preset.ambientColor[0], preset.ambientColor[1], preset.ambientColor[2]);
      }
    }
    if (preset.directLightColor && this.dir_light1) {
      this.dir_light1.color.setRGB(preset.directLightColor[0], preset.directLightColor[1], preset.directLightColor[2]);
    }
  } else {
    if (preset.ambientColor && (this.amb_light && isForOverlay)) {
      this.amb_light.color.setRGB(preset.ambientColor[0], preset.ambientColor[1], preset.ambientColor[2]);
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.initCamera = function(model) {
  var upVectorArray = model.getUpVector();
  var upVector = upVectorArray ? (new THREE.Vector3).fromArray(upVectorArray) : null;
  var needsFit = false;
  var loadedCamera = model.getDefaultCamera();
  if (ENABLE_AUTOCAM && loadedCamera !== null) {
    var fov = loadedCamera.fov;
    if (!loadedCamera.isPerspective) {
      fov = 10;
      needsFit = true;
    }
    this.camera.isPerspective = true;
    this.camera.fov = fov;
    this.camera.position.copy(loadedCamera.position);
    this.camera.up.copy(loadedCamera.up);
    this.camera.target = (new THREE.Vector3).copy(loadedCamera.target);
    if (loadedCamera.inst && loadedCamera.inst.transform) {
      var transform = (new THREE.Matrix4).copy(loadedCamera.inst.transform);
      this.camera.position.applyMatrix4(transform);
      this.camera.target.applyMatrix4(transform);
      this.camera.up.transformDirection(transform);
    }
    if (upVector) {
      this.camera.up.copy(upVector);
    } else {
      this.camera.up = this.getNearestAxis(this.camera.up);
    }
  } else {
    var bbox = model.getBoundingBox();
    this.camera.target = bbox.center();
    var size = bbox.size();
    this.camera.position.copy(this.camera.target);
    this.camera.position.z += Math.max(size.x, Math.max(size.y, size.z));
    this.camera.isPerspective = true;
    if (upVector) {
      this.camera.up.copy(upVector);
    } else {
      if (model.is2d()) {
        this.camera.up.set(0, 0, 1);
        this.camera.target.y += 1E-6 * size.y;
      } else {
        this.camera.up.set(0, 1, 0);
      }
    }
  }
  this.api.navigation.setWorldUpVector(this.camera.up);
  this.api.navigation.setView(this.camera.position, this.camera.target);
  if (needsFit) {
    this.api.navigation.fitBounds(true, this.model.getBoundingBox());
  }
  this.syncCamera(true);
  this.controls.recordHomeView();
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.syncCamera = function(syncWorldUp) {
  this.camera.updateProjectionMatrix();
  if (syncWorldUp) {
    this.setWorldUp(this.api.navigation.getWorldUpVector());
  }
  if (ENABLE_AUTOCAM) {
    this.controls.syncCamera();
  } else {
    this.controls.resetScene(this.model.getBoundingBox());
  }
  this.cameraUpdated = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.getNearestAxis = function(v) {
  var newv = v.clone();
  if (newv.x < 0) {
    newv.x = -newv.x;
  }
  if (newv.y < 0) {
    newv.y = -newv.y;
  }
  if (newv.z < 0) {
    newv.z = -newv.z;
  }
  if (newv.x > newv.y && newv.x > newv.z) {
    newv.set(newv.x > 0 ? 1 : -1, 0, 0);
  } else {
    if (newv.y > newv.x && newv.y > newv.z) {
      newv.set(0, newv.y > 0 ? 1 : -1, 0);
    } else {
      newv.set(0, 0, newv.z > 0 ? 1 : -1);
    }
  }
  return newv;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setViewFromFile = function(model) {
  var camera = {};
  var isPerspectiveCamera = true;
  var upVectorArray = model.getUpVector();
  var upVector = upVectorArray ? (new THREE.Vector3).fromArray(upVectorArray) : null;
  var defaultCamera = model.getDefaultCamera();
  if (defaultCamera) {
    isPerspectiveCamera = defaultCamera.isPerspective;
    camera.isPerspective = true;
    camera.fov = isPerspectiveCamera ? defaultCamera.fov : 10;
    camera.position = (new THREE.Vector3).copy(defaultCamera.position);
    camera.target = (new THREE.Vector3).copy(defaultCamera.target);
    camera.up = (new THREE.Vector3).copy(defaultCamera.up);
    if (defaultCamera.inst && defaultCamera.inst.transform) {
      var transform = (new THREE.Matrix4).copy(defaultCamera.inst.transform);
      camera.position.applyMatrix4(transform);
      camera.target.applyMatrix4(transform);
      camera.up.transformDirection(transform);
    }
    camera.up = upVector ? upVector : this.getNearestAxis(camera.up);
  } else {
    camera.isPerspective = true;
    camera.fov = this.camera.fov;
    camera.target = model.getBoundingBox().center();
    camera.up = upVector ? upVector : this.camera.up.clone();
    camera.position = camera.target.clone();
    var size = model.getBoundingBox().size();
    camera.position.z += Math.max(size.x, size.y, size.z);
  }
  this.applyCamera(camera, !isPerspectiveCamera);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setViewFromArray = function(params) {
  var camera = {position:new THREE.Vector3(params[0], params[1], params[2]), target:new THREE.Vector3(params[3], params[4], params[5]), up:new THREE.Vector3(params[6], params[7], params[8]), aspect:params[9], fov:THREE.Math.radToDeg(params[10]), orthoHeight:params[11], isPerspective:!params[12]};
  var isPerspectiveCamera = camera.isPerspective;
  if (!isPerspectiveCamera) {
    camera.fov = 10;
  }
  var upVectorArray = this.model ? this.model.getUpVector() : null;
  var up = upVectorArray ? (new THREE.Vector3).fromArray(upVectorArray) : null;
  camera.up = up ? up : this.getNearestAxis(camera.up);
  this.applyCamera(camera, !isPerspectiveCamera);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setWorldUp = function(v) {
  this.worldUp.copy(v);
  var upAxis = 0;
  var maxVal = Math.abs(v.x);
  if (Math.abs(v.y) > maxVal) {
    upAxis = 1;
    maxVal = Math.abs(v.y);
  }
  if (Math.abs(v.z) > maxVal) {
    upAxis = 2;
  }
  this.camera.worldUpTransform = null;
  if (upAxis == 2) {
    var upMatrix = this.camera.worldUpTransform = new THREE.Matrix4;
    var e = upMatrix.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = -1;
    e[8] = 0;
    e[9] = 1;
    e[10] = 0;
  } else {
    if (upAxis == 0) {
      var upMatrix = this.camera.worldUpTransform = new THREE.Matrix4;
      var e = upMatrix.elements;
      e[0] = 0;
      e[1] = 1;
      e[2] = 0;
      e[4] = -1;
      e[5] = 0;
      e[6] = 0;
      e[8] = 0;
      e[9] = 0;
      e[10] = 1;
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.applyCamera = function(camera, fit) {
  if (fit) {
    var fitResult = this.controls.computeFit(camera.position, camera.target, camera.fov);
    this.controls.transitionView(fitResult.position, fitResult.target, camera.fov, camera.up);
  } else {
    this.controls.transitionView(camera.position, camera.target, camera.fov, camera.up);
  }
  this.cameraUpdated = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setModel = function(model) {
  if (model) {
    this.model = model;
    this.selector.model = this.model;
    this.visibilityManager.model = this.model;
    this.model.setLoader(this.svfloader);
    this.initScene();
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.initScene = function() {
  if (!this.model) {
    return;
  }
  if (this.model.is2d()) {
    this.initLayerTexture(this.model);
    this.enter2DMode();
  }
  this.modelQueue = new RenderQueue(this.model.getData().fragments.length, this.scene, this.model.getBoundingBox());
  this.initCamera(this.model);
  var bbox = this.model.getBoundingBox();
  var radius = 0.5 * bbox.size().length();
  this.initLights(radius);
  this.setLightPreset(this.currentLightPreset);
  this.needsClear = true;
  this.needsRender = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.initLayerTexture = function(model) {
  var layersList = model.getLayersList();
  var tw = 256;
  var th = 0 | Math.ceil(layersList.length / 256);
  var layerMask = new Uint8Array(4 * tw * th);
  for (var l = 0, lEnd = layersList.length;l < lEnd;l++) {
    layerMask[4 * l] = 255;
    layerMask[4 * l + 1] = 255;
    layerMask[4 * l + 2] = 255;
    layerMask[4 * l + 3] = 255;
  }
  var layerMaskTex = new THREE.DataTexture(layerMask, tw, th, THREE.RGBAFormat, THREE.UnsignedByteType, new THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter, 0);
  layerMaskTex.generateMipmaps = false;
  layerMaskTex.flipY = false;
  layerMaskTex.needsUpdate = true;
  this.layerMaskTex = layerMaskTex;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.create2DMaterial = function(material) {
  var hash = "__lineMaterial__";
  if (material.image) {
    hash += "|image:" + material.image.name;
  }
  if (material.clip) {
    hash += "|clip:" + JSON.stringify(material.clip);
  }
  if (!this.materials.hasOwnProperty(hash)) {
    var lineMaterial = new THREE.ShaderMaterial({fragmentShader:LineShader.fragmentShader, vertexShader:LineShader.vertexShader, uniforms:THREE.UniformsUtils.clone(LineShader.uniforms), attributes:LineShader.attributes, defines:LineShader.defines, transparent:true});
    lineMaterial.depthWrite = false;
    lineMaterial.depthTest = false;
    lineMaterial.blending = THREE.NormalBlending;
    lineMaterial.side = THREE.DoubleSide;
    lineMaterial.uniforms["tLayerMask"].value = this.layerMaskTex;
    if (material.image) {
      var texture;
      if (material.image.dataURI) {
        var img = new Image;
        img.src = material.image.dataURI;
        texture = new THREE.Texture(img, new THREE.UVMapping);
        texture.name = material.image.name;
        if (material.image.isPng) {
          lineMaterial.transparent = true;
        }
      } else {
        if (material.image.bits) {
          texture = new THREE.DataTexture(material.image.bits, material.image.width, material.image.height, THREE.RGBAFormat);
        }
      }
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.anisotropy = 1;
      texture.flipY = true;
      texture.needsUpdate = true;
      lineMaterial.uniforms["tRaster"].value = texture;
    }
    this.materials[hash] = lineMaterial;
  }
  return hash;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.addMaterial = function(name, mat, skipHeuristics) {
  function luminance(c) {
    return 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;
  }
  var svf = this.svfloader.svf;
  if (!skipHeuristics) {
    var proteinMaterials = svf ? svf.proteinMaterials : null;
    if (mat.metal) {
      if (!mat.reflectivity) {
        mat.reflectivity = luminance(mat.specular);
      }
      if (proteinMaterials) {
        if (mat.reflectivity === 1) {
          mat.reflectivity = luminance(mat.specular);
        }
        if (mat.color.r === 0 && (mat.color.g === 0 && mat.color.b === 0)) {
          mat.color.r = mat.specular.r * 0.1;
          mat.color.g = mat.specular.g * 0.1;
          mat.color.b = mat.specular.b * 0.1;
        } else {
          mat.color.r *= 0.1;
          mat.color.g *= 0.1;
          mat.color.b *= 0.1;
        }
      }
    } else {
      if (!proteinMaterials && mat.reflectivity) {
        mat.metal = true;
        mat.specular.r = mat.color.r * mat.reflectivity;
        mat.specular.g = mat.color.g * mat.reflectivity;
        mat.specular.b = mat.color.b * mat.reflectivity;
        mat.color.r *= 0.1;
        mat.color.g *= 0.1;
        mat.color.b *= 0.1;
      } else {
        if (mat.color.r === 1 && (mat.color.g === 1 && (mat.color.b === 1 && (mat.specular.r === 1 && (mat.specular.g === 1 && (mat.specular.b === 1 && (!mat.uri_map && !mat.uri_specularMap))))))) {
          mat.metal = true;
          mat.reflectivity = 0.7;
          mat.specular.r = mat.specular.g = mat.specular.b = mat.reflectivity;
          mat.color.r *= 0.1;
          mat.color.g *= 0.1;
          mat.color.b *= 0.1;
        } else {
          if (!mat.reflectivity) {
            mat.reflectivity = 0.01 + 0.06 * luminance(mat.specular);
          }
          mat.specular.r *= mat.reflectivity;
          mat.specular.g *= mat.reflectivity;
          mat.specular.b *= mat.reflectivity;
        }
      }
    }
    mat.ambient.copy(mat.color);
    mat.ambient.r *= 0.3;
    mat.ambient.g *= 0.3;
    mat.ambient.b *= 0.3;
    mat.combine = THREE.MixOperation;
    if (mat.transparent || (mat.uri_map && mat.uri_map.toLowerCase().indexOf(".png") != -1 || mat.uri_opacityMap)) {
      mat.alphaTest = 0.01;
    }
  }
  if (mat.uri_normalMap) {
    var scale = mat.bumpScale;
    if (scale === undefined || scale >= 1) {
      scale = 1;
    }
    mat.normalScale = new THREE.Vector2(scale, scale);
  } else {
    if (mat.bumpScale === undefined && (mat.uri_map || mat.uri_bumpMap)) {
      mat.bumpScale = 0.03;
    } else {
      if (mat.bumpScale > 1) {
        mat.bumpScale = 0.03;
      }
    }
  }
  if (proteinMaterials && proteinMaterials.materials) {
    var protMat = proteinMaterials.materials[name];
    if (protMat) {
      var matDef = protMat["materials"][protMat["userassets"][0]];
      if (matDef.categories && matDef.categories.indexOf("Paint") != -1) {
        mat.clearcoat = true;
      }
    }
  }
  if (this.reflectionCube) {
    mat.envMap = this.reflectionCube;
  }
  if (this.irradianceMap) {
    mat.irradianceMap = this.irradianceMap;
  }
  mat.mrtNormals = this.renderer.hasMRT() && this.renderer.settings.sao;
  if (mat.side == THREE.DoubleSide) {
    this.renderer.toggleTwoSided(true);
  }
  this.materials[name] = mat;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.addTexture = function(def) {
  this.texturesToUpdate.push(def);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.addMeshInstance = function(threegeom, fragId, materialId, matrix) {
  var svf = this.model.getData();
  if (fragId === 0 && svf.basePath.indexOf("SaRang") != -1) {
    return;
  }
  var m;
  if (threegeom.isLines) {
    var vertexColors = !!threegeom.attributes.color;
    var material = new THREE.LineBasicMaterial({vertexColors:vertexColors, polygonOffset:true, polygonOffsetFactor:2, polygonOffsetUnits:1});
    if (!vertexColors) {
      material.color = this.materials[materialId].color;
    }
    m = new THREE.Mesh(threegeom, material, true);
    m.isLine = true;
  } else {
    var material = this.materials[materialId];
    if (!material) {
      stderr("Unknown material " + materialId);
      for (var p in this.materials) {
        material = this.materials[p];
        break;
      }
    }
    if (threegeom.attributes.color) {
      material.vertexColors = THREE.VertexColors;
      material.needsUpdate = true;
    }
    if (threegeom.attributes.uv && threegeom.attributes.uv.isPattern) {
      if (material.map && !material.bumpMap) {
        material.bumpMap = material.map;
        material.needsUpdate = true;
      }
      if (material.uri_map && !material.uri_bumpMap) {
        material.uri_bumpMap = material.uri_map;
        material.needsUpdate = true;
      }
    }
    m = new THREE.Mesh(threegeom, material, true);
  }
  if (matrix) {
    if (m.matrix) {
      m.matrix.copy(matrix);
    } else {
      m.matrixWorld.copy(matrix);
    }
  }
  m.matrixAutoUpdate = false;
  this.modelQueue.addMesh(fragId, m);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.signalProgress = function(percent, message) {
  this.api.fireEvent({type:Autodesk.Viewing.PROGRESS_UPDATE_EVENT, percent:percent, message:message});
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.resize = function(w, h) {
  this.needsResize = true;
  this.newWidth = w;
  this.newHeight = h;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.enter2DMode = function() {
  var zUp = new THREE.Vector3(0, 0, 1);
  this.api.navigation.setWorldUpVector(zUp);
  this.syncCamera(true);
  this.controls.set2DMode(true);
  this.setLightPreset(0);
  this.togglePostProcess(false, false, true);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.loadSvf = function(path, ids, propertyDbPath, onSuccess, onError) {
  return this.svfloader.loadSvf(path, ids, propertyDbPath, onSuccess, onError);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.createOverlayScene = function(name, materialPre, materialPost, cam) {
  if (materialPre) {
    materialPre.depthWrite = false;
    materialPre.depthTest = true;
  }
  if (materialPost) {
    materialPost.depthWrite = false;
    materialPost.depthTest = false;
  }
  var s = new THREE.Scene(true);
  s.__lights = this.scene.__lights;
  this.overlayScenes[name] = {scene:s, camera:cam, materialPre:materialPre, materialPost:materialPost};
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.addOverlay = function(overlayName, mesh) {
  this.overlayScenes[overlayName].scene.add(mesh);
  this.overlayDirty = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.removeOverlay = function(overlayName, mesh) {
  this.overlayScenes[overlayName].scene.remove(mesh);
  this.overlayDirty = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.clearOverlay = function(overlayName) {
  this.overlayScenes[overlayName].scene.clear();
  this.overlayDirty = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setClearColors = function(r, g, b, r2, g2, b2) {
  this.clearColorTop = new THREE.Vector4(r / 255, g / 255, b / 255, 1);
  this.clearColorBottom = new THREE.Vector4(r2 / 255, g2 / 255, b2 / 255, 1);
  if (!this.reflectionCube || this.reflectionCube.isBgColor) {
    this.setCubeMapFromColors(this.clearColorTop, this.clearColorBottom);
  }
  this.renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
  this.needsClear = true;
  this.fireRenderOptionChanged();
};
THREE.Object3D.prototype.traverse = function(callback) {
  callback(this);
  if (this.children) {
    for (var i = 0, l = this.children.length;i < l;i++) {
      this.children[i].traverse(callback);
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.getOverlayBounds = function() {
  var bounds = new THREE.Box3;
  var overlays = this.overlayScenes;
  for (var key in overlays) {
    if (!overlays.hasOwnProperty(key)) {
      continue;
    }
    var box = new THREE.Box3;
    box.setFromObject(overlays[key].scene);
    bounds.union(box);
  }
  return bounds;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.getVisibleBounds = function(includeGhosted, includeOverlays) {
  var result = null;
  if (this.modelQueue) {
    result = this.modelQueue.getVisibleBounds(includeGhosted);
    if (includeOverlays) {
      result = this.getOverlayBounds().union(result);
    }
  }
  return result;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.getRenderProxy = function(model, fragId) {
  return this.modelQueue.getVizmesh(fragId);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setFragmentVisibility = function(model, fragId, value) {
  this.modelQueue.setVisibility(fragId, value);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setModelVisibility = function(model, value) {
  this.modelQueue.setAllVisibility(value);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.isWholeModelVisible = function(model) {
  return this.modelQueue.areAllVisible();
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.resetIsolation = function(model) {
  this.modelQueue.setOverrideMaterial(null);
  this.needGhostedPass = false;
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.highlightFragment = function(model, fragId, value) {
  this.modelQueue.setHightlighted(fragId, value);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.explode = function(scale) {
  var _this = this;
  var model = this.model;
  var svf = model.getData();
  var mc = this.getVisibleBounds(true).center();
  var frags = svf.fragments;
  var transforms = frags.transforms;
  var scaledExplodeDepth = scale * (svf.maxTreeDepth - 1) + 1;
  var explodeDepth = 0 | scaledExplodeDepth;
  var currentSegmentFraction = scaledExplodeDepth - explodeDepth;
  scale *= 2;
  if (svf.instanceTree && (svf.instanceBoxes && scale != 0)) {
    var nodeBoxes = svf.instanceBoxes;
    (function explodeRec(node, depth, cx, cy, cz, ox, oy, oz) {
      var oscale = scale * 2;
      if (depth == explodeDepth) {
        oscale *= currentSegmentFraction;
      }
      var box_offset = node.dbId * 6;
      var mycx = 0.5 * (nodeBoxes[box_offset] + nodeBoxes[box_offset + 3]);
      var mycy = 0.5 * (nodeBoxes[box_offset + 1] + nodeBoxes[box_offset + 4]);
      var mycz = 0.5 * (nodeBoxes[box_offset + 2] + nodeBoxes[box_offset + 5]);
      if (depth > 0 && depth <= explodeDepth) {
        var dx = (mycx - cx) * oscale;
        var dy = (mycy - cy) * oscale;
        var dz = (mycz - cz) * oscale;
        ox += dx;
        oy += dy;
        oz += dz;
      }
      var children = node.children;
      if (children) {
        for (var i = 0, iEnd = children.length;i < iEnd;i++) {
          explodeRec(children[i], depth + 1, mycx, mycy, mycz, ox, oy, oz);
        }
      }
      var fragIds = node.fragIds;
      if (fragIds !== undefined) {
        if (!Array.isArray(fragIds)) {
          var frag = fragIds | 0;
          var mtx = _this.getRenderProxy(model, frag).matrixWorld.elements;
          var mtx_offset = frag * 16;
          mtx[12] = transforms[mtx_offset + 12] + ox;
          mtx[13] = transforms[mtx_offset + 13] + oy;
          mtx[14] = transforms[mtx_offset + 14] + oz;
        } else {
          for (var j = 0;j < fragIds.length;j++) {
            var frag = 0 | fragIds[j];
            var mtx_offset = frag * 16;
            var mtx = _this.getRenderProxy(model, frag).matrixWorld.elements;
            mtx[12] = transforms[mtx_offset + 12] + ox;
            mtx[13] = transforms[mtx_offset + 13] + oy;
            mtx[14] = transforms[mtx_offset + 14] + oz;
          }
        }
      }
    })(svf.instanceTree, 0, mc.x, mc.y, mc.x, 0, 0, 0);
  } else {
    var boxes = frags.boxes;
    for (var i = 0, iEnd = frags.length;i < iEnd;i++) {
      var box_offset = i * 6;
      var mtx_offset = i * 16;
      var cx = 0.5 * (boxes[box_offset] + boxes[box_offset + 3]);
      var cy = 0.5 * (boxes[box_offset + 1] + boxes[box_offset + 4]);
      var cz = 0.5 * (boxes[box_offset + 2] + boxes[box_offset + 5]);
      cx = scale * (cx - mc.x);
      cy = scale * (cy - mc.y);
      cz = scale * (cz - mc.z);
      var mtx = _this.getRenderProxy(model, i).matrixWorld.elements;
      mtx[12] = transforms[mtx_offset + 12] + cx;
      mtx[13] = transforms[mtx_offset + 13] + cy;
      mtx[14] = transforms[mtx_offset + 14] + cz;
    }
  }
  this.modelQueue.visibleBoundsDirty = true;
  this.needsClear = true;
  this.overlayDirty = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setCubeMapFromColors = function(ctop, cbot) {
  var r1 = ctop.x * 255, g1 = ctop.y * 255, b1 = ctop.z * 255, r2 = cbot.x * 255, g2 = cbot.y * 255, b2 = cbot.z * 255;
  var pixelsTop = new Uint8Array(16);
  var pixelsBot = new Uint8Array(16);
  var pixelsSide = new Uint8Array(16);
  for (var i = 0;i < 4;i++) {
    pixelsTop[i * 4] = r1;
    pixelsTop[i * 4 + 1] = g1;
    pixelsTop[i * 4 + 2] = b1;
    pixelsTop[i * 4 + 3] = 255;
    pixelsBot[i * 4] = r2;
    pixelsBot[i * 4 + 1] = g2;
    pixelsBot[i * 4 + 2] = b2;
    pixelsBot[i * 4 + 3] = 255;
    if (0 | i / 2) {
      pixelsSide[i * 4] = r1;
      pixelsSide[i * 4 + 1] = g1;
      pixelsSide[i * 4 + 2] = b1;
      pixelsSide[i * 4 + 3] = 255;
    } else {
      pixelsSide[i * 4] = r2;
      pixelsSide[i * 4 + 1] = g2;
      pixelsSide[i * 4 + 2] = b2;
      pixelsSide[i * 4 + 3] = 255;
    }
  }
  var x_neg = new THREE.DataTexture(pixelsSide, 2, 2, THREE.RGBAFormat);
  var x_pos = new THREE.DataTexture(pixelsSide, 2, 2, THREE.RGBAFormat);
  var y_neg = new THREE.DataTexture(pixelsBot, 2, 2, THREE.RGBAFormat);
  var y_pos = new THREE.DataTexture(pixelsTop, 2, 2, THREE.RGBAFormat);
  var z_neg = new THREE.DataTexture(pixelsSide, 2, 2, THREE.RGBAFormat);
  var z_pos = new THREE.DataTexture(pixelsSide, 2, 2, THREE.RGBAFormat);
  var texture = new THREE.Texture(null, new THREE.CubeReflectionMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBAFormat);
  texture.image = [x_pos.image, x_neg.image, y_pos.image, y_neg.image, z_pos.image, z_neg.image];
  texture.needsUpdate = true;
  this.reflectionCube = texture;
  this.reflectionCube.isBgColor = true;
  for (var p in this.materials) {
    var m = this.materials[p];
    m.envMap = texture;
    m.needsUpdate = true;
  }
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setCubeMap = function(path) {
  var scope = this;
  var texLoadDone = function(map) {
    var svf = scope.model ? scope.model.getData() : null;
    scope.reflectionCube = map === undefined && svf ? svf.envMap : map;
    if (scope.reflectionCube) {
      for (var p in scope.materials) {
        var m = scope.materials[p];
        m.envMap = scope.reflectionCube;
        m.needsUpdate = true;
      }
    } else {
      scope.setCubeMapFromColors(scope.clearColorTop, scope.clearColorBottom);
    }
    scope.needsClear = true;
  };
  if (Array.isArray(path)) {
    this.reflectionCube = THREE.ImageUtils.loadTextureCube(path, new THREE.CubeReflectionMapping, texLoadDone);
    this.reflectionCube.format = THREE.RGBFormat;
  } else {
    if (typeof path == "string") {
      if (path.toLowerCase().indexOf(".dds") != -1) {
        this.reflectionCube = THREE.ImageUtils.loadCompressedTextureCube(path, new THREE.CubeReflectionMapping, texLoadDone);
        this.reflectionCube.LogLuv = path.indexOf("logluv") != -1;
      } else {
        this.reflectionCube = THREE.ImageUtils.loadTexture(path, new THREE.SphericalReflectionMapping, texLoadDone);
        this.reflectionCube.format = THREE.RGBFormat;
      }
    } else {
      if (path) {
        texLoadDone(path);
      } else {
        texLoadDone(null);
      }
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setIrradianceMap = function(path) {
  var scope = this;
  var texLoadDone = function(map) {
    if (map) {
      for (var p in scope.materials) {
        var m = scope.materials[p];
        m.irradianceMap = map;
        m.needsUpdate = true;
      }
      scope.irradianceMap = map;
    } else {
      if (scope.irradianceMap) {
        for (var p in scope.materials) {
          var m = scope.materials[p];
          m.irradianceMap = null;
          m.needsUpdate = true;
        }
        scope.irradianceMap = null;
      }
    }
    scope.needsClear = true;
  };
  THREE.ImageUtils.crossOrigin = "";
  if (Array.isArray(path)) {
    this.irradianceMap = THREE.ImageUtils.loadTextureCube(path, new THREE.CubeReflectionMapping, texLoadDone);
    this.irradianceMap.format = THREE.RGBFormat;
  } else {
    if (typeof path == "string") {
      if (path.toLowerCase().indexOf(".dds") != -1) {
        this.irradianceMap = THREE.ImageUtils.loadCompressedTextureCube(path, new THREE.CubeReflectionMapping, texLoadDone);
        this.irradianceMap.LogLuv = path.indexOf("logluv") != -1;
      }
    } else {
      if (path) {
        texLoadDone(path);
      } else {
        texLoadDone(null);
      }
    }
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setGhostingBrightness = function(brighterFade) {
  if (brighterFade) {
    this.fadeMaterial.color = new THREE.Color(1052688);
  } else {
    this.fadeMaterial.color = new THREE.Color(16777215);
  }
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.setLightPreset = function(index) {
  this.currentLightPreset = index;
  var preset = this.LightPresets[index];
  if (preset && preset.path) {
    var reflPath = RESOURCE_ROOT + "environments/" + preset.path + "_mipdrop.logluv.dds";
    var irrPath = RESOURCE_ROOT + "environments/" + preset.path + "_irr.logluv.dds";
    this.setIrradianceMap(irrPath);
    this.setCubeMap(reflPath);
    this.renderer.setExposureBias(preset.E_bias, preset.lightMultiplier);
    this.setGhostingBrightness(preset.brighterFade);
    this.lastLightPreset = index;
  } else {
    this.setIrradianceMap(null);
    this.setCubeMap(null);
    this.renderer.setExposureBias(0, 1);
  }
  this.renderer.setTonemapMethod(preset.tonemap);
  if (preset.tonemap) {
    this.renderer.setGamma(2);
  } else {
    this.renderer.setGamma(1);
  }
  var saoRadius = SAOShader.uniforms.radius.value;
  var saoIntensity = SAOShader.uniforms.intensity.value;
  if (preset.hasOwnProperty("saoRadius")) {
    saoRadius = preset.saoRadius;
  }
  if (preset.hasOwnProperty("saoIntensity")) {
    saoIntensity = preset.saoIntensity;
  }
  this.renderer.setAOOptions(saoRadius, saoIntensity);
  var c = preset.bgColorGradient;
  if (!c) {
    c = this.BackgroundPresets["Custom"];
  }
  this.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5]);
  var lightIntensity = 1;
  if (preset.lightMultiplier !== null && preset.lightMultiplier !== undefined) {
    lightIntensity = preset.lightMultiplier;
  }
  if (this.dir_light1) {
    this.toggleLights(lightIntensity != 0);
    this.dir_light1.intensity = lightIntensity;
  }
  this.needsClear = true;
  this.overlayDirty = true;
  this.fireRenderOptionChanged();
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.uninitialize = function() {
  window.cancelAnimationFrame(this.reqid);
  this.controls.uninitialize();
  this.controls = null;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.hideLines = function(hide) {
  this.modelQueue.hideLines(hide);
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.toggleLayerVisibility = function(layerIndex, hide) {
  var lineMaterial = this.materials["__lineMaterial__"];
  var layerMaskTex = lineMaterial.uniforms["tLayerMask"].value;
  var layerMaskData = layerMaskTex.image.data;
  var mask = hide ? 255 : 0;
  layerMaskData[4 * layerIndex] = mask;
  layerMaskData[4 * layerIndex + 1] = mask;
  layerMaskData[4 * layerIndex + 2] = mask;
  layerMaskData[4 * layerIndex + 3] = mask;
  layerMaskTex.needsUpdate = true;
  lineMaterial.needsUpdate = true;
  this.needsClear = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.fireRenderOptionChanged = function() {
  var useSAO = this.renderer.hasMRT() && this.renderer.settings.sao;
  for (var p in this.materials) {
    var m = this.materials[p];
    if (m.mrtNormals !== useSAO) {
      m.mrtNormals = useSAO;
      m.needsUpdate = true;
    }
  }
  this.api.fireEvent({type:Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT});
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.castRayViewport = function(vpx, vpy, ignoreTransparent) {
  if (!this.modelQueue) {
    return;
  }
  var vector = new THREE.Vector3(vpx, vpy, 1);
  var camera = this.camera;
  this.projector.unprojectVector(vector, camera);
  var result = this.modelQueue.rayIntersect(camera.position, vector.sub(camera.position).normalize(), ignoreTransparent);
  var object = result[0], intersectPoint = result[1];
  var dbNode = null;
  if (object) {
    var svf = this.model.getData();
    var frags = svf ? svf.fragments : null;
    var fragId = object.fragId;
    if (!frags.fragToCachedNode) {
      frags.fragToCachedNode = [];
    }
    if (frags.fragToDbNode && frags.fragToDbNode[fragId]) {
      dbNode = frags.fragToDbNode[fragId];
    } else {
      if (!frags.fragToCachedNode[fragId]) {
        frags.fragToCachedNode[fragId] = {"dbId":0, fragIds:fragId};
      }
      dbNode = frags.fragToCachedNode[fragId];
    }
  }
  return{"node":dbNode, "intersectPoint":intersectPoint};
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.castRay = function(clientX, clientY, ignoreTransparent) {
  var rect = this.canvas.getBoundingClientRect();
  var vpx = (clientX + 0.5 - rect.left) / rect.width * 2 - 1;
  var vpy = -((clientY + 0.5 - rect.top) / rect.height) * 2 + 1;
  return this.castRayViewport(vpx, vpy, ignoreTransparent);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.intersectGroundViewport = function(vpx, vpy) {
  var camera = this.camera;
  var worldUp = "z";
  if (camera.up.x == 1) {
    worldUp = "x";
  } else {
    if (camera.up.y == 1) {
      worldUp = "y";
    }
  }
  var dir = new THREE.Vector3(vpx, vpy, 1);
  this.projector.unprojectVector(dir, camera);
  dir.sub(camera.position);
  dir.normalize();
  if (Math.abs(dir[worldUp]) < 1E-6) {
    return null;
  }
  var baseElev = this.model ? this.model.getBoundingBox().min[worldUp] : 0;
  var distance = (baseElev - camera.position[worldUp]) / dir[worldUp];
  dir.multiplyScalar(distance);
  dir.add(camera.position);
  return dir;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.intersectGround = function(clientX, clientY) {
  var rect = this.canvas.getBoundingClientRect();
  var vpx = (clientX + 0.5 - rect.left) / rect.width * 2 - 1;
  var vpy = -((clientY + 0.5 - rect.top) / rect.height) * 2 + 1;
  return this.intersectGroundViewport(vpx, vpy);
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.highlightObjectViewport = function(vpx, vpy) {
  this.renderer.highlightObjectViewport(vpx, vpy);
  this.overlayDirty = true;
};
Autodesk.Viewing.Private.Viewer3DImpl.prototype.highlightObject = function(clientX, clientY) {
  var rect = this.canvas.getBoundingClientRect();
  var vpx = (clientX + 0.5 - rect.left) / rect.width * 2 - 1;
  var vpy = -((clientY + 0.5 - rect.top) / rect.height) * 2 + 1;
  this.highlightObjectViewport(vpx, vpy);
};
/*
 Copyright (c) 2014 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing.UI");
Autodesk.Viewing.UI.DockingPanel = function(parentContainer, id, title, options) {
  this.visibilityCallbacks = [];
  this.parentContainer = parentContainer;
  this.container = document.createElement("div");
  this.container.id = id;
  this.container.lastWidth = "";
  this.container.dockRight = false;
  this.container.dockBottom = false;
  this.titleLabel = title;
  var addShadow = options && options.shadow;
  this.container.className = addShadow ? "dockingPanel shadow" : "dockingPanel";
  parentContainer.appendChild(this.container);
  this.initialize();
  this.setVisible(false);
};
Autodesk.Viewing.UI.DockingPanel.prototype.initialize = function() {
  this.title = this.createTitleBar(this.titleLabel || this.container.id);
  this.container.appendChild(this.title);
  this.initializeMoveHandlers(this.title);
  this.closer = this.createCloseButton();
  this.container.appendChild(this.closer);
};
Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize = function() {
};
Autodesk.Viewing.UI.DockingPanel.prototype.addVisibilityListener = function(callback) {
  this.visibilityCallbacks.push(callback);
};
Autodesk.Viewing.UI.DockingPanel.prototype.isVisible = function() {
  return this.container.style.display !== "none" && this.container.style.display !== "";
};
Autodesk.Viewing.UI.DockingPanel.prototype.setVisible = function(show) {
  this.container.style.display = show ? "block" : "none";
  if (show) {
    if (this.container.dockRight) {
      var screenw = this.parentContainer.getBoundingClientRect().width;
      var wi = this.container.style.width ? this.container.style.width : this.container.getBoundingClientRect().width;
      if (!wi) {
        wi = this.container.lastWidth;
      }
      var wi2 = wi === "" ? 300 : parseInt(wi);
      this.container.style.left = screenw - wi2 + "px";
    }
    if (this.container.dockBottom) {
      var screenh = this.parentContainer.getBoundingClientRect().height;
      var hi = this.container.style.height ? this.container.style.height : this.container.getBoundingClientRect().height;
      if (!hi) {
        hi = this.container.lastHeight;
      }
      var hi2 = hi === "" ? 300 : parseInt(hi);
      this.container.style.top = screenh - hi2 + "px";
    }
  } else {
    this.container.lastWidth = this.parentContainer.style.width;
    this.container.lastHeight = this.parentContainer.style.height;
  }
  for (var i = 0;i < this.visibilityCallbacks.length;i++) {
    this.visibilityCallbacks[i](show);
  }
};
Autodesk.Viewing.UI.DockingPanel.prototype.initializeMoveHandlers = function(mover) {
  var x, y;
  var lastX, lastY;
  var startX, startY;
  var deltaX, deltaY;
  var container = this.container;
  var self = this;
  function handleMove(e) {
    var parentRect = self.parentContainer.getBoundingClientRect();
    if (container.style.maxWidth && parseInt(container.style.width) > parseInt(container.style.maxWidth)) {
      container.style.width = container.style.maxWidth;
    }
    if (container.style.maxHeight && parseInt(container.style.height) > parseInt(container.style.maxHeight)) {
      container.style.height = container.style.maxHeight;
    }
    if (parseInt(container.style.width) < 100) {
      container.style.width = "100px";
    }
    if (parseInt(container.style.height) < 100) {
      container.style.height = "100px";
    }
    deltaX += e.screenX - lastX;
    deltaY += e.screenY - lastY;
    x = startX + deltaX;
    y = startY + deltaY;
    var wi = parseInt(container.style.width);
    var hi = parseInt(container.style.height);
    if (isNaN(wi)) {
      wi = self.container.getBoundingClientRect().width;
    }
    if (isNaN(hi)) {
      hi = self.container.getBoundingClientRect().height;
    }
    if (x < 5) {
      x = 0;
    }
    if (y < 5) {
      y = 0;
    }
    container.dockRight = false;
    container.dockBottom = false;
    if (parentRect.width - 5 < x + wi) {
      x = parentRect.width - wi;
      container.dockRight = true;
    }
    if (parentRect.height - 5 < y + hi) {
      y = parentRect.height - hi;
      container.dockBottom = true;
    }
    container.style.left = x + "px";
    container.style.top = y + "px";
    container.style.maxWidth = parentRect.width - x + "px";
    container.style.maxHeight = parentRect.height - y + "px";
    lastX = e.screenX;
    lastY = e.screenY;
    self.onMove(e, x, y);
  }
  function handleUp(e) {
    window.removeEventListener("mousemove", handleMove);
    window.removeEventListener("mouseup", handleUp);
    self.onEndMove(e, x, y);
  }
  function handleDown(e) {
    lastX = e.screenX;
    lastY = e.screenY;
    deltaX = 0;
    deltaY = 0;
    startX = self.container.offsetLeft;
    startY = self.container.offsetTop;
    window.addEventListener("mousemove", handleMove, false);
    window.addEventListener("mouseup", handleUp, false);
    e.preventDefault();
    self.onStartMove(e, startX, startY);
  }
  mover.addEventListener("mousedown", handleDown, false);
};
Autodesk.Viewing.UI.DockingPanel.prototype.initializeCloseHandler = function(closer) {
  var self = this;
  closer.addEventListener("click", function(e) {
    self.setVisible(false);
  }, false);
};
Autodesk.Viewing.UI.DockingPanel.prototype.createScrollContainer = function(options) {
  var scrollContainer = document.createElement("div");
  scrollContainer.className = options && options.left ? "dockingPanelScroll left" : "dockingPanelScroll right";
  if (options && options.heightAdjustment) {
    scrollContainer.style.height = "calc(100% - " + options.heightAdjustment + "px)";
  }
  return scrollContainer;
};
Autodesk.Viewing.UI.DockingPanel.prototype.createTitleBar = function(title) {
  var titleBar = document.createElement("div");
  titleBar.className = "dockingPanelTitle";
  titleBar.textContent = title;
  return titleBar;
};
Autodesk.Viewing.UI.DockingPanel.prototype.createCloseButton = function() {
  var closeButton = document.createElement("div");
  closeButton.className = "dockingPanelClose";
  closeButton.innerHTML = "&times;";
  this.initializeCloseHandler(closeButton);
  return closeButton;
};
Autodesk.Viewing.UI.DockingPanel.prototype.onStartMove = function(event, startX, startY) {
};
Autodesk.Viewing.UI.DockingPanel.prototype.onEndMove = function(event, endX, endY) {
};
Autodesk.Viewing.UI.DockingPanel.prototype.onMove = function(event, currentX, currentY) {
};
/*
 Copyright (c) 2014 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing.UI");
Autodesk.Viewing.UI.ModelStructurePanel = function(parentContainer, id, title, options) {
  Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, title, options);
  this.container.style.left = "0px";
  this.container.style.top = "0px";
  this.scrollContainer = this.createScrollContainer({left:false, heightAdjustment:70});
  this.scrollContainer.style.marginTop = "20px";
  this.container.appendChild(this.scrollContainer);
  this.scrollContainer.id = this.container.id + "-scroll-container";
  this.container.style.minHeight = "100px";
  this.container.style.height = "600px";
  this.container.style.width = "340px";
  this.modelRoot = null;
  this.tree = null;
  this.selectedNodes = [];
  this.options = options;
  this.movedSinceLastClick = false;
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.UI.ModelStructurePanel.prototype.constructor = Autodesk.Viewing.UI.ModelStructurePanel;
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setModel = function(modelRoot, modelTitle) {
  var that = this;
  var createDelegate = function() {
    var delegate = new Autodesk.Viewing.UI.TreeDelegate;
    delegate.getTreeNodeId = function(node) {
      return node.dbId;
    };
    delegate.getTreeNodeLabel = function(node) {
      return that.getNodeLabel(node);
    };
    delegate.getTreeNodeClass = function(node) {
      return that.getNodeClass(node);
    };
    delegate.isTreeNodeGroup = function(node) {
      return that.isGroupNode(node);
    };
    delegate.shouldCreateTreeNode = function(node) {
      return that.shouldInclude(node);
    };
    delegate.onTreeNodeHover = function(tree, node, event) {
      that.onHover(node, event);
    };
    delegate.onTreeNodeClick = function(tree, node, event) {
      that.onClick(node, event);
    };
    delegate.onTreeNodeRightClick = function(tree, node, event) {
      that.onRightClick(node, event);
    };
    delegate.onTreeNodeDoubleClick = function(tree, node, event) {
      that.onDoubleClick(node, event);
    };
    return delegate;
  };
  that.selectedNodes = [];
  var title = modelTitle;
  if (!title) {
    if (that.options && that.options.defaultTitle) {
      title = that.options.defaultTitle;
    } else {
      if (modelRoot) {
        title = modelRoot.name;
      }
    }
  }
  if (!title) {
    title = "Model Structure";
  }
  that.setTitle(title);
  if (that.tree) {
    while (that.scrollContainer.hasChildNodes()) {
      that.scrollContainer.removeChild(that.scrollContainer.lastChild);
    }
    that.title.removeEventListener("click", that.onTitleClick);
    that.title.removeEventListener("dblclick", that.onTitleDoubleClick);
  }
  that.modelRoot = modelRoot;
  if (!modelRoot) {
    return;
  }
  var delegate = createDelegate();
  that.tree = new Autodesk.Viewing.UI.Tree(delegate, modelRoot, that.scrollContainer, {});
  if (!that.options || (!that.options.hasOwnProperty("startCollapsed") || that.options.startCollapsed)) {
    that.tree.setAllCollapsed(true);
    that.tree.setCollapsed(delegate.getTreeNodeId(modelRoot), false);
  }
  if (!that.options || (!that.options.hasOwnProperty("excludeRoot") || that.options.excludeRoot)) {
    that.tree.addClass(delegate.getTreeNodeId(modelRoot), "exclude");
  }
  that.onTitleClick = function(e) {
    if (!self.movedSinceLastClick) {
      that.onClick(modelRoot, e);
    }
    self.movedSinceLastClick = false;
  };
  that.onTitleDoubleClick = function(e) {
    that.onDoubleClick(modelRoot, e);
  };
  that.title.addEventListener("click", that.onTitleClick, false);
  that.title.addEventListener("dblclick", that.onTitleDoubleClick, false);
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setTitle = function(title) {
  this.title.textContent = title;
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.getNodeLabel = function(node) {
  return node.name && node.name !== "" ? node.name : "Object " + node.dbId;
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.getNodeClass = function(node) {
  return "";
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.isGroupNode = function(node) {
  return node.children && (Array.isArray(node.children) && node.children.length > 0);
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.shouldInclude = function(node) {
  return true;
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onHover = function(node, event) {
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onClick = function(node, event) {
  this.setSelection([node]);
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onDoubleClick = function(node, event) {
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onRightClick = function(node, event) {
};
Autodesk.Viewing.UI.DockingPanel.prototype.onMove = function(event, currentX, currentY) {
  self.movedSinceLastClick = true;
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setSelection = function(nodes) {
  if (!this.tree) {
    return;
  }
  for (var i = 0;i < this.selectedNodes.length;++i) {
    var parent = this.selectedNodes[i].parent;
    while (parent) {
      this.tree.removeClass(this.tree.delegate().getTreeNodeId(parent), "ancestor-selected");
      parent = parent.parent;
    }
  }
  var selectedIds = [];
  for (var i = 0;i < nodes.length;++i) {
    selectedIds.push(nodes[i].dbId);
    var parent = nodes[i].parent;
    while (parent) {
      this.tree.addClass(this.tree.delegate().getTreeNodeId(parent), "ancestor-selected");
      parent = parent.parent;
    }
  }
  this.selectedNodes = nodes;
  this.tree.setSelection(selectedIds);
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.addClass = function(id, className) {
  this.tree.addClass(id, className);
};
Autodesk.Viewing.UI.ModelStructurePanel.prototype.removeClass = function(id, className) {
  this.tree.removeClass(id, className);
};
/*
 Copyright (c) 2014 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing.Extensions");
Autodesk.Viewing.Extensions.ViewerModelStructurePanel = function(viewer, title, options) {
  this.viewer = viewer;
  Autodesk.Viewing.UI.ModelStructurePanel.call(this, viewer.container, viewer.container.id + "ViewerModelStructurePanel", title, options);
  this.clickConfig = options && options.docStructureConfig ? options.docStructureConfig : null;
  this.isMac = navigator.userAgent.search("Mac OS") !== -1;
  this.visibleNodes = [];
  this.hiddenNodes = [];
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype = Object.create(Autodesk.Viewing.UI.ModelStructurePanel.prototype);
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.constructor = Autodesk.Viewing.Extensions.ViewerModelStructurePanel;
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.initialize = function() {
  Autodesk.Viewing.UI.ModelStructurePanel.prototype.initialize.call(this);
  var that = this;
  that.viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(event) {
    that.setSelection(event.nodeArray);
  });
  that.viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function(event) {
    that.setIsolation(event.nodeIdArray);
  });
  that.viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, function(event) {
    that.setHidden(event.nodeIdArray, true);
  });
  that.viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, function(event) {
    that.setHidden(event.nodeIdArray, false);
  });
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setModel = function(modelRoot, modelTitle) {
  this.visibleNodes = [];
  this.hiddenNodes = [];
  Autodesk.Viewing.UI.ModelStructurePanel.prototype.setModel.call(this, modelRoot, modelTitle);
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.handleAction = function(actionArray, node) {
  for (var action in actionArray) {
    switch(actionArray[action]) {
      case "selectOnly":
        this.viewer.select([node.dbId]);
        break;
      case "deselectAll":
        this.viewer.select([]);
        break;
      case "selectToggle":
        this.viewer.toggleSelect(node.dbId);
        break;
      case "isolate":
        this.viewer.isolate(node);
        break;
      case "showAll":
        this.viewer.isolate(null);
        break;
      case "focus":
        this.viewer.fitToView();
        break;
      case "hide":
        this.viewer.hide(node);
        break;
      case "show":
        this.viewer.show(node);
        break;
      case "toggleVisibility":
        this.viewer.toggleVisibility(node);
        break;
    }
  }
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.ctrlDown = function(event) {
  return this.isMac && event.metaKey || !this.isMac && event.ctrlKey;
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick = function(node, event) {
  var that = this;
  var key = "click";
  if (that.ctrlDown(event)) {
    key += "Ctrl";
  }
  if (event.shiftKey) {
    key += "Shift";
  }
  if (event.altKey) {
    key += "Alt";
  }
  if (this.clickConfig && this.clickConfig[key]) {
    that.handleAction(this.clickConfig[key]["onObject"], node);
  } else {
    this.viewer.select([node.dbId]);
  }
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onDoubleClick = function(node, event) {
  this.handleAction(["focus"], node);
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onRightClick = function(node, event) {
  var dbIds = [node.dbId];
  if (event.shiftKey || (this.isMac && event.metaKey || event.ctrlKey && (!this.isMac || event.button === 2))) {
    var selectedNodes = this.viewer.impl.selector.getSelection();
    for (var i = 0;i < selectedNodes.length;++i) {
      dbIds.push(selectedNodes[i].dbId);
    }
  }
  this.viewer.isolateById(dbIds);
  this.viewer.select(dbIds);
  return this.viewer.objectContextMenu.show(event);
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setHidden = function(nodes, hidden) {
  if (nodes.length > 0) {
    for (var i = 0;i < nodes.length;++i) {
      var node = nodes[i];
      if (hidden) {
        if (this.hiddenNodes.indexOf(node) === -1) {
          this.addClass(nodes[i].dbId, "dim");
          this.hiddenNodes.push(nodes[i]);
          var index = this.visibleNodes.indexOf(node);
          if (index > -1) {
            this.removeClass(nodes[i].dbId, "visible");
            this.visibleNodes.splice(index);
          }
        }
      } else {
        if (this.visibleNodes.indexOf(node) === -1) {
          this.addClass(nodes[i].dbId, "visible");
          this.visibleNodes.push(nodes[i]);
          var index = this.hiddenNodes.indexOf(node);
          if (index > -1) {
            this.removeClass(nodes[i].dbId, "dim");
            this.hiddenNodes.splice(index);
          }
        }
      }
    }
  }
};
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setIsolation = function(nodes) {
  for (var i = 0;i < this.hiddenNodes.length;++i) {
    this.removeClass(this.hiddenNodes[i].dbId, "dim");
  }
  for (var i = 0;i < this.visibleNodes.length;++i) {
    this.removeClass(this.visibleNodes[i].dbId, "visible");
  }
  this.visibleNodes = nodes;
  if (this.visibleNodes.length > 0) {
    if (this.visibleNodes.length === 1 && this.visibleNodes[0] === this.modelRoot) {
      return;
    }
    this.addClass(this.modelRoot.dbId, "dim");
    this.hiddenNodes = [this.modelRoot];
    for (var i = 0;i < this.visibleNodes.length;++i) {
      this.addClass(this.visibleNodes[i].dbId, "visible");
    }
  }
};
AutodeskNamespace("Autodesk.Viewing.Extensions");
Autodesk.Viewing.Extensions.RaaSPanel = function(viewer) {
  var self = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "RaaSPanel", "Cloud Rendering", {shadow:true});
  this.renderButton = document.createElement("input");
  this.renderButton.setAttribute("type", "button");
  this.renderButton.setAttribute("value", "Render");
  this.renderButton.id = "renderButton";
  this.container.appendChild(this.renderButton);
  this.thumbnailPanel = document.createElement("div");
  this.thumbnailPanel.id = "thumbnailPanel";
  this.imagePanel = document.createElement("div");
  this.imagePanel.id = "imagePanel";
  this.container.appendChild(document.getElementById("loader"));
  document.getElementById("loader").style.display = "none";
  this.imageNum = 0;
  this.thumbList = [];
  this.imageList = [];
  this.imageIndex = 0;
  this.container.style.width = 1E3 + 20 + "px";
  this.container.style.top = "10px";
  this.container.style.left = "150px";
  this.container.style.height = 700 + 50 + "px";
  this.container.style.display = "none";
  this.viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function() {
    self.syncUI();
  });
  this.renderButton.addEventListener("click", function() {
    self.addImage();
    self.container.appendChild(self.thumbnailPanel);
    self.container.appendChild(self.imagePanel);
    self.imagePanel.style.display = "none";
    document.getElementById("loader").style.display = "block";
    self.imageIndex = self.imageNum - 1;
    for (var i = 0;i < self.thumbList.length;i++) {
      self.thumbList[i].addEventListener("click", function() {
        if (self.imageList[this.index].status == "progress") {
          self.imagePanel.style.display = "none";
          self.imageList[self.imageIndex].style.display = "none";
          self.imageIndex = this.index;
          document.getElementById("loader").style.display = "block";
        } else {
          if (self.imageList[this.index].status == "complete") {
            document.getElementById("loader").style.display = "none";
            self.imageList[self.imageIndex].style.display = "none";
            self.imageList[this.index].style.display = "block";
            self.imagePanel.style.display = "block";
            self.imageIndex = this.index;
          } else {
            if (self.imageList[this.index].status == "error") {
              document.getElementById("loader").style.display = "none";
              self.imageList[self.imageIndex].style.display = "none";
              self.imageIndex = this.index;
            }
          }
        }
      });
    }
    viewer.impl.svfloader.testCloudRendering(viewer);
  });
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.RaaSPanel.prototype.constructor = Autodesk.Viewing.Extensions.RaaSPanel;
Autodesk.Viewing.Extensions.RaaSPanel.prototype.syncUI = function() {
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.screenCapture = function(viewer) {
  return Autodesk.Viewing.ScreenCapture(viewer);
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.addImage = function() {
  var thm = new Image;
  thm.src = this.screenCapture(this.viewer);
  thm.className = "thumbnail";
  thm.style.left = 130 * this.imageNum + "px";
  thm.index = this.imageNum;
  this.thumbList.push(thm);
  this.thumbnailPanel.appendChild(this.thumbList[this.imageNum]);
  var img = new Image;
  img.src = "";
  img.status = "progress";
  this.imageList.push(img);
  this.imagePanel.appendChild(this.imageList[this.imageNum]);
  this.imageNum++;
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.loadThumbnail = function(url) {
  this.thumbList[this.imageNum - 1].src = url;
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.loadImage = function(url) {
  this.imageList[this.imageNum - 1].src = url;
  this.imageList[this.imageNum - 1].status = "complete";
  document.getElementById("loader").style.display = "none";
  if (this.imageIndex == this.imageNum - 1) {
    this.imagePanel.style.display = "block";
    this.imageList[this.imageIndex].style.display = "block";
  }
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.imageError = function() {
  this.imageList[this.imageNum - 1].status = "error";
  document.getElementById("loader").style.display = "none";
};
Autodesk.Viewing.Extensions.RaaSPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  this.closer = null;
  this.title = null;
  this.viewer = null;
  this.renderButton = null;
  this.mainImage = null;
};
AutodeskNamespace("Autodesk.Viewing.Extensions");
Autodesk.Viewing.Extensions.RaaSDataPanel = function(viewer) {
  var self = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "RaaSDataPanel", "RaaS Data", {shadow:true});
  this.table = document.createElement("table");
  self.addTableRow("cameraPosition");
  self.addTableRow("cameraIsPerspective");
  self.addTableRow("cameraUp");
  self.addTableRow("cameraTarget");
  self.addTableRow("cameraNear");
  self.addTableRow("cameraFar");
  self.addTableRow("cameraFov");
  self.addTableRow("cameraAspect");
  self.addTableRow("lightName");
  self.addTableRow("lightPath");
  self.addTableRow("lightTonemap");
  self.addTableRow("lightE_bias");
  self.addTableRow("lightDirectLightColor");
  self.addTableRow("lightAmbientColor");
  self.addTableRow("lightMultiplier");
  self.addTableRow("lightBgColorGradientClearColorTop");
  self.addTableRow("lightBgColorGradientClearColorBottom");
  self.addTableRow("renderOptionsSaoToggle");
  self.addTableRow("renderOptionsSaoRadius");
  self.addTableRow("renderOptionsSaoIntensity");
  self.addTableRow("renderOptionsGamma");
  self.addTableRow("renderOptionsExposureBias");
  self.addTableRow("renderOptionsWhitePointIntensity");
  self.addTableRow("renderOptionsFovAngle");
  this.container.appendChild(this.table);
  this.container.style.width = "600px";
  this.container.style.top = "100px";
  this.container.style.left = "220px";
  this.container.style.height = "660px";
  this.container.dock = true;
  this.container.style.display = "none";
  this.viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function() {
    self.syncUI();
  });
};
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype.constructor = Autodesk.Viewing.Extensions.RaaSDataPanel;
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype.syncUI = function() {
};
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype.addTableRow = function(name) {
  var titleRow = document.createElement("tr");
  var dataName = document.createElement("td");
  this.dataValue = document.createElement("td");
  this.dataValue.id = name;
  dataName.textContent = name;
  this.dataValue.textContent = "";
  titleRow.appendChild(dataName);
  titleRow.appendChild(this.dataValue);
  this.table.appendChild(titleRow);
};
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype.undistort = function(viewer) {
  this.img.style.width = window.innerWidth / 2 + "px";
  this.img.style.height = window.innerHeight / 2 + "px";
  this.container.style.width = this.img.style.width;
  this.container.style.height = window.innerHeight / 2 + 50 + "px";
};
Autodesk.Viewing.Extensions.RaaSDataPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  this.closer = null;
  this.title = null;
  this.viewer = null;
  this.img = null;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.addClass = function(elem, name) {
  if (elem) {
    var found = false;
    var classNames = elem.className.split(/\s+/).filter(Boolean);
    for (var i = 0;i < classNames.length;++i) {
      if (classNames[i] === name) {
        found = true;
        break;
      }
    }
    if (!found) {
      classNames.push(name);
      elem.className = classNames.join(" ");
    }
  }
};
Autodesk.Viewing.Private.removeClass = function(elem, name) {
  if (elem) {
    var classNames = elem.className.split(/\s+/).filter(Boolean);
    for (var i = 0;i < classNames.length;++i) {
      if (classNames[i] === name) {
        classNames.splice(i, 1);
        elem.className = classNames.join(" ");
        break;
      }
    }
  }
};
Autodesk.Viewing.Private.hasClass = function(elem, name) {
  if (elem) {
    var classNames = elem.className.split(/\s+/).filter(Boolean);
    for (var i = 0;i < classNames.length;++i) {
      if (classNames[i] === name) {
        return true;
      }
    }
  }
  return false;
};
Autodesk.Viewing.Private.toggleClass = function(elem, name) {
  if (Autodesk.Viewing.Private.hasClass(elem, name)) {
    Autodesk.Viewing.Private.removeClass(elem, name);
  } else {
    Autodesk.Viewing.Private.addClass(elem, name);
  }
};
Autodesk.Viewing.Private.Preferences = function(viewer, prefix, useWebStorage) {
  this.viewer = viewer;
  if (!prefix) {
    prefix = "Autodesk.Viewing.Preferences.";
  }
  this.prefix = prefix;
  if (useWebStorage === undefined) {
    useWebStorage = true;
  }
  this.useWebStorage = useWebStorage;
  this.defaults = {};
  this.values = {};
};
Autodesk.Viewing.Private.Preferences.prototype.constructor = Autodesk.Viewing.Private.Preferences;
Autodesk.Viewing.Private.Preferences.PREFERENCES_RESET_EVENT = "PreferencesReset";
Autodesk.Viewing.Private.Preferences.prototype.load = function(defaults) {
  this.defaults = defaults;
  for (var name in defaults) {
    if (defaults.hasOwnProperty(name)) {
      var value = this._webStorage(name);
      if (value === "true" || value === "false") {
        value = value === "true";
      }
      this.values[name] = value !== null ? value : defaults[name];
    }
  }
};
Autodesk.Viewing.Private.Preferences.prototype.reset = function() {
  for (var name in this.defaults) {
    if (this.defaults.hasOwnProperty(name)) {
      this.set(name, this.defaults[name]);
    }
  }
  this.viewer.fireEvent(Autodesk.Viewing.Private.Preferences.PREFERENCES_RESET_EVENT);
};
Autodesk.Viewing.Private.Preferences.prototype.addResetListener = function(name, onResetCallback) {
  var that = this;
  that.viewer.addEventListener(Autodesk.Viewing.Private.Preferences.PREFERENCES_RESET_EVENT, function() {
    onResetCallback(name ? that.values[name] : that.values);
  }, false);
};
Autodesk.Viewing.Private.Preferences.prototype.get = function(name) {
  return this.values[name];
};
Autodesk.Viewing.Private.Preferences.prototype.set = function(name, value) {
  this.values[name] = value;
  this._webStorage(name, value);
};
Autodesk.Viewing.Private.Preferences.prototype._webStorage = function(name, value) {
  if (!this.useWebStorage) {
    return null;
  }
  if (typeof localStorage !== "undefined" && typeof name === "string") {
    name = this.prefix + name;
    if (typeof value !== "undefined") {
      localStorage[name] = value;
    } else {
      value = localStorage[name] || null;
    }
    return value;
  }
  return null;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.PropertyPanel = function(viewer) {
  var scope = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "PropertyPanel", "Object Properties Loading...", {shadow:false});
  this.table = document.createElement("table");
  this.table.id = "propertygrid";
  this.table.className = "tftable";
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  this.scrollpanel = this.createScrollContainer({heightAdjustment:70});
  this.scrollpanel.style.marginTop = "20px";
  this.container.appendChild(this.scrollpanel);
  this.scrollpanel.appendChild(this.table);
  this.container.style.width = "335px";
  this.container.style.height = "200px";
  this.container.style.top = "180px";
  this.container.style.left = "220px";
  this.container.dockRight = true;
  function highlight(element) {
    var text = viewer.searchText;
    if (text !== "") {
      var query = new RegExp("(\\b" + text + "\\b)", "gim");
      var e = element.innerHTML;
      var enew = e.replace(/(<highlight>|<\/highlight>)/igm, "");
      element.innerHTML = enew;
      var newe = enew.replace(query, "<highlight>$1</highlight>");
      element.innerHTML = newe;
    }
    return element;
  }
  this.setOpenOnSelect = function(openOnSelect) {
    this.openOnSelect = openOnSelect;
  };
  this.lastSelected = [];
  viewer.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(e) {
    scope.lastSelected = e.dbIdArray;
    scope.pullCorrectProperties();
    if (scope.openOnSelect) {
      scope.setVisible(e.dbIdArray.length > 0);
    }
  });
  viewer.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function(e) {
    var dbIdArray = [];
    for (var i = 0;i < e.nodeIdArray.length;i++) {
      var dbId = e.nodeIdArray[i].dbId;
      if (dbId) {
        dbIdArray.push(dbId);
      }
    }
    scope.lastSelected = dbIdArray;
    scope.pullCorrectProperties();
    if (scope.openOnSelect) {
      scope.setVisible(e.nodeIdArray.length > 0);
    }
  });
  viewer.addEventListener(Autodesk.Viewing.HIDE_EVENT, function(e) {
    scope.pullCorrectProperties();
  });
  viewer.addEventListener(Autodesk.Viewing.SHOW_EVENT, function(e) {
    scope.pullCorrectProperties();
    if (scope.openOnSelect) {
      scope.setVisible(e.nodeIdArray.length > 0);
    }
  });
  this.pullCorrectProperties = function() {
    if (this.lastSelected.length > 0) {
      this.setNodeId(this.lastSelected[this.lastSelected.length - 1]);
      return;
    }
    if (!viewer.areAllVisible()) {
      var nodeQueue = [viewer.model.getRoot()];
      while (nodeQueue.length > 0) {
        var node = nodeQueue.shift();
        if (node) {
          if (Autodesk.Viewing.Private.VisibilityManager.isVisible(node)) {
            this.setNodeId(node.dbId);
            return;
          }
          if (node.children) {
            for (var i = 0;i < node.children.length;i++) {
              nodeQueue.push(node.children[i]);
            }
          }
        }
      }
    }
    var nodeId = viewer.model.getRoot() ? viewer.model.getRootId() : null;
    this.setNodeId(nodeId);
  };
  this.getNodeId = function() {
    return this.currentID;
  };
  this.setDefaultProperties = function() {
    if (viewer.model.getRoot()) {
      this.setNodeId(viewer.model.getRootId());
    } else {
      this.setNodeId(null);
    }
  };
  this.setNodeId = function(selectedNodeId) {
    scope.tbody.innerHTML = "";
    var nodeId = selectedNodeId;
    if (!nodeId) {
      nodeId = viewer.model && viewer.model.getRoot() ? viewer.model.getRootId() : null;
    }
    if (nodeId) {
      this.currentID = nodeId;
      viewer.getProperties(nodeId, function(result) {
        scope.tbody.innerHTML = "";
        if (result.properties) {
          for (var i = 0;i < result.properties.length;i++) {
            var property = result.properties[i];
            var item = property.displayValue;
            var row = scope.tbody.insertRow(-1);
            var cell = row.insertCell(0);
            cell.textContent = property.displayName;
            cell = row.insertCell(1);
            cell.textContent = item;
            highlight(cell);
          }
        }
        var caption = scope.title;
        if (!result.name) {
          caption.textContent = "Object Properties";
        } else {
          caption.textContent = result.name;
        }
        scope.scrollpanel.scrollTop = 0;
        var elem = scope.viewer.canvas, docwidth = elem.clientWidth, docheight = elem.clientHeight;
        var ih = scope.table.offsetHeight + scope.title.offsetHeight + parseInt(scope.scrollpanel.style.marginBottom);
        scope.container.style.height = (ih > docheight - 180 ? docheight - 180 : ih) + "px";
      });
    } else {
      this.currentID = null;
      var caption = scope.title;
      caption.textContent = "Object Properties";
    }
  };
};
Autodesk.Viewing.Private.PropertyPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.PropertyPanel.prototype.constructor = Autodesk.Viewing.Private.PropertyPanel;
Autodesk.Viewing.Private.PropertyPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  this.closer = null;
  this.title = null;
  this.viewer = null;
  this.table = null;
  this.tbody = null;
  this.scrollpanel = null;
  this.viewer = null;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.OptionSlider = function(caption, min, max, parentTbody) {
  var self = this;
  this.tbody = parentTbody;
  this.sliderRow = this.tbody.insertRow(-1);
  var cell = this.sliderRow.insertCell(0);
  this.caption = document.createElement("div");
  this.caption.innerHTML = caption + ":";
  this.sliderElement = document.createElement("input");
  this.sliderElement.type = "range";
  this.sliderElement.id = caption + "_slider";
  this.sliderElement.min = min;
  this.sliderElement.max = max;
  cell.appendChild(this.caption);
  cell.appendChild(this.sliderElement);
  cell = this.sliderRow.insertCell(1);
  this.stepperElement = document.createElement("input");
  this.stepperElement.type = "number";
  this.stepperElement.id = caption + "_stepper";
  this.stepperElement.min = min;
  this.stepperElement.max = max;
  this.stepperElement.step = 1;
  this.stepperElement.style.width = "64px";
  cell.appendChild(this.stepperElement);
  this.blockEvent = false;
  this.stepperElement.addEventListener("change", function(e) {
    if (e.target != self.sliderElement) {
      self.sliderElement.value = self.stepperElement.value;
    }
    self.fireChangeEvent();
  }, false);
  function changeHandler(e) {
    if (e.target != self.stepperElement) {
      self.stepperElement.value = self.sliderElement.value;
    }
    self.fireChangeEvent();
  }
  this.sliderElement.addEventListener("change", changeHandler, false);
  this.sliderElement.addEventListener("input", changeHandler, false);
};
Autodesk.Viewing.Private.OptionSlider.prototype = Object.create(THREE.EventDispatcher.prototype);
Autodesk.Viewing.Private.OptionSlider.prototype.fireChangeEvent = function() {
  if (!this.blockEvent) {
    this.value = this.sliderElement.value;
    var e = new CustomEvent("change", {detail:{target:this, value:this.sliderElement.value}});
    this.dispatchEvent(e);
  }
};
Autodesk.Viewing.Private.OptionSlider.prototype.setValue = function(v) {
  this.blockEvent = true;
  this.value = v;
  this.sliderElement.value = v;
  this.stepperElement.value = v;
  this.blockEvent = false;
};
Autodesk.Viewing.Private.OptionSlider.prototype.setDisabled = function(v) {
  this.sliderElement.disabled = v;
  this.stepperElement.disabled = v;
  this.caption.disabled = v;
};
Autodesk.Viewing.Private.OptionCheckbox = function(caption, parentTbody, initialState) {
  THREE.EventDispatcher.call(this.prototype);
  var self = this;
  this.tbody = parentTbody;
  this.sliderRow = this.tbody.insertRow(-1);
  var cell = this.sliderRow.insertCell(0);
  this.caption = document.createElement("div");
  this.caption.innerHTML = caption;
  cell.appendChild(this.caption);
  cell = this.sliderRow.insertCell(1);
  this.checkElement = document.createElement("input");
  this.checkElement.type = "checkbox";
  this.checkElement.id = caption + "_check";
  this.checkElement.checked = initialState;
  cell.appendChild(this.checkElement);
  this.blockEvent = false;
  this.checked = initialState;
  this.checkElement.addEventListener("change", function(e) {
    self.fireChangeEvent();
  }, false);
  this.checkElement.addEventListener("click", function(event) {
    event.stopPropagation();
  }, false);
  this.sliderRow.addEventListener("click", function(e) {
    self.checkElement.checked = !self.checkElement.checked;
    self.fireChangeEvent();
  }, false);
};
Autodesk.Viewing.Private.OptionCheckbox.prototype = Object.create(THREE.EventDispatcher.prototype);
Autodesk.Viewing.Private.OptionCheckbox.prototype.fireChangeEvent = function() {
  if (!this.blockEvent) {
    this.checked = this.checkElement.checked;
    var e = new CustomEvent("change", {detail:{target:this, value:this.checkElement.checked}});
    this.dispatchEvent(e);
  }
};
Autodesk.Viewing.Private.OptionCheckbox.prototype.setValue = function(v) {
  this.blockEvent = true;
  this.checked = v;
  this.checkElement.checked = v;
  this.blockEvent = false;
};
Autodesk.Viewing.Private.OptionCheckbox.prototype.setDisabled = function(v) {
  this.checkElement.disabled = v;
  this.caption.disabled = v;
};
Autodesk.Viewing.Private.OptionDropDown = function(caption, parentTbody, items, initialItemIndex) {
  THREE.EventDispatcher.call(this.prototype);
  var self = this;
  this.tbody = parentTbody;
  this.sliderRow = this.tbody.insertRow(-1);
  var cell = this.sliderRow.insertCell(0);
  this.caption = document.createElement("div");
  this.caption.innerHTML = caption + ":";
  cell.appendChild(this.caption);
  cell = this.sliderRow.insertCell(1);
  this.dropdownElement = document.createElement("select");
  this.dropdownElement.id = caption + "_dropdown";
  this.dropdownElement.className = "optionDropDown";
  for (var i = 0;i < items.length;i++) {
    var item = document.createElement("option");
    item.value = i;
    item.text = items[i];
    this.dropdownElement.add(item);
  }
  this.selectedIndex = this.dropdownElement.selectedIndex = initialItemIndex;
  cell.appendChild(this.dropdownElement);
  this.blockEvent = false;
  this.dropdownElement.addEventListener("change", function(e) {
    self.fireChangeEvent();
  }, false);
};
Autodesk.Viewing.Private.OptionDropDown.prototype = Object.create(THREE.EventDispatcher.prototype);
Autodesk.Viewing.Private.OptionDropDown.prototype.setSelectedIndex = function(index) {
  this.blockEvent = true;
  this.selectedIndex = this.dropdownElement.selectedIndex = index;
  this.blockEvent = false;
};
Autodesk.Viewing.Private.OptionDropDown.prototype.setSelectedValue = function(value) {
  this.blockEvent = true;
  this.dropdownElement.selectedValue = value;
  this.selectedIndex = this.dropdownElement.selectedIndex;
  this.blockEvent = false;
};
Autodesk.Viewing.Private.OptionDropDown.prototype.fireChangeEvent = function() {
  if (!this.blockEvent) {
    this.selectedIndex = this.dropdownElement.selectedIndex;
    var e = new CustomEvent("change", {detail:{target:this, value:this.selectedIndex}});
    this.dispatchEvent(e);
  }
};
Autodesk.Viewing.Private.OptionDropDown.prototype.setDisabled = function(v) {
  this.dropdownElement.disabled = v;
  this.caption.disabled = v;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.ProgressBar = function(container) {
  this.bg = document.createElement("div");
  this.bg.className = "progressbg";
  this.fg = document.createElement("div");
  this.fg.className = "progressfg";
  this.bg.appendChild(this.fg);
  container.appendChild(this.bg);
  this.widthScale = this.fg.clientWidth;
};
Autodesk.Viewing.Private.ProgressBar.prototype.setPercent = function(pct) {
  if (pct >= 99) {
    this.bg.style.visibility = "hidden";
  } else {
    this.bg.style.visibility = "visible";
    this.fg.style.width = this.widthScale * pct * 0.01 + "px";
  }
};
if (typeof window !== "undefined") {
  (function(s, t, u) {
    var v = s.SVGAngle || t.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML", picker, slide, hueOffset = 15, svgNS = "http://www.w3.org/2000/svg";
    var w = ['<div class="picker-wrapper">', '<div class="picker"></div>', '<div class="picker-indicator"></div>', "</div>", '<div class="slide-wrapper">', '<div class="slide"></div>', '<div class="slide-indicator"></div>', "</div>"].join("");
    function mousePosition(a) {
      if (s.event && s.event.contentOverflow !== u) {
        return{x:s.event.offsetX, y:s.event.offsetY};
      }
      if (a.offsetX !== u && a.offsetY !== u) {
        return{x:a.offsetX, y:a.offsetY};
      }
      var b = a.target.parentNode.parentNode;
      return{x:a.layerX - b.offsetLeft, y:a.layerY - b.offsetTop};
    }
    function $(a, b, c) {
      a = t.createElementNS(svgNS, a);
      for (var d in b) {
        a.setAttribute(d, b[d]);
      }
      if (Object.prototype.toString.call(c) != "[object Array]") {
        c = [c];
      }
      var i = 0, len = c[0] && c.length || 0;
      for (;i < len;i++) {
        a.appendChild(c[i]);
      }
      return a;
    }
    if (v == "SVG") {
      slide = $("svg", {xmlns:"http://www.w3.org/2000/svg", version:"1.1", width:"100%", height:"100%"}, [$("defs", {}, $("linearGradient", {id:"gradient-hsv", x1:"0%", y1:"100%", x2:"0%", y2:"0%"}, [$("stop", {offset:"0%", "stop-color":"#FF0000", "stop-opacity":"1"}), $("stop", {offset:"13%", "stop-color":"#FF00FF", "stop-opacity":"1"}), $("stop", {offset:"25%", "stop-color":"#8000FF", "stop-opacity":"1"}), $("stop", {offset:"38%", "stop-color":"#0040FF", "stop-opacity":"1"}), $("stop", {offset:"50%", 
      "stop-color":"#00FFFF", "stop-opacity":"1"}), $("stop", {offset:"63%", "stop-color":"#00FF40", "stop-opacity":"1"}), $("stop", {offset:"75%", "stop-color":"#0BED00", "stop-opacity":"1"}), $("stop", {offset:"88%", "stop-color":"#FFFF00", "stop-opacity":"1"}), $("stop", {offset:"100%", "stop-color":"#FF0000", "stop-opacity":"1"})])), $("rect", {x:"0", y:"0", width:"100%", height:"100%", fill:"url(#gradient-hsv)"})]);
      picker = $("svg", {xmlns:"http://www.w3.org/2000/svg", version:"1.1", width:"100%", height:"100%"}, [$("defs", {}, [$("linearGradient", {id:"gradient-black", x1:"0%", y1:"100%", x2:"0%", y2:"0%"}, [$("stop", {offset:"0%", "stop-color":"#000000", "stop-opacity":"1"}), $("stop", {offset:"100%", "stop-color":"#CC9A81", "stop-opacity":"0"})]), $("linearGradient", {id:"gradient-white", x1:"0%", y1:"100%", x2:"100%", y2:"100%"}, [$("stop", {offset:"0%", "stop-color":"#FFFFFF", "stop-opacity":"1"}), 
      $("stop", {offset:"100%", "stop-color":"#CC9A81", "stop-opacity":"0"})])]), $("rect", {x:"0", y:"0", width:"100%", height:"100%", fill:"url(#gradient-white)"}), $("rect", {x:"0", y:"0", width:"100%", height:"100%", fill:"url(#gradient-black)"})]);
    } else {
      if (v == "VML") {
        slide = ['<DIV style="position: relative; width: 100%; height: 100%">', '<v:rect style="position: absolute; top: 0; left: 0; width: 100%; height: 100%" stroked="f" filled="t">', '<v:fill type="gradient" method="none" angle="0" color="red" color2="red" colors="8519f fuchsia;.25 #8000ff;24903f #0040ff;.5 aqua;41287f #00ff40;.75 #0bed00;57671f yellow"></v:fill>', "</v:rect>", "</DIV>"].join("");
        picker = ['<DIV style="position: relative; width: 100%; height: 100%">', '<v:rect style="position: absolute; left: -1px; top: -1px; width: 101%; height: 101%" stroked="f" filled="t">', '<v:fill type="gradient" method="none" angle="270" color="#FFFFFF" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill>', "</v:rect>", '<v:rect style="position: absolute; left: 0px; top: 0px; width: 100%; height: 101%" stroked="f" filled="t">', '<v:fill type="gradient" method="none" angle="0" color="#000000" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill>', 
        "</v:rect>", "</DIV>"].join("");
        if (!t.namespaces["v"]) {
          t.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML");
        }
      }
    }
    function hsv2rgb(a) {
      var R, G, B, X, C;
      var h = a.h % 360 / 60;
      C = a.v * a.s;
      X = C * (1 - Math.abs(h % 2 - 1));
      R = G = B = a.v - C;
      h = ~~h;
      R += [C, X, 0, 0, X, C][h];
      G += [X, C, C, X, 0, 0][h];
      B += [0, 0, X, C, C, X][h];
      var r = Math.floor(R * 255);
      var g = Math.floor(G * 255);
      var b = Math.floor(B * 255);
      return{r:r, g:g, b:b, hex:"#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1)};
    }
    function rgb2hsv(a) {
      var r = a.r;
      var g = a.g;
      var b = a.b;
      if (a.r > 1 || (a.g > 1 || a.b > 1)) {
        r /= 255;
        g /= 255;
        b /= 255;
      }
      var H, S, V, C;
      V = Math.max(r, g, b);
      C = V - Math.min(r, g, b);
      H = C == 0 ? null : V == r ? (g - b) / C + (g < b ? 6 : 0) : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
      H = H % 6 * 60;
      S = C == 0 ? 0 : C / V;
      return{h:H, s:S, v:V};
    }
    function slideListener(d, e, f) {
      return function(a) {
        a = a || s.event;
        var b = mousePosition(a);
        d.h = b.y / e.offsetHeight * 360 + hueOffset;
        d.s = d.v = 1;
        var c = hsv2rgb({h:d.h, s:1, v:1});
        f.style.backgroundColor = c.hex;
        d.callback && d.callback(c.hex, {h:d.h - hueOffset, s:d.s, v:d.v}, {r:c.r, g:c.g, b:c.b}, u, b);
      };
    }
    function pickerListener(d, e) {
      return function(a) {
        a = a || s.event;
        var b = mousePosition(a), width = e.offsetWidth, height = e.offsetHeight;
        d.s = b.x / width;
        d.v = (height - b.y) / height;
        var c = hsv2rgb(d);
        d.callback && d.callback(c.hex, {h:d.h - hueOffset, s:d.s, v:d.v}, {r:c.r, g:c.g, b:c.b}, b);
      };
    }
    var x = 0;
    function ColorPicker(f, g, h) {
      if (!(this instanceof ColorPicker)) {
        return new ColorPicker(f, g, h);
      }
      this.h = 0;
      this.s = 1;
      this.v = 1;
      if (!h) {
        var i = f;
        i.innerHTML = w;
        this.slideElement = i.getElementsByClassName("slide")[0];
        this.pickerElement = i.getElementsByClassName("picker")[0];
        var j = i.getElementsByClassName("slide-indicator")[0];
        var k = i.getElementsByClassName("picker-indicator")[0];
        ColorPicker.fixIndicators(j, k);
        this.callback = function(a, b, c, d, e) {
          ColorPicker.positionIndicators(j, k, e, d);
          g(a, b, c);
        };
      } else {
        this.callback = h;
        this.pickerElement = g;
        this.slideElement = f;
      }
      if (v == "SVG") {
        var l = slide.cloneNode(true);
        var m = picker.cloneNode(true);
        var n = l.getElementById("gradient-hsv");
        var o = l.getElementsByTagName("rect")[0];
        n.id = "gradient-hsv-" + x;
        o.setAttribute("fill", "url(#" + n.id + ")");
        var p = [m.getElementById("gradient-black"), m.getElementById("gradient-white")];
        var q = m.getElementsByTagName("rect");
        p[0].id = "gradient-black-" + x;
        p[1].id = "gradient-white-" + x;
        q[0].setAttribute("fill", "url(#" + p[1].id + ")");
        q[1].setAttribute("fill", "url(#" + p[0].id + ")");
        this.slideElement.appendChild(l);
        this.pickerElement.appendChild(m);
        x++;
      } else {
        this.slideElement.innerHTML = slide;
        this.pickerElement.innerHTML = picker;
      }
      addEventListener(this.slideElement, "click", slideListener(this, this.slideElement, this.pickerElement));
      addEventListener(this.pickerElement, "click", pickerListener(this, this.pickerElement));
      enableDragging(this, this.slideElement, slideListener(this, this.slideElement, this.pickerElement));
      enableDragging(this, this.pickerElement, pickerListener(this, this.pickerElement));
    }
    function addEventListener(a, b, c) {
      if (a.attachEvent) {
        a.attachEvent("on" + b, c);
      } else {
        if (a.addEventListener) {
          a.addEventListener(b, c, false);
        }
      }
    }
    function enableDragging(b, c, d) {
      var e = false;
      addEventListener(c, "mousedown", function(a) {
        e = true;
      });
      addEventListener(c, "mouseup", function(a) {
        e = false;
      });
      addEventListener(c, "mouseout", function(a) {
        e = false;
      });
      addEventListener(c, "mousemove", function(a) {
        if (e) {
          d(a);
        }
      });
    }
    ColorPicker.hsv2rgb = function(a) {
      var b = hsv2rgb(a);
      delete b.hex;
      return b;
    };
    ColorPicker.hsv2hex = function(a) {
      return hsv2rgb(a).hex;
    };
    ColorPicker.rgb2hsv = rgb2hsv;
    ColorPicker.rgb2hex = function(a) {
      return hsv2rgb(rgb2hsv(a)).hex;
    };
    ColorPicker.hex2hsv = function(a) {
      return rgb2hsv(ColorPicker.hex2rgb(a));
    };
    ColorPicker.hex2rgb = function(a) {
      return{r:parseInt(a.substr(1, 2), 16), g:parseInt(a.substr(3, 2), 16), b:parseInt(a.substr(5, 2), 16)};
    };
    function setColor(a, b, d, e) {
      a.h = b.h % 360;
      a.s = b.s;
      a.v = b.v;
      var c = hsv2rgb(a);
      var f = {y:a.h * a.slideElement.offsetHeight / 360, x:0};
      var g = a.pickerElement.offsetHeight;
      var h = {x:a.s * a.pickerElement.offsetWidth, y:g - a.v * g};
      a.pickerElement.style.backgroundColor = hsv2rgb({h:a.h, s:1, v:1}).hex;
      a.callback && a.callback(e || c.hex, {h:a.h, s:a.s, v:a.v}, d || {r:c.r, g:c.g, b:c.b}, h, f);
      return a;
    }
    ColorPicker.prototype.setHsv = function(a) {
      return setColor(this, a);
    };
    ColorPicker.prototype.setRgb = function(a) {
      return setColor(this, rgb2hsv(a), a);
    };
    ColorPicker.prototype.setHex = function(a) {
      return setColor(this, ColorPicker.hex2hsv(a), u, a);
    };
    ColorPicker.positionIndicators = function(a, b, c, d) {
      if (c) {
        b.style.left = "auto";
        b.style.right = "0px";
        b.style.top = "0px";
        a.style.top = c.y - a.offsetHeight / 2 + "px";
      }
      if (d) {
        b.style.top = d.y - b.offsetHeight / 2 + "px";
        b.style.left = d.x - b.offsetWidth / 2 + "px";
      }
    };
    ColorPicker.fixIndicators = function(a, b) {
      b.style.pointerEvents = "none";
      a.style.pointerEvents = "none";
    };
    s.ColorPicker = ColorPicker;
  })(window, window.document);
}
;AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.ContextMenu = function(viewer) {
  this.viewer = viewer;
  this.menus = [];
  this.open = false;
  this.itemWidth = 100;
  this.itemHeight = 25;
};
Autodesk.Viewing.Private.ContextMenu.prototype.constructor = Autodesk.Viewing.Private.ContextMenu;
Autodesk.Viewing.Private.ContextMenu.prototype.show = function(event, menu) {
  var viewport = this.viewer.api.container.getBoundingClientRect();
  var x = event.clientX - viewport.left;
  var y = event.clientY - viewport.top;
  if (this.open == false) {
    var self = this;
    this.showMenu(menu, 0, x, y);
    this.open = true;
    this.hideEventListener = function(event) {
      if (event.target.className != "menuItem") {
        self.hide(event);
      }
    };
    document.body.addEventListener("mousedown", this.hideEventListener, true);
  }
};
Autodesk.Viewing.Private.ContextMenu.prototype.showMenu = function(menu, level, x, y) {
  if (x < 0) {
    x = 0;
  }
  if (y < 0) {
    y = 0;
  }
  if (x + this.itemWidth + 10 > this.viewer.canvas.width) {
    x = this.viewer.canvas.width - this.itemWidth - 10;
  }
  if (y + Object.keys(menu).length * this.itemHeight > this.viewer.canvas.height) {
    y = this.viewer.canvas.height - Object.keys(menu).length * this.itemHeight;
  }
  var menuHtml = document.createElement("div");
  menuHtml.width = this.itemWidth;
  menuHtml.className = "menu";
  menuHtml.style.top = y + "px";
  menuHtml.style.left = x + "px";
  menuHtml.style.zIndex = 10;
  this.viewer.api.container.appendChild(menuHtml);
  var top = 0;
  for (var item in menu) {
    var menuItem = this.createMenuItem(menuHtml, item, top);
    top = top + this.itemHeight;
    if (typeof menu[item] == "object") {
      this.addSubMenuClickToMenuItem(menuItem, level, menu[item], x + this.itemWidth + 10, y + top);
    } else {
      if (typeof menu[item] == "function") {
        this.addCallbackToMenuItem(menuItem, menu[item]);
      } else {
        console.warn("Invalid option", menu, item);
      }
    }
  }
  menuHtml.style.height = top + "px";
  if (this.menus[level] != null) {
    this.menus[level].parentNode.removeChild(this.menus[level]);
  }
  this.menus[level] = menuHtml;
};
Autodesk.Viewing.Private.ContextMenu.prototype.createMenuItem = function(menuHtml, text, top) {
  var menuItem = document.createElement("div");
  menuItem.className = "menuItem";
  menuItem.innerHTML = text;
  menuHtml.appendChild(menuItem);
  return menuItem;
};
Autodesk.Viewing.Private.ContextMenu.prototype.addSubMenuClickToMenuItem = function(menuItem, level, subMenu, x, y) {
  var self = this;
  menuItem.addEventListener("click", function() {
    self.showMenu(subMenu, level + 1, x, y);
  });
};
Autodesk.Viewing.Private.ContextMenu.prototype.addCallbackToMenuItem = function(menuItem, callback) {
  var self = this;
  menuItem.addEventListener("click", function(event) {
    self.hide();
    callback();
    event.preventDefault();
    return false;
  });
};
Autodesk.Viewing.Private.ContextMenu.prototype.hide = function() {
  if (this.open) {
    for (var index = 0;index < this.menus.length;++index) {
      if (this.menus[index]) {
        this.menus[index].parentNode.removeChild(this.menus[index]);
      }
    }
    this.menus = [];
    this.open = false;
    document.body.removeEventListener("mousedown", this.hideEventListener);
    return true;
  }
  return false;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.ObjectContextMenu = function(viewerImpl) {
  this.viewerImpl = viewerImpl;
  this.contextMenu = new Autodesk.Viewing.Private.ContextMenu(viewerImpl);
};
Autodesk.Viewing.Private.ObjectContextMenu.prototype.constructor = Autodesk.Viewing.Private.ObjectContextMenu;
Autodesk.Viewing.Private.ObjectContextMenu.prototype.show = function(event) {
  var self = this;
  var menu = {};
  var numSelected = self.viewerImpl.selector.selectedObjects.length;
  var hasVisible = false;
  var hasHidden = false;
  for (var i = 0;i < numSelected;i++) {
    var node = self.viewerImpl.selector.selectedObjects[i];
    if (Autodesk.Viewing.Private.VisibilityManager.isVisible(node)) {
      hasVisible = true;
    } else {
      hasHidden = true;
    }
    if (hasVisible && hasHidden) {
      break;
    }
  }
  if (numSelected > 0) {
    menu["Isolate"] = function() {
      var selected = self.viewerImpl.selector.getSelection();
      self.viewerImpl.selector.clearSelection();
      self.viewerImpl.visibilityManager.isolateMultiple(selected);
    };
    if (hasVisible) {
      menu["Hide Selected"] = function() {
        var selected = self.viewerImpl.selector.getSelection();
        self.viewerImpl.selector.clearSelection();
        self.viewerImpl.visibilityManager.hideMultiple(selected);
      };
    }
    if (hasHidden) {
      menu["Show Selected"] = function() {
        var selected = self.viewerImpl.selector.getSelection();
        self.viewerImpl.selector.clearSelection();
        self.viewerImpl.visibilityManager.showMultiple(selected);
      };
    }
  }
  menu["Show All"] = function() {
    self.viewerImpl.visibilityManager.isolate(null);
  };
  if (numSelected > 0) {
    menu["Focus"] = function() {
      self.viewerImpl.api.fitToView();
    };
  }
  this.contextMenu.show(event, menu);
  return false;
};
Autodesk.Viewing.Private.ObjectContextMenu.prototype.hide = function() {
  return this.contextMenu.hide();
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.RenderOptionsPanel = function(viewer) {
  var self = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "RenderOptionsPanel", "Rendering Options", {shadow:true});
  this.table = document.createElement("table");
  this.table.className = "tftable";
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  this.scrollpanel = this.createScrollContainer({heightAdjustment:70});
  this.scrollpanel.style.marginTop = "20px";
  this.container.appendChild(this.scrollpanel);
  this.scrollpanel.appendChild(this.table);
  this.container.style.width = "364px";
  this.container.style.top = "260px";
  this.container.style.left = "220px";
  this.container.style.height = "500px";
  this.container.dockRight = true;
  var color_list = [];
  for (var p in viewer.BackgroundPresets) {
    color_list.push(p);
  }
  this.bgSelect = new Autodesk.Viewing.Private.OptionDropDown("Background Color", this.tbody, color_list, -1);
  this.updateBgColorIndex();
  this.bgSelect.addEventListener("change", function(e) {
    var chosen = self.bgSelect.value;
    var c = viewer.BackgroundPresets[chosen];
    viewer.prefs.set("backgroundColorPreset", JSON.stringify(c));
    viewer.impl.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5]);
  });
  this.saoToggle = new Autodesk.Viewing.Private.OptionCheckbox("AO Enabled:", this.tbody, true);
  this.saoToggle.addEventListener("change", function(e) {
    var enable = self.saoToggle.checked;
    viewer.prefs.set("ambientShadows", enable);
    viewer.setQualityLevel(enable, viewer.impl.renderer.settings.antialias);
  });
  this.saoRadius = new Autodesk.Viewing.Private.OptionSlider("AO Radius", 0, 100, this.tbody);
  this.saoRadius.setValue(10);
  this.saoRadius.sliderElement.step = this.saoRadius.stepperElement.step = 1;
  this.saoRadius.addEventListener("change", function(e) {
    viewer.impl.renderer.setAOOptions(self.saoRadius.value, self.saoIntensity.value);
    viewer.impl.renderer.composeFinalFrame(false);
  });
  this.saoIntensity = new Autodesk.Viewing.Private.OptionSlider("AO Intensity", 0, 3, this.tbody);
  this.saoIntensity.setValue(0.75);
  this.saoIntensity.sliderElement.step = this.saoIntensity.stepperElement.step = 0.1;
  this.saoIntensity.addEventListener("change", function(e) {
    viewer.impl.renderer.setAOOptions(self.saoRadius.value, self.saoIntensity.value);
    viewer.impl.renderer.composeFinalFrame(false);
  });
  var env_list = [];
  for (var i = 0;i < viewer.impl.LightPresets.length;i++) {
    env_list.push(viewer.impl.LightPresets[i].name);
  }
  this.envSelect = new Autodesk.Viewing.Private.OptionDropDown("Environment Light", this.tbody, env_list, viewer.impl.currentLightPreset);
  this.envSelect.addEventListener("change", function(e) {
    var chosen = self.envSelect.selectedIndex;
    viewer.prefs.set("lightPreset", chosen);
    viewer.impl.setLightPreset(chosen);
  });
  var initialTonemapMethod = viewer.impl.renderer.getToneMapMethod();
  this.toneMapMethod = new Autodesk.Viewing.Private.OptionDropDown("Tonemap method", this.tbody, ["None", "Linear", "Reinhard", "Filmic", "Exp", "Canon"], initialTonemapMethod);
  this.toneMapMethod.addEventListener("change", function(e) {
    var oldMethod = viewer.impl.renderer.getToneMapMethod();
    var method = self.toneMapMethod.selectedIndex;
    viewer.impl.renderer.setTonemapMethod(method);
    if (method == 0 && oldMethod != 0 || oldMethod == 0 && method != 0) {
      var gammaPreset;
      if (method == 0) {
        gammaPreset = 1;
      } else {
        gammaPreset = 1.7;
      }
      self.gamma.setValue(gammaPreset);
      viewer.impl.renderer.setGamma(gammaPreset);
    }
    viewer.impl.fireRenderOptionChanged();
    viewer.impl.needsClear = true;
  });
  this.gamma = new Autodesk.Viewing.Private.OptionSlider("Gamma", 0, 5, this.tbody);
  this.gamma.setValue(viewer.impl.renderer.getGamma());
  this.gamma.sliderElement.step = this.gamma.stepperElement.step = 0.05;
  this.gamma.addEventListener("change", function(e) {
    viewer.impl.renderer.setGamma(self.gamma.value);
    viewer.impl.renderer.composeFinalFrame(false);
  });
  this.gamma.setDisabled(initialTonemapMethod == 0);
  this.exposureBias = new Autodesk.Viewing.Private.OptionSlider("Exposure bias", -30, 30, this.tbody);
  this.exposureBias.setValue(viewer.impl.renderer.getExposureBias());
  this.exposureBias.sliderElement.step = this.exposureBias.stepperElement.step = 0.1;
  this.exposureBias.addEventListener("change", function(e) {
    viewer.impl.renderer.setExposureBias(self.exposureBias.value, self.whiteScale.value);
    viewer.impl.needsClear = true;
  });
  this.exposureBias.setDisabled(initialTonemapMethod == 0);
  this.whiteScale = new Autodesk.Viewing.Private.OptionSlider("White Point Intensity", -5, 20, this.tbody);
  var intensity = 0;
  if (viewer.impl.dir_light1) {
    if (viewer.impl.dir_light1.intensity != 0) {
      intensity = Math.log(viewer.impl.dir_light1.intensity) / Math.log(2);
    } else {
      intensity = -1E-20;
    }
  }
  this.whiteScale.setValue(intensity);
  this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = 0.1;
  this.whiteScale.addEventListener("change", function(e) {
    viewer.impl.dir_light1.intensity = Math.pow(2, self.whiteScale.value);
    viewer.impl.renderer.setExposureBias(self.exposureBias.value, self.whiteScale.value);
    viewer.impl.needsClear = true;
  });
  this.fovAngle = new Autodesk.Viewing.Private.OptionSlider("Field of View (degrees)", 6.88, 100, this.tbody);
  this.fovAngle.setValue(viewer.getFOV());
  this.fovAngle.addEventListener("change", function(e) {
    viewer.setFOV(parseFloat(self.fovAngle.value));
  });
  this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
    var myFov = parseFloat(self.fovAngle.value);
    var camFov = viewer.getFOV();
    if (myFov != camFov) {
      self.fovAngle.setValue(camFov);
    }
  });
  this.viewer.addEventListener(Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, function(e) {
    self.syncUI();
  });
};
Autodesk.Viewing.Private.RenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.constructor = Autodesk.Viewing.Private.RenderOptionsPanel;
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.updateBgColorIndex = function() {
  var viewer = this.viewer.impl;
  var ctop = viewer.clearColorTop;
  var cbot = viewer.clearColorBottom;
  var current_color = [ctop.x * 255 | 0, ctop.y * 255 | 0, ctop.z * 255 | 0, cbot.x * 255 | 0, cbot.y * 255 | 0, cbot.z * 255 | 0];
  var color_name;
  for (var p in viewer.BackgroundPresets) {
    var c = viewer.BackgroundPresets[p];
    var j;
    for (j = 0;j < 6;j++) {
      if (c[j] != current_color[j]) {
        break;
      }
    }
    if (j == 6) {
      color_name = p;
      break;
    }
  }
  if (!color_name) {
    color_name = "Custom";
    var custom_color_arr = viewer.BackgroundPresets[color_name];
    for (var i = 0;i < 6;i++) {
      custom_color_arr[i] = current_color[i];
    }
  }
  this.bgSelect.setSelectedValue(color_name);
};
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.syncUI = function() {
  var impl = this.viewer.impl;
  var intensity = 0;
  if (impl.dir_light1) {
    if (impl.dir_light1.intensity != 0) {
      intensity = Math.log(impl.dir_light1.intensity) / Math.log(2);
    } else {
      intensity = -1E-20;
    }
  }
  this.whiteScale.setValue(intensity);
  this.exposureBias.setValue(impl.renderer.getExposureBias());
  this.gamma.setValue(impl.renderer.getGamma());
  this.updateBgColorIndex();
  var method = impl.renderer.getToneMapMethod();
  this.toneMapMethod.setSelectedIndex(method);
  this.envSelect.setSelectedIndex(impl.currentLightPreset);
  this.gamma.setDisabled(method == 0);
  this.exposureBias.setDisabled(method == 0);
  this.saoToggle.setValue(impl.renderer.settings.sao);
  this.saoRadius.setDisabled(!impl.renderer.settings.sao);
  this.saoIntensity.setDisabled(!impl.renderer.settings.sao);
};
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  this.closer = null;
  this.title = null;
  this.viewer = null;
  this.table = null;
  this.tbody = null;
  this.bgSelect = null;
  this.saoToggle = null;
  this.saoRadius = null;
  this.saoIntensity = null;
  this.envSelect = null;
  this.toneMapMethod = null;
  this.gamma = null;
  this.exposureBias = null;
  this.whiteScale = null;
  this.fovAngle = null;
  this.viewer = null;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.LayersPanel = function(viewer) {
  var self = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "LayersPanel", "Layer Manager", {shadow:true});
  this.table = document.createElement("table");
  this.table.className = "tftable";
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);
  this.scrollpanel = this.createScrollContainer({heightAdjustment:50});
  this.container.appendChild(this.scrollpanel);
  this.scrollpanel.appendChild(this.table);
  this.container.style.width = "300px";
  this.container.style.top = "180px";
  this.container.style.left = "220px";
  this.container.style.height = "460px";
  this.container.dockRight = true;
  this.container.style.display = "none";
  this.viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function() {
    self.syncUI();
  });
};
Autodesk.Viewing.Private.LayersPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.LayersPanel.prototype.constructor = Autodesk.Viewing.Private.LayersPanel;
Autodesk.Viewing.Private.LayersPanel.prototype.syncUI = function() {
  this.tbody.innerHTML = "";
  if (this.viewer.model && this.viewer.model) {
    this.layerCheckboxes = [];
    var layers = this.viewer.model.getLayersList();
    if (layers) {
      var self = this;
      for (var i = 0;i < layers.length;i++) {
        var caption = layers[i].name || "Layer " + layers[i].index;
        var cb = this.layerCheckboxes[i] = new Autodesk.Viewing.Private.OptionCheckbox(caption, this.tbody, true);
        cb.layer = layers[i].index;
        cb.addEventListener("change", function(e) {
          self.viewer.impl.toggleLayerVisibility(e.detail.target.layer, e.detail.target.checked);
        }, false);
      }
    }
  }
};
Autodesk.Viewing.Private.LayersPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
  this.closer = null;
  this.title = null;
  this.viewer = null;
  this.table = null;
  this.tbody = null;
  this.scrollpanel = null;
  this.viewer = null;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.NavigationTab = 1;
Autodesk.Viewing.Private.PerformanceTab = 2;
Autodesk.Viewing.Private.Viewer3dSettingsPanel = function(viewer) {
  var self = this;
  this.viewer = viewer;
  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, "Viewer3dSettingsPanel", "Settings", {shadow:true});
  this.container.style.minWidth = "425px";
  this.container.style.maxWidth = "800px";
  this.container.style.height = "385px";
  this.container.style.top = "200px";
  this.container.style.left = "220px";
  this.container.style.resize = "none";
  this.container.style.position = "absolute";
  this.container.dockRight = true;
  this.main = document.createElement("div");
  this.main.className = "viewer-tabs";
  this.container.appendChild(this.main);
  this.tabs = document.createElement("ul");
  this.tab1 = document.createElement("li");
  this.tab1.id = "navigationtab";
  this.tab2 = document.createElement("li");
  this.tab2.id = "performancetab";
  var title1 = document.createElement("a");
  var span1 = document.createElement("span");
  span1.innerHTML = "Navigation & selection";
  title1.appendChild(span1);
  var title2 = document.createElement("a");
  var span2 = document.createElement("span");
  span2.innerHTML = "Performance & appearance";
  title2.appendChild(span2);
  this.tab1.appendChild(title1);
  this.tab2.appendChild(title2);
  this.tabs.appendChild(this.tab1);
  this.tabs.appendChild(this.tab2);
  this.main.appendChild(this.tabs);
  this.table1 = document.createElement("table");
  this.table1.className = "viewer-table tftable";
  this.tbody1 = document.createElement("tbody");
  this.table1.appendChild(this.tbody1);
  this.table2 = document.createElement("table");
  this.table2.className = "viewer-table tftable";
  this.tbody2 = document.createElement("tbody");
  this.table2.appendChild(this.tbody2);
  this.container.appendChild(this.table1);
  this.container.appendChild(this.table2);
  var div = document.createElement("div");
  div.className = "viewer-restore-defaults";
  var label = document.createElement("label");
  label.textContent = "Restore defaults";
  div.appendChild(label);
  div.addEventListener("click", function() {
    viewer.prefs.reset();
  }, false);
  this.container.appendChild(div);
  this.mouseOver = false;
  this.selectTab(Autodesk.Viewing.Private.NavigationTab);
  var viewerSettings = this;
  this.tab1.addEventListener("click", function(e) {
    viewerSettings.selectTab(Autodesk.Viewing.Private.NavigationTab);
  });
  this.tab2.addEventListener("click", function(e) {
    viewerSettings.selectTab(Autodesk.Viewing.Private.PerformanceTab);
  });
  this.createNavigationPanel(this.tbody1);
  this.createPerformancePanel(this.tbody2);
  this.container.addEventListener("mouseover", function(event) {
    var e = event.toElement || event.relatedTarget;
    if (viewerSettings.mouseOver) {
      return true;
    }
    while (e && (e.parentNode && e.parentNode != window)) {
      if (e.parentNode == this || e == this) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        viewerSettings.mouseOver = true;
        Autodesk.Viewing.Private.removeClass(viewerSettings.tab1, "selectedmouseout");
        Autodesk.Viewing.Private.removeClass(viewerSettings.tab2, "selectedmouseout");
        return true;
      }
      e = e.parentNode;
    }
  });
  this.container.addEventListener("mouseout", function(event) {
    var e = event.toElement || event.relatedTarget;
    if (!viewerSettings.mouseOver) {
      return;
    }
    while (e && (e.parentNode && e.parentNode != window)) {
      if (e.parentNode == this || e == this) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        return false;
      }
      e = e.parentNode;
    }
    viewerSettings.mouseOver = false;
    var selectedTab = Autodesk.Viewing.Private.hasClass(viewerSettings.tab1, "tabselected") ? viewerSettings.tab1 : viewerSettings.tab2;
    Autodesk.Viewing.Private.addClass(selectedTab, "selectedmouseout");
  });
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.constructor = Autodesk.Viewing.Private.Viewer3dSettingsPanel;
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.uninitialize = function() {
  this.container.parentNode.removeChild(this.container);
  this.container = null;
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.setVisible = function(show) {
  if (show) {
    this.container.style.display = "block";
  }
  Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call(this, show);
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.selectTab = function(tab) {
  if (tab === Autodesk.Viewing.Private.NavigationTab) {
    this.table1.style.display = "table";
    this.table2.style.display = "none";
    Autodesk.Viewing.Private.addClass(this.tab1, "tabselected");
    Autodesk.Viewing.Private.removeClass(this.tab2, "tabselected");
    if (!this.mouseOver) {
      Autodesk.Viewing.Private.addClass(this.tab1, "selectedmouseout");
      Autodesk.Viewing.Private.removeClass(this.tab2, "selectedmouseout");
    }
    this.container.style.height = "385px";
  } else {
    if (tab === Autodesk.Viewing.Private.PerformanceTab) {
      this.table1.style.display = "none";
      this.table2.style.display = "table";
      Autodesk.Viewing.Private.addClass(this.tab2, "tabselected");
      Autodesk.Viewing.Private.removeClass(this.tab1, "tabselected");
      if (!this.mouseOver) {
        Autodesk.Viewing.Private.addClass(this.tab2, "selectedmouseout");
        Autodesk.Viewing.Private.removeClass(this.tab1, "selectedmouseout");
      }
      this.container.style.height = "295px";
    }
  }
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.addOptionCheckbox = function(tooltip, parent, initialState, onchange, saveKey) {
  var viewer = this.viewer;
  var storedState = viewer.prefs.values[saveKey];
  initialState = storedState !== null ? storedState : initialState;
  var checkBoxElem = new Autodesk.Viewing.Private.OptionCheckbox(tooltip, parent, initialState);
  checkBoxElem.addEventListener("change", function(e) {
    var checked = e.detail.target.checked;
    viewer.prefs.set(saveKey, checked);
    onchange(checked);
  });
  viewer.prefs.addResetListener(saveKey, function(value) {
    checkBoxElem.setValue(value);
    onchange(value);
  });
  return checkBoxElem;
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.createNavigationPanel = function(tbody) {
  var viewer = this.viewer;
  this.viewcube = this.addOptionCheckbox("Show ViewCube", tbody, true, function(checked) {
    viewer.displayViewCube(checked);
  }, "viewCube");
  this.viewcubeonpivot = this.addOptionCheckbox("ViewCube acts on pivot", tbody, false, function(checked) {
    viewer.navigation.setUsePivotAlways(checked);
  }, "alwaysUsePivot");
  this.reverse = this.addOptionCheckbox("Reverse mouse zoom direction", tbody, false, function(checked) {
    viewer.navigation.setReverseZoomDirection(checked);
  }, "reverseMouseZoomDir");
  this.zoom = this.addOptionCheckbox("Zoom towards pivot", tbody, false, function(checked) {
    viewer.navigation.setZoomTowardsPivot(checked);
  }, "zoomTowardsPivot");
  this.orbit = this.addOptionCheckbox("Orbit past world poles", tbody, true, function(checked) {
    viewer.navigation.setOrbitPastWorldPoles(checked);
  }, "orbitPastWorldPoles");
  this.setpivot = this.addOptionCheckbox("Set pivot with left mouse button", tbody, false, function(checked) {
    viewer.setClickToSetCOI(checked);
  }, "clickToSetCOI");
  this.propertiesOnSelect = this.addOptionCheckbox("Open properties on select", tbody, true, function(checked) {
    viewer.setPropertiesOnSelect(checked);
  }, "openPropertiesOnSelect");
  this.leftHanded = this.addOptionCheckbox("Left handed mouse setup", tbody, false, function(checked) {
    viewer.navigation.setUseLeftHandedInput(checked);
  }, "leftHandedMouseSetup");
};
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.createPerformancePanel = function(tbody) {
  var viewer = this.viewer;
  this.ghosthidden = this.addOptionCheckbox("Ghost hidden objects", tbody, true, function(checked) {
    viewer.setGhosting(checked);
  }, "ghosting");
  this.optimizeNavigation = this.addOptionCheckbox("Smooth navigation", tbody, false, function(checked) {
    viewer.setOptimizeNavigation(checked);
  }, "optimizeNavigation");
  this.ambientshadows = this.addOptionCheckbox("Ambient shadows", tbody, true, function(checked) {
    viewer.setQualityLevel(checked, viewer.prefs.values.antialiasing);
  }, "ambientShadows");
  this.antialiasing = this.addOptionCheckbox("Anti-aliasing", tbody, true, function(checked) {
    viewer.setQualityLevel(viewer.prefs.values.ambientShadows, checked);
  }, "antialiasing");
  this.progressiveRender = this.addOptionCheckbox("Progressive model display", tbody, true, function(checked) {
    viewer.setProgressiveRendering(checked);
  }, "progressiveRendering");
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.AlertBox = function() {
};
Autodesk.Viewing.Private.AlertBox.instances = [];
Autodesk.Viewing.Private.AlertBox.displayError = function(container, msg, title, imgPath, htmlContent) {
  var alertBox = document.createElement("div");
  alertBox.className = "alertBox error";
  container.appendChild(alertBox);
  var errorImagePath = imgPath;
  if (!errorImagePath) {
    errorImagePath = RESOURCE_ROOT + "icons/error_item_not_found.png";
  }
  var alertBoxImg = document.createElement("img");
  alertBoxImg.className = "alertBoxImage";
  alertBoxImg.src = errorImagePath;
  alertBox.appendChild(alertBoxImg);
  var alertBoxMsg = document.createElement("div");
  alertBoxMsg.className = "alertBoxMsg";
  alertBox.appendChild(alertBoxMsg);
  var errorTitle = title;
  if (!errorTitle) {
    errorTitle = "Error Occurred";
  }
  var alertBoxTitle = document.createElement("div");
  alertBoxTitle.className = "alertBoxTitle";
  alertBoxTitle.textContent = errorTitle;
  alertBoxMsg.appendChild(alertBoxTitle);
  var alertBoxText = document.createElement("div");
  alertBoxText.className = "alertBoxText";
  alertBoxText.textContent = msg;
  alertBoxMsg.appendChild(alertBoxText);
  if (htmlContent) {
    var content = document.createElement("div");
    content.className = "alertBoxContent";
    content.appendChild(htmlContent);
    alertBoxMsg.appendChild(content);
  }
  var alertBoxOK = document.createElement("div");
  alertBoxOK.className = "alertBoxOK";
  alertBoxOK.textContent = "OK";
  var instance = {alertBox:alertBox, container:container};
  alertBoxOK.addEventListener("click", function(event) {
    alertBox.style.visibility = "hidden";
    container.removeChild(alertBox);
    Autodesk.Viewing.Private.AlertBox.instances.splice(Autodesk.Viewing.Private.AlertBox.instances.indexOf(instance), 1);
  });
  alertBox.appendChild(alertBoxOK);
  alertBox.style.visibility = "visible";
  Autodesk.Viewing.Private.AlertBox.instances.push(instance);
};
Autodesk.Viewing.Private.AlertBox.dismiss = function() {
  if (Autodesk.Viewing.Private.AlertBox.instances.length > 0) {
    var instance = Autodesk.Viewing.Private.AlertBox.instances.pop();
    instance.alertBox.style.visibility = "hidden";
    instance.container.removeChild(instance.alertBox);
    return true;
  }
  return false;
};
AutodeskNamespace("Autodesk.Viewing.UI");
Autodesk.Viewing.UI.TreeDelegate = function() {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.constructor = Autodesk.Viewing.UI.TreeDelegate;
Autodesk.Viewing.UI.TreeDelegate.prototype.isTreeNodeGroup = function(node) {
  throw "isTreeNodeGroup is not implemented.";
};
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeId = function(node) {
  throw "getTreeNodeId is not implemented.";
};
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeLabel = function(node) {
  return node.name;
};
Autodesk.Viewing.UI.TreeDelegate.prototype.shouldCreateTreeNode = function(node) {
  return true;
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeClick = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeDoubleClick = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeRightClick = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeEnter = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeLeave = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeHover = function(tree, node, event) {
};
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeClass = function(node) {
  return "";
};
Autodesk.Viewing.UI.Tree = function(delegate, root, parentContainer, options) {
  this.myDelegate = delegate;
  this.mySelectedIds = [];
  this.myOptions = options;
  var parentContainerId;
  if (typeof parentContainer === "string") {
    parentContainerId = parentContainer;
    parentContainer = document.getElementById(parentContainerId);
  } else {
    parentContainerId = parentContainer.id;
  }
  var className = "treeview";
  this.myRootContainerId = parentContainerId + "-" + className;
  this.myInternalIds = [];
  this.myInternalIdCounter = 0;
  this.myGroupNodes = [];
  var rootContainer = this.createHtmlElement_(parentContainer, "div", this.myRootContainerId, className);
  this.createElement_(root, rootContainer);
};
Autodesk.Viewing.UI.Tree.prototype.constructor = Autodesk.Viewing.UI.Tree;
Autodesk.Viewing.UI.Tree.prototype.show = function(show) {
  var rootContainer = document.getElementById(this.myRootContainerId);
  if (show) {
    rootContainer.style.display = "block";
  } else {
    rootContainer.style.display = "none";
  }
};
Autodesk.Viewing.UI.Tree.prototype.getRootContainerId = function() {
  return this.myRootContainerId;
};
Autodesk.Viewing.UI.Tree.prototype.delegate = function() {
  return this.myDelegate;
};
Autodesk.Viewing.UI.Tree.prototype.isCollapsed = function(groupId) {
  return this.hasClass(groupId, "collapsed");
};
Autodesk.Viewing.UI.Tree.prototype.setCollapsed = function(groupId, collapsed) {
  var isCollapsed = this.isCollapsed(groupId);
  if (collapsed) {
    if (!isCollapsed) {
      this.addClass(groupId, "collapsed");
      this.removeClass(groupId, "expanded");
      return true;
    }
  } else {
    if (isCollapsed) {
      this.addClass(groupId, "expanded");
      this.removeClass(groupId, "collapsed");
      return true;
    }
  }
  return false;
};
Autodesk.Viewing.UI.Tree.prototype.setAllCollapsed = function(collapsed) {
  var wantNode, changeNode;
  if (collapsed) {
    wantNode = function(node) {
      return Autodesk.Viewing.Private.hasClass(node, "expanded");
    };
    changeNode = function(node) {
      Autodesk.Viewing.Private.addClass(node, "collapsed");
      Autodesk.Viewing.Private.removeClass(node, "expanded");
    };
  } else {
    wantNode = function(node) {
      return Autodesk.Viewing.Private.hasClass(node, "collapsed");
    };
    changeNode = function(node) {
      Autodesk.Viewing.Private.addClass(node, "expanded");
      Autodesk.Viewing.Private.removeClass(node, "collapsed");
    };
  }
  for (var i = 0;i < this.myGroupNodes.length;++i) {
    var node = this.myGroupNodes[i];
    if (wantNode(node)) {
      changeNode(node);
    }
  }
};
Autodesk.Viewing.UI.Tree.prototype.addToSelection = function(ids) {
  var tree = this;
  function addSingle(id) {
    var index = tree.mySelectedIds.indexOf(id);
    if (index === -1) {
      tree.mySelectedIds.push(id);
      return true;
    }
    return false;
  }
  var numIds = ids.length;
  for (var i = 0;i < numIds;++i) {
    var id = ids[i];
    if (addSingle(id)) {
      this.addClass(id, "selected");
    }
  }
};
Autodesk.Viewing.UI.Tree.prototype.removeFromSelection = function(ids) {
  var tree = this;
  function removeSingle(id) {
    var index = tree.mySelectedIds.indexOf(id);
    if (index !== -1) {
      tree.mySelectedIds.splice(index, 1);
      return true;
    }
    return false;
  }
  for (var i = ids.length - 1;i >= 0;--i) {
    var id = ids[i];
    if (removeSingle(id)) {
      this.removeClass(id, "selected");
    }
  }
};
Autodesk.Viewing.UI.Tree.prototype.setSelection = function(ids) {
  this.removeFromSelection(this.mySelectedIds);
  this.addToSelection(ids);
  return this.mySelectedIds;
};
Autodesk.Viewing.UI.Tree.prototype.clearSelection = function() {
  this.removeFromSelection(this.mySelectedIds);
};
Autodesk.Viewing.UI.Tree.prototype.isSelected = function(id) {
  return this.hasClass(id, "selected");
};
Autodesk.Viewing.UI.Tree.prototype.addClass = function(id, className) {
  var internalId = this.getInternalId_(id, false);
  if (internalId) {
    var elem = document.getElementById(internalId);
    Autodesk.Viewing.Private.addClass(elem, className);
  }
};
Autodesk.Viewing.UI.Tree.prototype.removeClass = function(id, className) {
  var internalId = this.getInternalId_(id, false);
  if (internalId) {
    var elem = document.getElementById(internalId);
    Autodesk.Viewing.Private.removeClass(elem, className);
  }
};
Autodesk.Viewing.UI.Tree.prototype.hasClass = function(id, className) {
  var internalId = this.getInternalId_(id, false);
  if (internalId) {
    var elem = document.getElementById(internalId);
    return Autodesk.Viewing.Private.hasClass(elem, className);
  }
  return false;
};
Autodesk.Viewing.UI.Tree.prototype.getInternalId_ = function(id, create) {
  if (this.myInternalIds[id] === undefined && create) {
    this.myInternalIds[id] = this.myRootContainerId + "-node-" + this.myInternalIdCounter;
    this.myInternalIdCounter++;
  }
  return this.myInternalIds[id];
};
Autodesk.Viewing.UI.Tree.prototype.createElement_ = function(node, parentElement) {
  if (!node) {
    return;
  }
  if (!this.myDelegate.shouldCreateTreeNode(node)) {
    return;
  }
  var tree = this;
  var id = tree.myDelegate.getTreeNodeId(node);
  var internalId = this.getInternalId_(id, true);
  var elem, header, icon, label;
  if (tree.myDelegate.isTreeNodeGroup(node)) {
    elem = tree.createHtmlElement_(parentElement, "group", internalId, "expanded");
    tree.myGroupNodes.push(elem);
    header = tree.createHtmlElement_(elem, "header", "header" + internalId);
    icon = tree.createHtmlElement_(header, "icon");
    icon.addEventListener("click", function(e) {
      Autodesk.Viewing.Private.toggleClass(elem, "collapsed");
      Autodesk.Viewing.Private.toggleClass(elem, "expanded");
      e.stopPropagation();
      e.preventDefault();
    }, false);
    label = tree.createHtmlElement_(header, "label");
    label.textContent = tree.myDelegate.getTreeNodeLabel(node);
    var childCount = node.children ? node.children.length : 0;
    for (var childIndex = 0;childIndex < childCount;++childIndex) {
      var child = node.children[childIndex];
      tree.createElement_(child, elem);
    }
  } else {
    elem = tree.createHtmlElement_(parentElement, "leaf", internalId);
    header = tree.createHtmlElement_(elem, "header", "header" + internalId);
    icon = tree.createHtmlElement_(header, "icon");
    label = tree.createHtmlElement_(header, "label");
    label.textContent = tree.myDelegate.getTreeNodeLabel(node);
  }
  elem.addEventListener("click", function(e) {
    tree.myDelegate.onTreeNodeClick(tree, node, e);
    e.stopPropagation();
    e.preventDefault();
  }, false);
  elem.addEventListener("dblclick", function(e) {
    tree.myDelegate.onTreeNodeDoubleClick(tree, node, e);
    e.stopPropagation();
    e.preventDefault();
  }, false);
  elem.addEventListener("contextmenu", function(e) {
    tree.myDelegate.onTreeNodeRightClick(tree, node, e);
    e.stopPropagation();
    e.preventDefault();
  }, false);
  function mouseenter(e) {
    tree.myDelegate.onTreeNodeEnter(tree, node, e);
    tree.myDelegate.onTreeNodeHover(tree, node, e);
    e.stopPropagation();
    e.preventDefault();
  }
  function mouseleave(e) {
    tree.myDelegate.onTreeNodeLeave(tree, node, e);
    tree.myDelegate.onTreeNodeHover(tree, node, e);
    e.stopPropagation();
    e.preventDefault();
  }
  elem.addEventListener("mouseenter", function(e) {
    mouseenter(e);
  }, false);
  elem.addEventListener("mouseleave", function(e) {
    mouseleave(e);
  }, false);
  elem.addEventListener("mouseover", function(e) {
    mouseenter(e);
  }, false);
  elem.addEventListener("mouseout", function(e) {
    mouseleave(e);
  }, false);
  Autodesk.Viewing.Private.addClass(elem, tree.myDelegate.getTreeNodeClass(node));
};
Autodesk.Viewing.UI.Tree.prototype.createHtmlElement_ = function(parent, tagName, id, className) {
  var elem = document.createElement(tagName);
  parent.appendChild(elem);
  if (id) {
    elem.id = id;
  }
  if (className) {
    elem.className = className;
  }
  return elem;
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.TreeDelegate = Autodesk.Viewing.UI.TreeDelegate;
Autodesk.Viewing.Private.TreeDelegate.prototype = Autodesk.Viewing.UI.TreeDelegate.prototype;
Autodesk.Viewing.Private.Tree = Autodesk.Viewing.UI.Tree;
Autodesk.Viewing.Private.Tree.prototype = Autodesk.Viewing.UI.Tree.prototype;
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.BrowserDelegate = function() {
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.constructor = Autodesk.Viewing.Private.BrowserDelegate;
Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeId = function(node) {
  throw "getId is not implemented.";
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeLabel = function(node) {
  return node.name;
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeClass = function(node) {
  return "";
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.hasThumbnail = function(node) {
  return false;
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.getThumbnail = function(node) {
  return null;
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.onNodeClick = function(browser, node, event) {
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.onNodeHover = function(browser, node, event) {
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.hasContent = function(node) {
  return false;
};
Autodesk.Viewing.Private.BrowserDelegate.prototype.addContent = function(node, parentId) {
};
Autodesk.Viewing.Private.Browser = function(delegate, items, parentContainerId, options) {
  this.myDelegate = delegate;
  this.mySelectedIds = [];
  this.myParentContainderId = parentContainerId;
  var prefix = "browserview";
  this.myRootContainerId = parentContainerId + "-" + prefix;
  this.myInternalIds = [];
  this.myInternalIdCounter = 0;
  this.myOptions = options;
  this.jQuery = options && options.jQuery ? options.jQuery : $;
  this.jQuery('<div id="' + this.myRootContainerId + '" class="' + prefix + '"></div>').appendTo("#" + this.myParentContainderId);
  this.createElements(items, this.myRootContainerId);
};
Autodesk.Viewing.Private.Browser.prototype.constructor = Autodesk.Viewing.Private.Browser;
Autodesk.Viewing.Private.Browser.prototype.show = function(show) {
  if (show) {
    this.jQuery("#" + this.myRootContainerId).fadeIn();
  } else {
    this.jQuery("#" + this.myRootContainerId).hide();
  }
};
Autodesk.Viewing.Private.Browser.prototype.getRootContainerId = function() {
  return this.myRootContainerId;
};
Autodesk.Viewing.Private.Browser.prototype.delegate = function() {
  return this.myDelegate;
};
Autodesk.Viewing.Private.Browser.prototype.addToSelection = function(ids) {
  var browser = this;
  function addSingle(id) {
    var index = browser.mySelectedIds.indexOf(id);
    if (index == -1) {
      browser.mySelectedIds.push(id);
      return true;
    }
    return false;
  }
  for (var index in ids) {
    var id = ids[index];
    if (addSingle(id)) {
      var internalId = this.getInternalId(id, false);
      this.jQuery("#" + internalId).addClass("selected");
    }
  }
};
Autodesk.Viewing.Private.Browser.prototype.removeFromSelection = function(ids) {
  var browser = this;
  function removeSingle(id) {
    var index = browser.mySelectedIds.indexOf(id);
    if (index != -1) {
      browser.mySelectedIds.splice(index, 1);
      return true;
    }
    return false;
  }
  for (var index in ids) {
    var id = ids[index];
    if (removeSingle(id)) {
      var internalId = this.getInternalId(id, false);
      this.jQuery("#" + internalId).removeClass("selected");
    }
  }
};
Autodesk.Viewing.Private.Browser.prototype.setSelection = function(ids) {
  this.removeFromSelection(this.mySelectedIds);
  this.addToSelection(ids);
  return this.mySelectedIds;
};
Autodesk.Viewing.Private.Browser.prototype.clearSelection = function() {
  this.removeFromSelection(this.mySelectedIds);
};
Autodesk.Viewing.Private.Browser.prototype.getInternalId = function(id, create) {
  if (this.myInternalIds[id] === undefined && create) {
    this.myInternalIds[id] = this.myRootContainerId + "-node-" + this.myInternalIdCounter;
    this.myInternalIdCounter++;
  }
  return this.myInternalIds[id];
};
Autodesk.Viewing.Private.Browser.prototype.createElements = function(items, containerId) {
  if (!items) {
    return;
  }
  var browser = this;
  for (var nodeIndex = 0;nodeIndex < items.length;nodeIndex++) {
    var node = items[nodeIndex];
    browser.createElement(node, containerId);
  }
};
Autodesk.Viewing.Private.Browser.prototype.createElement = function(browserNode, containerId) {
  var browser = this;
  var id = browser.myDelegate.getNodeId(browserNode);
  var internalId = browser.getInternalId(id, true);
  var elementId = "#" + internalId;
  this.jQuery('<item id="' + internalId + '"></item>').appendTo(this.jQuery("#" + containerId)).hover(function() {
    browser.myDelegate.onNodeHover(browser, browserNode);
  });
  this.jQuery("#" + internalId).click(function(e) {
    browser.jQuery(".flipped").removeClass("flipped");
    browser.myDelegate.onNodeClick(browser, browserNode, e);
  });
  var card = this.jQuery('<div id="card' + internalId + '" class="card"></div>');
  card.appendTo(this.jQuery(elementId));
  var elemWrapper = this.jQuery('<div class="browserElement"></div>');
  elemWrapper.appendTo(card);
  var label = browser.myDelegate.getNodeLabel(browserNode);
  this.jQuery("<label>" + label + "</label>").appendTo(elemWrapper).click(function(e) {
    browser.myDelegate.onNodeClick(browser, browserNode, e);
  });
  var thumbnailUrl = browser.myDelegate.getThumbnail(browserNode);
  if (thumbnailUrl) {
    this.jQuery('<img class="thumb" src="' + thumbnailUrl + '" ></img>').appendTo(elemWrapper).click(function(e) {
      browser.myDelegate.onNodeClick(browser, browserNode, e);
    });
  }
  if (browser.myDelegate.hasContent(browserNode)) {
    browser.myDelegate.addContent(browserNode, internalId);
  }
  this.jQuery(elementId).addClass(browser.myDelegate.getNodeClass(browserNode));
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.ErrorInfoData = {1:{"img":"icons/error_reload_in_viewer.png", "header":"Oops", "text":"Sorry. We seem to have some technical difficulties and couldn't complete your request.", "content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li>" + "</ul>"}, 2:{"img":"icons/error_unsupported_file_type.png", "header":"Oops", "text":"Sorry. The item you are trying to view was not processed completely.", 
"content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Please upload the file again to see if that fixes the issue.</li>" + "</ul>"}, 3:{"img":"icons/error_reload_in_viewer.png", "header":"Oops", "text":"Sorry. We seem to have some technical difficulties and couldn't complete your request.", "content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li>" + "</ul>"}, 4:{"img":"icons/error_unlock_upload.png", 
"header":"No access", "text":"Sorry. You don\u2019t have the required privileges to access this item.", "content":"<ul>" + "<li>Please contact the author.</li>" + "</ul>"}, 5:{"img":"icons/error_item_not_found.png", "header":"Oops", "text":"Sorry. We can\u2019t display the item you are looking for. It may not have been processed yet. It may have been moved, deleted, or you may be using a corrupt file or unsupported file format.", "content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Try uploading the file again to see if that fixes the issue.</li>" + 
'<li><a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-488804D0-B0B0-4413-8741-4F5EE0FACC4A" target="_blank">See a list of supported formats.</a></li>' + "</ul>"}, 6:{"img":"icons/error_reload_in_viewer.png", "header":"Oops", "text":"Sorry. We seem to have some technical difficulties and couldn't complete your request.", "content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li>" + 
"</ul>"}, 7:{"img":"icons/error_reload_in_viewer.png", "header":"Network problem", "text":"Sorry. We seem to have some technical difficulties and couldn't complete your request.", "content":"<ul>" + "<li>Try loading the item again.</li>" + "<li>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</li>" + "</ul>"}, 8:{"img":"icons/error_unsupported_file_type.png", "header":"Oops", "text":"Sorry. We couldn\u2019t show the item because your browser doesn\u2019t support 3D viewing.", 
"content":"<ul>" + "<li>Please use Google Chrome, Firefox or another browser that supports WebGL 3D graphics.</li>" + '<li><a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-6BD255B4-FB67-4909-9332-3A5905076E0A" target="_blank">See a list of browsers supporting WebGL 3D graphics.</a></li>' + "</ul>"}, 9:{"img":"icons/error_item_not_found.png", "header":"No viewable content", "text":"There\u2019s nothing to display for this item. It may not have been processed or it may not have content we can display.", 
"content":"<ul>" + "<li>Please contact the author.</li>" + "<li>Try uploading the file again to see if that fixes the issue.</li>" + "</ul>"}};
Autodesk.Viewing.Private.ErrorHandler = function() {
};
Autodesk.Viewing.Private.ErrorHandler.prototype.constructor = Autodesk.Viewing.Private.ErrorHandler;
Autodesk.Viewing.Private.ErrorHandler.reportError = function(container, errorCode, errorMsg) {
  var errorInfo = Autodesk.Viewing.Private.ErrorInfoData[errorCode];
  if (errorInfo) {
    var msg = errorInfo.text;
    var header = errorInfo.header;
    var img = RESOURCE_ROOT + errorInfo.img;
    var content = errorInfo.content;
    var contentDOM = null;
    if (content) {
      contentDOM = document.createElement("div");
      contentDOM.innerHTML = content;
    }
    Autodesk.Viewing.Private.AlertBox.displayError(container, msg, header, img, contentDOM);
  } else {
    Autodesk.Viewing.Private.AlertBox.displayError(container, errorMsg);
  }
};
Autodesk.Viewing.Private.ErrorHandler.getErrorCode = function(networkStatus) {
  if (networkStatus === 403 || networkStatus === 401) {
    return Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED;
  } else {
    if (networkStatus === 404) {
      return Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND;
    } else {
      if (networkStatus >= 500) {
        return Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR;
      }
    }
  }
  return Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE;
};
/*
 Copyright (c) 2014 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing.UI");
Autodesk.Viewing.UI.ToolBar = function(parentContainer) {
  this.parentContainer = parentContainer;
  this.container = document.createElement("div");
  this.container.className = "toolbar-menuplacer";
  this.menu = document.createElement("ul");
  this.menu.className = "toolbar-menu";
  this.container.appendChild(this.menu);
  this.parentContainer.appendChild(this.container);
  this.subToolbars = {};
};
Autodesk.Viewing.UI.ToolBar.prototype.constructor = Autodesk.Viewing.UI.ToolBar;
Autodesk.Viewing.UI.ToolBar.createMenuButton = function(id, tooltip, onclick) {
  var buttonGroup = document.createElement("li");
  buttonGroup.className = "toolbar-generic-button";
  buttonGroup.id = id;
  var tooltipElem = null;
  if (tooltip) {
    tooltipElem = document.createElement("div");
    tooltipElem.className = "toolbar-tooltip";
    tooltipElem.textContent = tooltip;
    tooltipElem.setAttribute("tooltipText", tooltip);
    buttonGroup.appendChild(tooltipElem);
  }
  var button = document.createElement("div");
  button.className = "toolbar-button";
  button.id = id + "Button";
  buttonGroup.appendChild(button);
  if (onclick) {
    buttonGroup.addEventListener("click", onclick);
  }
  if (tooltipElem) {
    buttonGroup.addEventListener("mouseover", function(e) {
      if (e.target == buttonGroup || e.target === button) {
        tooltipElem.style.visibility = "visible";
      }
    });
    buttonGroup.addEventListener("mouseout", function(e) {
      if (e.target === buttonGroup || e.target == button) {
        tooltipElem.style.visibility = "hidden";
      }
    });
  }
  return buttonGroup;
};
Autodesk.Viewing.UI.ToolBar.prototype.addSubToolbar = function(id, isRadio) {
  var subToolbar = new Autodesk.Viewing.UI.SubToolbar(this.menu, id, isRadio);
  this.subToolbars[id] = subToolbar;
  return subToolbar;
};
Autodesk.Viewing.UI.ToolBar.prototype.getSubToolbars = function() {
  return this.subToolbars;
};
Autodesk.Viewing.UI.ToolBar.prototype.getSubToolbarById = function(id) {
  if (id in this.subToolbars) {
    return this.subToolbars[id];
  }
  return null;
};
Autodesk.Viewing.UI.ToolBar.prototype.removeSubToolbar = function(id) {
  if (id in this.subToolbars) {
    var child = this.subToolbars[id];
    if (child) {
      this.menu.removeChild(child.subtoolbar);
      delete this.subToolbars[id];
    }
  }
};
Autodesk.Viewing.UI.ToolBar.prototype.removeAllSubToolbars = function() {
  while (this.menu.firstChild) {
    this.menu.removeChild(this.menu.firstChild);
  }
  this.subToolbars = {};
};
Autodesk.Viewing.UI.ToolBar.prototype.addToSubToolbar = function(id, item) {
  if (this.subToolbars[id]) {
    this.subToolbars[id].addTool(item);
  }
};
Autodesk.Viewing.UI.ToolBar.prototype.removeFromSubToolbar = function(id, item) {
  if (this.subToolbars[id]) {
    this.subToolbars[id].removeTool(item.id);
  }
};
Autodesk.Viewing.UI.ToolBar.prototype.attachSubMenu = function(parent, submenu) {
  parent.appendChild(submenu);
};
Autodesk.Viewing.UI.ToolBar.prototype.collapse = function(collapse) {
  if (collapse) {
    Autodesk.Viewing.Private.addClass(this.container, "toolbar-menu-collapsed");
  } else {
    Autodesk.Viewing.Private.removeClass(this.container, "toolbar-menu-collapsed");
  }
};
Autodesk.Viewing.UI.ToolBar.prototype.isCollapsed = function() {
  return Autodesk.Viewing.Private.hasClass(this.container, "toolbar-menu-collapsed");
};
Autodesk.Viewing.UI.ToolBar.prototype.addEventListener = function(eventName, action) {
  this.menu.addEventListener(eventName, action);
};
Autodesk.Viewing.UI.ToolBar.prototype.removeEventListener = function(eventName, action) {
  this.menu.removeEventListener(eventName, action);
};
Autodesk.Viewing.UI.SubToolbar = function(parentContainer, id, isRadio) {
  this.parentContainer = parentContainer;
  this.subtoolbar = document.createElement("div");
  this.subtoolbar.className = "toolbar-subtoolbar";
  this.subtoolbar.id = id;
  this.parentContainer.appendChild(this.subtoolbar);
  this.buttons = {};
  this.isRadio = isRadio;
};
Autodesk.Viewing.UI.SubToolbar.prototype.constructor = Autodesk.Viewing.SubToolbar;
Autodesk.Viewing.UI.SubToolbar.prototype.addTool = function(button) {
  this.buttons[button.id] = button;
  this.subtoolbar.appendChild(button);
};
Autodesk.Viewing.UI.SubToolbar.prototype.removeTool = function(id) {
  if (id in this.buttons) {
    var button = this.buttons[id];
    this.subtoolbar.removeChild(button);
    delete this.buttons[id];
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.getTool = function(id) {
  if (id in this.buttons) {
    return this.buttons[id];
  }
  return null;
};
Autodesk.Viewing.UI.SubToolbar.prototype.getToolCount = function() {
  if (this.subtoolbar.children) {
    return this.subtoolbar.children.length;
  }
  return 0;
};
Autodesk.Viewing.UI.SubToolbar.prototype.select = function(id) {
  if (id in this.buttons) {
    if (this.isRadio) {
      this.deselectAll();
    }
    var buttonGroup = this.buttons[id];
    var button = buttonGroup.childNodes[buttonGroup.childNodes.length - 1];
    Autodesk.Viewing.Private.removeClass(button, "disabled-button");
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.deselect = function(id) {
  if (id in this.buttons) {
    var buttonGroup = this.buttons[id];
    var button = buttonGroup.childNodes[buttonGroup.childNodes.length - 1];
    Autodesk.Viewing.Private.addClass(button, "disabled-button");
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.deselectAll = function() {
  for (var id in this.buttons) {
    if (this.buttons.hasOwnProperty(id)) {
      this.deselect(id);
    }
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.setToolVisibility = function(id, visible) {
  if (id in this.buttons) {
    if (visible) {
      this.buttons[id].style.display = "list-item";
    } else {
      this.buttons[id].style.display = "none";
    }
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.isToolVisible = function(id) {
  if (id in this.buttons) {
    return!(this.buttons[id].style.display && this.buttons[id].style.display === "none");
  }
  return false;
};
Autodesk.Viewing.UI.SubToolbar.prototype.setVisibility = function(visible) {
  if (visible) {
    this.subtoolbar.style.display = "";
  } else {
    this.subtoolbar.style.display = "none";
  }
};
Autodesk.Viewing.UI.SubToolbar.prototype.isVisible = function() {
  return!(this.subtoolbar.style.display && this.subtoolbar.style.display === "none");
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.GEOMETRY_LOADED_EVENT = "geometry_loaded";
Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT = "frag->node array created";
Autodesk.Viewing.SELECTION_CHANGED_EVENT = "selection";
Autodesk.Viewing.ISOLATE_EVENT = "isolate";
Autodesk.Viewing.HIDE_EVENT = "hide";
Autodesk.Viewing.SHOW_EVENT = "show";
Autodesk.Viewing.HIGHLIGHT_EVENT = "highlight";
Autodesk.Viewing.CAMERA_CHANGE_EVENT = "cameraChanged";
Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT = "renderOptionChanged";
Autodesk.Viewing.NAVIGATION_MODE = {ORBIT:0, PAN:1, DOLLY:2, ROLL:3, FOV:4, TOUCH_PAN_DOLLY:5, TOUCH_ROLL:6, OTHER:7};
Autodesk.Viewing.Viewer3D = function(container, config) {
  Autodesk.Viewing.Viewer.call(this, container, config);
  if (this.container.nodeName === "CANVAS") {
    throw "Viewer must be initialized on a div [temporary]";
  } else {
    this.canvas = document.createElement("canvas");
    this.canvas.tabIndex = 0;
    var dimensions = this.getDimensions();
    this.canvas.width = dimensions.width;
    this.canvas.height = dimensions.height;
    this.container.appendChild(this.canvas);
  }
  this.canvas.viewer = this;
  this.modelstructure = null;
  this.running = false;
};
Autodesk.Viewing.Viewer3D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.Viewer3D.prototype.constructor = Autodesk.Viewing.Viewer3D;
Autodesk.Viewing.Viewer3D.kDefaultCanvasConfig = {"click":{"onObject":["selectOnly"], "offObject":["deselectAll"]}, "clickAlt":{"onObject":["setCOI"], "offObject":["setCOI"]}, "clickCtrl":{"onObject":["selectToggle"], "offObject":["deselectAll"]}, "clickShift":{"onObject":["selectToggle"], "offObject":["deselectAll"]}, "clickCtrlShift":{"onObject":["deselectAll"], "offObject":["deselectAll"]}};
Autodesk.Viewing.Viewer3D.prototype.initialize = function() {
  var webGL = this.detectWebGL();
  if (webGL <= 0) {
    return Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED;
  }
  Autodesk.Viewing.Viewer.prototype.initialize.call(this);
  var self = this;
  this.impl = new Autodesk.Viewing.Private.Viewer3DImpl(this.canvas, this);
  this.model = null;
  this.navigation = new Autodesk.Viewing.Navigation(this.impl.camera);
  this.__initAutoCam();
  if (webGL == 4096) {
    return Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED;
  }
  var canvasConfig = this.config && this.config.canvasConfig ? this.config.canvasConfig : Autodesk.Viewing.Viewer3D.kDefaultCanvasConfig;
  this.setCanvasClickBehavior(canvasConfig);
  this.loader = document.createElement("div");
  this.loader.id = "loader";
  this.loader.className = "spinner";
  this.container.appendChild(this.loader);
  for (var i = 1;i <= 3;i++) {
    var spinnerContainer = document.createElement("div");
    spinnerContainer.className = "bounce" + i;
    this.loader.appendChild(spinnerContainer);
  }
  if (!this.config || (!this.config.hasOwnProperty("startOnInitialize") || this.config.startOnInitialize)) {
    this.run();
  }
  return 0;
};
Autodesk.Viewing.Viewer3D.prototype.run = function() {
  if (!this.running) {
    this.running = true;
    this.impl.run();
  }
};
Autodesk.Viewing.Viewer3D.prototype.__initAutoCam = function() {
  var self = this;
  var ourCamera = self.getCamera();
  if (!ourCamera.pivot) {
    ourCamera.pivot = new THREE.Vector3(0, 0, 0);
  }
  if (!ourCamera.target) {
    ourCamera.target = new THREE.Vector3(0, 0, 0);
  }
  if (!ourCamera.worldup) {
    ourCamera.target = ourCamera.up.clone();
  }
  function autocamChange(upChanged) {
    ourCamera.position.copy(self.autocamCamera.position);
    ourCamera.target.copy(self.autocamCamera.target);
    ourCamera.pivot.copy(self.autocamCamera.pivot);
    ourCamera.up.copy(self.autocamCamera.up);
    ourCamera.fov = self.autocamCamera.fov;
    self.impl.syncCamera(upChanged);
    if (upChanged) {
      ourCamera.worldup.copy(self.autocamCamera.worldup);
    }
  }
  function pivotDisplay(state) {
    self.impl.controls.pivotActive(state, false);
  }
  self.autocamCamera = ourCamera.clone();
  self.autocamCamera.target = ourCamera.target.clone();
  self.autocamCamera.pivot = ourCamera.pivot.clone();
  self.autocamCamera.worldup = ourCamera.worldup.clone();
  self.autocam = new Autocam(self.autocamCamera, self.navigation, autocamChange, pivotDisplay);
  self.addEventListener("cameraChanged", function(evt) {
    var ourCamera = evt.camera;
    self.autocam.sync(ourCamera);
  });
  self.autocam.sync(ourCamera);
  self.impl.controls.setAutocam(self.autocam);
};
Autodesk.Viewing.Viewer3D.prototype.load = function(svfURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback) {
  var self = this;
  return this.loadModel(svfURN, null, sharedPropertyDbPath, function() {
    if (self.modelstructure) {
      self.model.getObjectTree(function(root) {
        self.modelstructure.setModel(root, self.config.defaultModelStructureTitle ? self.config.defaultModelStructureTitle : "");
      });
    }
    if (onSuccessCallback) {
      onSuccessCallback();
    }
  }, onErrorCallback);
};
Autodesk.Viewing.Viewer3D.prototype.uninitialize = function(file) {
  this.canvas.parentNode.removeChild(this.canvas);
  this.canvas.viewer = null;
  this.canvas = null;
  if (this.navigation) {
    this.navigation.uninitialize();
  }
  if (this.impl) {
    this.impl.uninitialize();
    this.impl = null;
  }
  this.loader = null;
  this.model = null;
  Autodesk.Viewing.Viewer.prototype.uninitialize.call(this);
};
Autodesk.Viewing.Viewer3D.prototype.detectWebGL = function() {
  if (!!window.WebGLRenderingContext) {
    var canvas = document.createElement("canvas"), names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], context = false;
    for (var i = 0;i < 4;i++) {
      try {
        context = canvas.getContext(names[i]);
        if (context && typeof context.getParameter === "function") {
          return 1;
        }
      } catch (e) {
      }
    }
    return 0;
  }
  return-1;
};
Autodesk.Viewing.Viewer3D.prototype.loadModel = function(url, ids, sharedPropertyDbPath, onSuccessCallback, onErrorCallback) {
  var self = this;
  function onSuccess(modelData) {
    self.model = new Autodesk.Viewing.Model(modelData);
    self.impl.setModel(self.model);
    self.loader.style.display = "None";
    if (onSuccessCallback) {
      onSuccessCallback();
    }
  }
  function onError(errorCode, errorMessage) {
    self.loader.style.display = "None";
    if (onErrorCallback) {
      onErrorCallback(errorCode, errorMessage);
    }
  }
  this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function(e) {
    this.impl.needsRender = true;
    self.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT);
  });
  return this.impl.loadSvf(url, ids, sharedPropertyDbPath, onSuccess, onError);
};
Autodesk.Viewing.Viewer3D.prototype.resize = function() {
  Autodesk.Viewing.Viewer.prototype.resize.call(this);
  return this.impl.resize(this.container.clientWidth, this.container.clientHeight);
};
Autodesk.Viewing.Viewer3D.prototype.getCamera = function() {
  return this.impl.camera;
};
Autodesk.Viewing.Viewer3D.prototype.setViewFromArray = function(params) {
  this.impl.setViewFromArray(params);
};
Autodesk.Viewing.Viewer3D.prototype.setViewFromFile = function() {
  this.impl.setViewFromFile(this.model);
};
Autodesk.Viewing.Viewer3D.prototype.getProperties = function(dbid, onSuccessCallback, onErrorCallback) {
  if (this.model) {
    this.model.getProperties(dbid, onSuccessCallback, onErrorCallback);
  } else {
    if (onErrorCallback) {
      onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Properties failed to load since model does not exist.");
    }
  }
};
Autodesk.Viewing.Viewer3D.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback) {
  if (this.model) {
    this.model.getObjectTree(onSuccessCallback, onErrorCallback);
  } else {
    if (onErrorCallback) {
      onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "ObjectTree failed to load since model does not exist.");
    }
  }
};
Autodesk.Viewing.Viewer3D.prototype.setCanvasClickBehavior = function(config) {
  this.impl.controls.setClickBehavior(config);
};
Autodesk.Viewing.Viewer3D.prototype.search = function(text, onSuccessCallback, onErrorCallback) {
  this.searchText = text;
  if (this.model) {
    this.model.search(text, onSuccessCallback, onErrorCallback);
  } else {
    if (onErrorCallback) {
      onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Search failed since model does not exist.");
    }
  }
};
Autodesk.Viewing.Viewer3D.prototype.isolate = function(node) {
  if (Array.isArray(node)) {
    this.impl.visibilityManager.isolateMultiple(node);
  } else {
    this.impl.visibilityManager.isolate(node);
  }
};
Autodesk.Viewing.Viewer3D.prototype.isolateById = function(dbids) {
  var nodes = [];
  var self = this;
  function isolateNodes(result) {
    nodes = self.model.getNodesByIds(Array.isArray(dbids) ? dbids : [dbids]);
    if (nodes) {
      self.isolate(nodes);
    }
  }
  function handleGeomLoadedEvent(event) {
    this.getObjectTree(isolateNodes);
    self.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleGeomLoadedEvent);
  }
  if (this.model && this.model.isLoadDone()) {
    this.getObjectTree(isolateNodes);
  } else {
    this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleGeomLoadedEvent);
  }
};
Autodesk.Viewing.Viewer3D.prototype.setBackgroundColor = function(red, green, blue, red2, green2, blue2) {
  this.impl.setClearColors(red, green, blue, red2, green2, blue2);
};
Autodesk.Viewing.Viewer3D.prototype.toggleSelect = function(dbid) {
  this.impl.selector.toggleSelectionId(dbid);
};
Autodesk.Viewing.Viewer3D.prototype.select = function(dbids) {
  if (typeof dbids === "number") {
    dbids = [dbids];
  }
  this.impl.selector.setSelectionIds(dbids);
};
Autodesk.Viewing.Viewer3D.prototype.deselect = function(dbids) {
  throw Error("not implemented yet");
};
Autodesk.Viewing.Viewer3D.prototype.clearSelection = function() {
  this.impl.selector.clearSelection();
};
Autodesk.Viewing.Viewer3D.prototype.hide = function(node) {
  if (Array.isArray(node)) {
    this.impl.visibilityManager.hideMultiple(node);
  } else {
    this.impl.visibilityManager.hide(node);
  }
};
Autodesk.Viewing.Viewer3D.prototype.show = function(node) {
  if (Array.isArray(node)) {
    this.impl.visibilityManager.showMultiple(node);
  } else {
    this.impl.visibilityManager.show(node);
  }
};
Autodesk.Viewing.Viewer3D.prototype.showAll = function() {
  this.impl.visibilityManager.isolateNone();
};
Autodesk.Viewing.Viewer3D.prototype.hideAll = function() {
  throw Error("not implemented yet");
};
Autodesk.Viewing.Viewer3D.prototype.toggleVisibility = function(node) {
  this.impl.visibilityManager.toggleVisibility(node);
};
Autodesk.Viewing.Viewer3D.prototype.areAllVisible = function() {
  return this.impl.visibilityManager.areAllVisible();
};
Autodesk.Viewing.Viewer3D.prototype.explode = function(scale) {
  this.impl.explode(scale);
};
Autodesk.Viewing.Viewer3D.prototype.setQualityLevel = function(useSAO, useFXAA) {
  this.impl.togglePostProcess(useSAO, useFXAA);
};
Autodesk.Viewing.Viewer3D.prototype.setEnvironmentMap = function(url) {
  this.impl.setCubeMap(url);
};
Autodesk.Viewing.Viewer3D.prototype.setGhosting = function(value) {
  this.impl.toggleGhosting(value);
};
Autodesk.Viewing.Viewer3D.prototype.setProgressiveRendering = function(value) {
  this.impl.toggleProgressive(value);
};
Autodesk.Viewing.Viewer3D.prototype.setOptimizeNavigation = function(value) {
  this.impl.setOptimizeNavigation(value);
};
Autodesk.Viewing.Viewer3D.prototype.getNavigationMode = function() {
  if ("getNavigationMode" in this.impl.controls) {
    return this.impl.controls.getNavigationMode();
  }
  return;
};
Autodesk.Viewing.Viewer3D.prototype.setNavigationMode = function(mode) {
  if ("setNavigationMode" in this.impl.controls) {
    this.impl.controls.setNavigationMode(mode);
  }
};
Autodesk.Viewing.Viewer3D.prototype.getFOV = function() {
  if ("getFOV" in this.impl.controls) {
    return this.impl.controls.getFOV();
  }
  return this.impl.camera.fov;
};
Autodesk.Viewing.Viewer3D.prototype.setFOV = function(degrees) {
  if ("setFOV" in this.impl.controls) {
    this.impl.controls.setFOV(degrees);
  } else {
    this.impl.camera.fov = degrees;
    this.impl.syncCamera();
  }
};
Autodesk.Viewing.Viewer3D.prototype.getFocalLength = function() {
  if ("getFocalLength" in this.impl.controls) {
    return this.impl.controls.getFocalLength();
  }
  var rads = THREE.Math.degToRad(this.impl.camera.fov);
  return Math.round(12 / Math.tan(rads * 0.5));
};
Autodesk.Viewing.Viewer3D.prototype.setFocalLength = function(mm) {
  if ("setFocalLength" in this.impl.controls) {
    this.impl.controls.setFocalLength(mm);
  } else {
    this.impl.camera.setLens(mm);
    this.impl.syncCamera();
  }
};
Autodesk.Viewing.Viewer3D.prototype.hideLines = function(hide) {
  this.impl.hideLines(hide);
};
Autodesk.Viewing.Viewer3D.prototype.applyCamera = function(camera, fit) {
  this.impl.applyCamera(camera, fit);
};
Autodesk.Viewing.Viewer3D.prototype.fitToView = function(objectIds) {
  var that = this;
  var instant = true;
  var fit = function() {
    var fitTo = null;
    if (Array.isArray(objectIds) && objectIds.length > 0) {
      var bounds = new THREE.Box3;
      var box = new THREE.Box3;
      var fragIds = that.impl.selector.getFragIdsFromObjectIds(objectIds);
      for (var i = 0;i < fragIds.length;i++) {
        if (fragIds[i] !== undefined) {
          var m = that.impl.getRenderProxy(that.model, fragIds[i]);
          m.geometry.boundingBox.getTransformedBox(m.matrixWorld, box);
          bounds.union(box);
        }
      }
      if (!bounds.empty()) {
        fitTo = bounds;
      }
    }
    that.impl.controls.fitToView(false, fitTo);
    that.removeEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
    that.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, fit);
    return instant;
  };
  var checkGeomAndFit = function() {
    if (that.model && that.model.isLoadDone()) {
      fit();
    } else {
      instant = false;
      that.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, fit);
    }
  };
  if (this.model && this.model.isObjectTreeCreated()) {
    checkGeomAndFit();
  } else {
    instant = false;
    this.addEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
  }
};
Autodesk.Viewing.Viewer3D.prototype.setClickConfig = function(what, where, newAction) {
  var config = this.impl.controls.getClickBehavior();
  if (what in config) {
    var actions = config[what];
    if (where in actions) {
      actions[where] = newAction;
      return true;
    }
  }
  return false;
};
Autodesk.Viewing.Viewer3D.prototype.getClickConfig = function(what, where) {
  var config = this.impl.controls.getClickBehavior();
  if (what in config) {
    var actions = config[what];
    if (where in actions) {
      return actions[where];
    }
  }
  return null;
};
Autodesk.Viewing.Viewer3D.prototype.setClickToSetCOI = function(state) {
  var currentOn = this.getClickConfig("click", "onObject");
  if (state) {
    if (currentOn.indexOf("setCOI") === -1) {
      this.setClickConfig("click", "onObject", ["setCOI"]);
    }
  } else {
    if (currentOn.indexOf("setCOI") >= 0) {
      this.setClickConfig("click", "onObject", ["selectOnly"]);
    }
  }
};
Autodesk.Viewing.Viewer3D.prototype.setModelStructurePanel = function(modelStructurePanel) {
  var self = this;
  if (modelStructurePanel instanceof Autodesk.Viewing.UI.ModelStructurePanel) {
    if (this.modelstructure) {
      this.removePanel(this.modelstructure);
    }
    this.modelstructure = modelStructurePanel;
    this.addPanel(this.modelstructure);
    if (self.model) {
      self.model.getObjectTree(function(root) {
        self.modelstructure.setModel(root);
      });
    }
    return true;
  }
  return false;
};
Autodesk.Viewing.BaseViewer3D = Autodesk.Viewing.Viewer3D;
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ErrorCodes = {UNKNOWN_FAILURE:1, BAD_DATA:2, NETWORK_FAILURE:3, NETWORK_ACCESS_DENIED:4, NETWORK_FILE_NOT_FOUND:5, NETWORK_SERVER_ERROR:6, NETWORK_UNHANDLED_RESPONSE_CODE:7, BROWSER_WEBGL_NOT_SUPPORTED:8, BAD_DATA_NO_VIEWABLE_CONTENT:9};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Viewer2D = function(container, config) {
  Autodesk.Viewing.Viewer.call(this, container, config);
  if (!config) {
    config = {};
  }
  config.domElement = this.container;
  this.impl = new Autodesk.Viewing.Private.Viewer2DImpl(this, config);
};
Autodesk.Viewing.Viewer2D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.Viewer2D.prototype.constructor = Autodesk.Viewing.Viewer2D;
Autodesk.Viewing.Viewer2D.prototype.initialize = function() {
  Autodesk.Viewing.Viewer.prototype.initialize.call(this);
  return this.impl.initialize();
};
Autodesk.Viewing.Viewer2D.prototype.load = function(sheetURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback) {
  if (this.impl.load(sheetURN)) {
    if (onSuccessCallback) {
      onSuccessCallback();
    }
    return true;
  }
  if (onErrorCallback) {
    onErrorCallback();
  }
  return false;
};
Autodesk.Viewing.Viewer2D.prototype.uninitialize = function() {
  this.impl.uninitialize();
  Autodesk.Viewing.Viewer.prototype.uninitialize.call(this);
};
Autodesk.Viewing.Viewer2D.prototype.resize = function() {
  Autodesk.Viewing.Viewer.prototype.resize.call(this);
  this.impl.resize();
};
Autodesk.Viewing.Viewer2D.prototype.setViewFromFile = function() {
  this.impl.goHome();
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Document = function(dataJSON, path) {
  this.myPath = path;
  this.myData = dataJSON;
  this.myViewGeometry = {};
  this.myNumViews = {};
  this.myPropertyDb = null;
  var self = this;
  function annotateViews(item) {
    if (!item) {
      return;
    }
    var childCount = item.children ? item.children.length : 0;
    if (item.type === "geometry" && (item.role === "3d" && childCount)) {
      var viewCount = 0;
      for (var i = 0;i < childCount;i++) {
        var child = item.children[i];
        if (child && (child.type === "view" && child.role === "3d")) {
          self.myViewGeometry[child.guid] = item;
          viewCount++;
        }
      }
      self.myNumViews[item.guid] = viewCount;
    } else {
      if (item.mime == "application/autodesk-db") {
        self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("/") + 1);
      } else {
        if (0 < childCount) {
          for (var i = 0;i < childCount;i++) {
            annotateViews(item.children[i]);
          }
        }
      }
    }
  }
  annotateViews(dataJSON);
  if (ENABLE_DEBUG) {
    function printItemDBG(key, value, space) {
      console.log(space + key + " : " + value);
    }
    function traverseDBG(data, printFunc, tabSpace, root) {
      if (!data) {
        return;
      }
      for (var key in data) {
        printFunc.apply(this, [key, data[key], tabSpace]);
        if (data[key] !== null && typeof data[key] === "object") {
          var space = tabSpace + "    ";
          traverseDBG(data[key], printFunc, space);
        }
      }
    }
  }
};
Autodesk.Viewing.Document.prototype.constructor = Autodesk.Viewing.Document;
Autodesk.Viewing.Document.load = function(documentId, onSuccessCallback, onErrorCallback) {
  if (typeof arguments[1] !== "function") {
    console.log("Autodesk.Viewing.Document.load called with deprecated (auth) parameter");
    if (typeof arguments[2] === "function") {
      onSuccessCallback = arguments[2];
    }
    if (typeof arguments[3] === "function") {
      onErrorCallback = arguments[3];
    }
  }
  function getDocumentPath(documentId) {
    if (documentId.substr(0, 7) == "http://" || (documentId.substr(0, 8) == "https://" || documentId.substr(0, 8) == "file:///")) {
      return documentId;
    }
    if (documentId.indexOf("urn:") === -1) {
      var relativePath = documentId;
      if (relativePath.indexOf("/") !== 0) {
        relativePath = "/" + relativePath;
      }
      return window.location.protocol + "//" + window.location.host + relativePath;
    } else {
      var urn = documentId.substr(4);
      if (Autodesk.Viewing.Private.env.indexOf("Autodesk") == 0) {
        return VIEWING_URL + "/" + urn;
      } else {
        return VIEWING_URL + "/bubbles/" + urn;
      }
    }
  }
  function hasModelData(data) {
    return data && (data.progress && data.progress !== "0%");
  }
  function getTranslationError(data) {
    return Autodesk.Viewing.ErrorCodes.BAD_DATA;
  }
  function xhrErrorMessage(title, xhr) {
    var message = title + ": " + xhr.status;
    if (xhr.statusText) {
      message += " (" + xhr.statusText + ")";
    }
    return message;
  }
  var documentPath = getDocumentPath(documentId);
  try {
    var xhr = new XMLHttpRequest;
    xhr.open("GET", documentPath, true);
    xhr.withCredentials = true;
    xhr.setRequestHeader("Access-Control-Allow-Credentials", true);
    xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
    xhr.onload = function(e) {
      if (xhr.status && xhr.status === 200) {
        var response = xhr.response ? xhr.response : xhr.responseText;
        var regex = /<[^>]*script/;
        if (regex.test(xhr.responseText)) {
          if (onErrorCallback) {
            onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Malicious document content detected. Abort loading.");
          }
          return;
        }
        var items = typeof response === "string" ? JSON.parse(response) : response;
        var document = new Autodesk.Viewing.Document(items, documentPath);
        if (onSuccessCallback) {
          onSuccessCallback(document);
        }
      } else {
        if (onErrorCallback) {
          var errorMsg = xhrErrorMessage("Network error", xhr);
          var errorCode = Autodesk.Viewing.Private.ErrorHandler.getErrorCode(xhr.status);
          onErrorCallback(errorCode, errorMsg);
        }
      }
    };
    xhr.onerror = function(e) {
      if (onErrorCallback) {
        var errorMsg = xhrErrorMessage("Load error", xhr);
        var errorCode = Autodesk.Viewing.Private.ErrorHandler.getErrorCode(xhr.status);
        onErrorCallback(errorCode, errorMsg);
      }
    };
    xhr.ontimeout = function(e) {
      if (onErrorCallback) {
        var errorMsg = xhrErrorMessage("Timeout occurred", xhr);
        var errorCode = Autodesk.Viewing.Private.ErrorHandler.getErrorCode(xhr.status);
        onErrorCallback(errorCode, errorMsg);
      }
    };
    xhr.send();
  } catch (e) {
    if (onErrorCallback) {
      var errorMsg = "An exception occurred while loading the document: " + e.toString();
      var errorCode = Autodesk.Viewing.ErrorCodes.UNKNOWN_FAILURE;
      onErrorCallback(errorCode, errorMsg);
    }
  }
};
Autodesk.Viewing.Document.prototype.getFullPath = function(urn) {
  var fullPath = urn;
  if (urn.indexOf("urn") === 0) {
    fullPath = VIEWING_URL + "/items/" + urn;
  } else {
    if (urn.indexOf("$file$") === 0 && this.myPath.indexOf("/output/bubble.json") !== -1) {
      fullPath = this.myPath.replace("/output/bubble.json", "") + urn.replace("$file$", "");
    }
  }
  return fullPath;
};
Autodesk.Viewing.Document.prototype.getThumbnailPath = function(item, width, height) {
  var requestedWidth = width ? width : 200;
  var requestedHeight = height ? height : 200;
  return VIEWING_URL + "/thumbnails/" + this.myData.urn + "?guid=" + encodeURIComponent(item.guid) + "&width=" + requestedWidth + "&height=" + requestedHeight;
};
Autodesk.Viewing.Document.prototype.getViewablePath = function(item) {
  if (item.type === "geometry") {
    var items = [];
    if (item.role === "3d") {
      items = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {"mime":"application/autodesk-svf"}, false);
    } else {
      if (item.role === "2d") {
        items = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {"role":"tileRoot"}, true);
      }
    }
    if (items.length > 0) {
      return this.getFullPath(items[0].urn);
    }
  } else {
    if (item.type === "view") {
      var geometryItem = this.getViewGeometry(item);
      if (geometryItem) {
        return this.getViewablePath(geometryItem);
      }
    }
  }
  return "";
};
Autodesk.Viewing.Document.prototype.getPropertyDbPath = function() {
  return this.myPropertyDb;
};
Autodesk.Viewing.Document.prototype.getRootItem = function() {
  return this.myData;
};
Autodesk.Viewing.Document.prototype.getPath = function() {
  return this.myPath;
};
Autodesk.Viewing.Document.prototype.getItemById = function(id) {
  function traverse(data) {
    if (!data) {
      return null;
    }
    for (var key in data) {
      var val = data[key];
      if (key === "guid" && val === id) {
        return data;
      }
      if (val !== null && typeof val === "object") {
        var item = traverse(val);
        if (item) {
          return item;
        }
      }
    }
    return null;
  }
  return traverse(this.myData);
};
Autodesk.Viewing.Document.getSubItemsWithProperties = function(item, properties, recursive) {
  var subItems = [];
  if (!item) {
    return[];
  }
  function hasProperties(item, properties) {
    for (var p in properties) {
      if (!(p in item) || properties[p] !== item[p]) {
        return false;
      }
    }
    return true;
  }
  var len = item.children ? item.children.length : 0;
  for (var i = 0;i < len;i++) {
    var child = item.children[i];
    if (hasProperties(child, properties)) {
      subItems.push(child);
    }
    if (recursive) {
      subItems.push.apply(subItems, Autodesk.Viewing.Document.getSubItemsWithProperties(child, properties, recursive));
    }
  }
  return subItems;
};
Autodesk.Viewing.Document.prototype.getViewGeometry = function(item) {
  return this.myViewGeometry[item.guid];
};
Autodesk.Viewing.Document.prototype.getNumViews = function(item) {
  return this.myNumViews[item.guid] || 0;
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ModelUnits = {METER:"m", CENTIMETER:"cm", MILLIMETER:"mm", FOOT:"ft", INCH:"in"};
Autodesk.Viewing.Model = function(modelData) {
  this.myData = modelData;
  this.sharedPath = null;
  this.propWorker = null;
  this.myLoader = null;
};
Autodesk.Viewing.Model.prototype = Object.create(THREE.EventDispatcher.prototype);
Autodesk.Viewing.Model.prototype.constructor = Autodesk.Viewing.Model;
Autodesk.Viewing.Model.prototype.setData = function(data) {
  this.myData = data;
};
Autodesk.Viewing.Model.prototype.getData = function() {
  return this.myData;
};
Autodesk.Viewing.Model.prototype.setLoader = function(loader) {
  this.myLoader = loader;
};
Autodesk.Viewing.Model.prototype.getRoot = function() {
  if (this.myData) {
    return this.myData.instanceTree;
  }
  return null;
};
Autodesk.Viewing.Model.prototype.getRootId = function() {
  if (this.myData && this.myData.instanceTree) {
    return this.myData.instanceTree.dbId;
  }
  return null;
};
Autodesk.Viewing.Model.prototype.getBoundingBox = function() {
  if (this.myData) {
    return this.myData.bbox;
  }
  return null;
};
Autodesk.Viewing.Model.prototype.getUnitScale = function() {
  var unit = this.getMetadata("distance unit", "value", null);
  switch(unit) {
    case "meter":
    ;
    case "m":
      return 1;
    case "foot":
    ;
    case "ft":
      return 0.3048;
    case "inch":
    ;
    case "in":
      return 0.0254;
    case "centimeter":
    ;
    case "cm":
      return 0.01;
    case "millimeter":
    ;
    case "mm":
      return 0.001;
    default:
      return 1;
  }
};
Autodesk.Viewing.Model.prototype.getUnitString = function() {
  var unit = this.getMetadata("distance unit", "value", null);
  switch(unit) {
    case "meter":
    ;
    case "m":
      return Autodesk.Viewing.ModelUnits.METER;
    case "foot":
    ;
    case "ft":
      return Autodesk.Viewing.ModelUnits.FOOT;
    case "inch":
    ;
    case "in":
      return Autodesk.Viewing.ModelUnits.INCH;
    case "centimeter":
    ;
    case "cm":
      return Autodesk.Viewing.ModelUnits.CENTIMETER;
    case "millimeter":
    ;
    case "mm":
      return Autodesk.Viewing.ModelUnits.MILLIMETER;
    default:
      return null;
  }
};
Autodesk.Viewing.Model.prototype.getBgColor = function() {
  if (this.myData) {
    return this.myData.bgColor;
  }
  return 4294967295;
};
Autodesk.Viewing.Model.prototype.getNodeById = function(id) {
  function traverse(node) {
    if (!node) {
      return null;
    }
    if (node.dbId && node.dbId === id) {
      return node;
    }
    if (node.children && node.children.length > 0) {
      for (var index = 0;index < node.children.length;index++) {
        var foundNode = traverse(node.children[index]);
        if (foundNode) {
          return foundNode;
        }
      }
    }
    return null;
  }
  return traverse(this.getRoot());
};
Autodesk.Viewing.Model.prototype.getNodesByIds = function(nodeIDArray) {
  var newNodeArray = nodeIDArray.slice(0);
  function recursiveGetNodeByID(array, node, list) {
    if (array.length === 0) {
      return list;
    }
    var nodeIDIndex = array.indexOf(node.dbId);
    if (nodeIDIndex !== -1) {
      list.push(node);
      array.splice(nodeIDIndex, 1);
    }
    if (node.children) {
      for (var i = 0;i < node.children.length;i++) {
        recursiveGetNodeByID(array, node.children[i], list);
      }
    }
    return list;
  }
  return recursiveGetNodeByID(newNodeArray, this.getRoot(), []);
};
Autodesk.Viewing.Model.prototype.getMetadata = function(itemName, subitemName, defaultValue) {
  if (this.myData) {
    var metadata = this.myData.metadata;
    if (metadata) {
      var item = metadata[itemName];
      if (item !== undefined) {
        if (subitemName) {
          var subitem = item[subitemName];
          if (subitem !== undefined) {
            return subitem;
          }
        } else {
          return item;
        }
      }
    }
  }
  return defaultValue;
};
Autodesk.Viewing.Model.prototype.getDefaultCamera = function() {
  var myData = this.myData;
  if (!myData) {
    return null;
  }
  var defaultCamera = null;
  var numCameras = myData.cameras ? myData.cameras.length : 0;
  if (0 < numCameras) {
    var defaultCameraIndex = this.getMetadata("default camera", "index", null);
    if (defaultCameraIndex !== null && myData.cameras[defaultCameraIndex]) {
      defaultCamera = myData.cameras[defaultCameraIndex];
    } else {
      for (var i = 0;i < numCameras;i++) {
        var camera = myData.cameras[i];
        if (camera.isPerspective) {
          defaultCamera = camera;
          break;
        }
      }
      if (!defaultCamera) {
        defaultCamera = myData.cameras[0];
      }
    }
  }
  return defaultCamera;
};
Autodesk.Viewing.Model.prototype.getUpVector = function() {
  return this.getMetadata("world up vector", "XYZ", null);
};
Autodesk.Viewing.Model.prototype.geomPolyCount = function() {
  if (!this.myData) {
    return null;
  }
  return this.myData.geomPolyCount;
};
Autodesk.Viewing.Model.prototype.instancePolyCount = function() {
  if (!this.myData) {
    return null;
  }
  return this.myData.instancePolyCount;
};
Autodesk.Viewing.Model.prototype.getLayersList = function() {
  if (!this.myData) {
    return null;
  }
  return this.myData.layersList;
};
Autodesk.Viewing.Model.prototype.is2d = function() {
  return this.myData && this.myData.is2d;
};
Autodesk.Viewing.Model.prototype.isLoadDone = function() {
  return this.myData && this.myData.loadDone;
};
Autodesk.Viewing.Model.prototype.isObjectTreeCreated = function() {
  return this.myData && this.myData.fragToNodeDone;
};
Autodesk.Viewing.Model.prototype.getProperties = function(dbId, onSuccessCallback, onErrorCallback) {
  if (!this.myData || !this.myLoader) {
    return;
  }
  this.myLoader.getProperties(dbId, onSuccessCallback, onErrorCallback);
};
Autodesk.Viewing.Model.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback) {
  if (!this.myData || !this.myLoader) {
    return;
  }
  this.myLoader.getObjectTree(onSuccessCallback, onErrorCallback);
};
Autodesk.Viewing.Model.prototype.search = function(text, onSuccessCallback, onErrorCallback) {
  var self = this;
  if (this.isLoadDone()) {
    this.myLoader.searchProperties(text, onSuccessCallback, onErrorCallback);
  } else {
    this.getObjectTree(function(tree) {
      self.myLoader.searchProperties(text, onSuccessCallback, onErrorCallback);
    });
  }
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Navigation = function(camera) {
  var kMinFOV = 6.88;
  var kMaxFOV = 100;
  var kEpsilon = 1E-6;
  this.__options = {dollyToPivot:false, orbitPastPoles:true, reverseDolly:false, useLeftHandedInput:false, usePivotAlways:false, lockNavigation:false};
  this.__pivotIsSetFlag = false;
  this.__fitToViewRequested = false;
  this.__homeViewRequested = false;
  this.__transitionActive = false;
  this.__destinationView = null;
  var _camera = null;
  var _viewport = {left:0, top:0, width:1, height:1};
  this.uninitialize = function() {
    this.setCamera(null);
  };
  this.setCamera = function(camera) {
    if (camera !== _camera) {
      _camera = camera;
      if (camera) {
        if (!camera.hasOwnProperty("target")) {
          camera.target = new THREE.Vector3(0, 0, 0);
        }
        if (!camera.hasOwnProperty("pivot")) {
          camera.pivot = new THREE.Vector3(0, 0, 0);
        }
        camera.worldup = camera.up.clone();
        camera.dirty = true;
      }
    }
  };
  this.getCamera = function() {
    return _camera;
  };
  this.setScreenViewport = function(viewport) {
    _viewport = viewport;
  };
  this.getScreenViewport = function() {
    return _viewport;
  };
  this.__setUp = function(up) {
    if (up && _camera) {
      var upCheck = up.clone().normalize();
      var diff = upCheck.sub(_camera.worldup);
      if (diff.lengthSq() !== 0) {
        _camera.worldup.copy(up).normalize();
        _camera.dirty = true;
        return true;
      }
    }
    return false;
  };
  this.__getUp = function() {
    return _camera ? _camera.worldup : null;
  };
  this.setView = function(position, target) {
    if (_camera && (position && (target && !this.__options.lockNavigation))) {
      _camera.position.copy(position);
      _camera.target.copy(target);
      _camera.dirty = true;
    }
  };
  this.getPivotPoint = function() {
    return _camera ? _camera.pivot.clone() : new THREE.Vector3(0, 0, 0);
  };
  this.setPivotPoint = function(pivot) {
    if (_camera && pivot) {
      _camera.pivot.copy(pivot);
      _camera.dirty = true;
    }
  };
  this.getPosition = function() {
    return _camera ? _camera.position.clone() : new THREE.Vector3(0, 0, 1);
  };
  this.setPosition = function(pos) {
    if (_camera && (pos && !this.__options.lockNavigation)) {
      _camera.position.copy(pos);
      _camera.dirty = true;
    }
  };
  this.setTarget = function(target) {
    if (_camera && (target && !this.__options.lockNavigation)) {
      _camera.target.copy(target);
      _camera.dirty = true;
    }
  };
  this.getTarget = function() {
    return _camera ? _camera.target.clone() : new THREE.Vector3(0, 0, 0);
  };
  this.getEyeVector = function() {
    return _camera ? _camera.target.clone().sub(_camera.position) : new THREE.Vector3(0, 0, -1);
  };
  this.getFovMin = function() {
    return kMinFOV;
  };
  this.getFovMax = function() {
    return kMaxFOV;
  };
  this.setVerticalFov = function(fov, adjustPosition) {
    if (fov < kMinFOV) {
      fov = kMinFOV;
    } else {
      if (fov > kMaxFOV) {
        fov = kMaxFOV;
      }
    }
    if (_camera) {
      if (Math.abs(_camera.fov - fov) <= kEpsilon) {
        return;
      }
      if (adjustPosition) {
        var eye = this.getEyeVector();
        var oldFOV = THREE.Math.degToRad(_camera.fov);
        var newFOV = THREE.Math.degToRad(fov);
        var distance = eye.length() * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
        var moveDirection = eye.multiplyScalar(-1).normalize();
        this.setPosition(this.getTarget().add(moveDirection.multiplyScalar(distance)));
      }
      _camera.fov = fov;
      _camera.dirty = true;
    }
  };
  this.computeFit = function(oldpos, oldcoi, fov, bounds) {
    if (bounds.empty()) {
      return{position:oldpos, target:oldcoi};
    }
    var coi = bounds.center();
    var size = bounds.size();
    var radius = 0.5 * Math.sqrt(size.x * size.x + size.y * size.y + size.z * size.z);
    if (radius === 0) {
      radius = 1;
    }
    var fovFudge = Math.max(1, 0.9 + fov / kMaxFOV * 0.5);
    radius *= fovFudge;
    var eye = oldpos.clone().sub(oldcoi).normalize();
    var fitToViewDistance = radius / Math.tan(THREE.Math.degToRad(fov * 0.5));
    eye.multiplyScalar(fitToViewDistance);
    var pos = coi.clone().add(eye);
    return{position:pos, target:coi};
  };
  this.fitBounds = function(immediate, bounds) {
    var oldcoi = this.getTarget();
    var pos = this.getPosition();
    if (this.__options.lockNavigation || (!bounds || bounds.empty())) {
      return{position:pos, target:oldcoi};
    }
    var fov = this.getVerticalFov();
    var fit = this.computeFit(pos, oldcoi, fov, bounds);
    if (immediate) {
      this.setView(fit.position, fit.target);
    } else {
      this.setRequestTransition(true, fit.position, fit.target, fov);
    }
    this.setPivotPoint(fit.target);
    this.setPivotSetFlag(true);
    return fit;
  };
  this.updateCamera = function() {
    if (_camera) {
      _camera.updateProjectionMatrix();
      this.orient(_camera, _camera.target, _camera.position, _camera.up);
      _camera.dirty = false;
    }
  };
  this.setCamera(camera);
};
Autodesk.Viewing.Navigation.prototype.constructor = Autodesk.Viewing.Navigation;
Autodesk.Viewing.Navigation.prototype.orient = function() {
  var m1 = new THREE.Matrix4;
  var x = new THREE.Vector3;
  var y = new THREE.Vector3;
  var z = new THREE.Vector3;
  return function(object, pos, towards, up) {
    var te = m1.elements;
    z.subVectors(towards, pos).normalize();
    if (z.lengthSq() === 0) {
      z.z = 1;
    }
    x.crossVectors(up, z).normalize();
    if (x.lengthSq() === 0) {
      if (up.z > up.y) {
        z.y -= 1E-4;
      } else {
        z.z += 1E-4;
      }
      x.crossVectors(up, z).normalize();
    }
    y.crossVectors(z, x);
    te[0] = x.x;
    te[4] = y.x;
    te[8] = z.x;
    te[1] = x.y;
    te[5] = y.y;
    te[9] = z.y;
    te[2] = x.z;
    te[6] = y.z;
    te[10] = z.z;
    object.setRotationFromMatrix(m1);
  };
}();
Autodesk.Viewing.Navigation.prototype.fov2fl = function(fov) {
  var k35mmVerticalCameraBackSize = 12;
  var rads = THREE.Math.degToRad(fov);
  if (rads <= 0) {
    rads = 1E-4;
  }
  return Math.round(k35mmVerticalCameraBackSize / Math.tan(rads * 0.5));
};
Autodesk.Viewing.Navigation.prototype.fl2fov = function(fl) {
  var k35mmVerticalCameraBackSize = 12;
  if (fl <= 0) {
    fl = 1E-4;
  }
  var rads = 2 * Math.atan(k35mmVerticalCameraBackSize / fl);
  return THREE.Math.radToDeg(rads);
};
Autodesk.Viewing.Navigation.prototype.getCameraUpVector = function() {
  var up = new THREE.Vector3;
  return function() {
    var right = this.getCameraRightVector();
    var eye = this.getEyeVector();
    return up.crossVectors(eye, right).normalize();
  };
}();
Autodesk.Viewing.Navigation.prototype.getCameraRightVector = function() {
  var right = new THREE.Vector3;
  return function() {
    var up = this.getWorldUpVector();
    var eye = this.getEyeVector();
    right.set(-eye.x, -eye.y, -eye.z);
    right.cross(up);
    if (right.lengthSq() === 0) {
      if (up.z > up.y) {
        eye.y -= 1E-4;
      } else {
        eye.z += 1E-4;
      }
      right.cross(up);
    }
    return right.normalize();
  };
}();
Autodesk.Viewing.Navigation.prototype.setWorldUpVector = function(up) {
  this.__setUp(up);
};
Autodesk.Viewing.Navigation.prototype.getWorldUpVector = function() {
  return this.__getUp().clone();
};
Autodesk.Viewing.Navigation.prototype.getWorldRightVector = function() {
  var _this = this;
  var right = new THREE.Vector3;
  return function() {
    right.copy(_this.__getUp());
    if (Math.abs(right.z) <= Math.abs(right.y)) {
      right.set(right.y, -right.x, 0);
    } else {
      if (right.z >= 0) {
        right.set(right.z, 0, -right.x);
      } else {
        right.set(-right.z, 0, right.x);
      }
    }
    return right.normalize();
  };
}();
Autodesk.Viewing.Navigation.prototype.getVerticalFov = function() {
  return this.getCamera().fov;
};
Autodesk.Viewing.Navigation.prototype.getHorizontalFov = function() {
  var viewport = this.getScreenViewport();
  return this.getCamera().fov * (viewport.width / viewport.height);
};
Autodesk.Viewing.Navigation.prototype.getFocalLength = function() {
  return this.fov2fl(this.getVerticalFov());
};
Autodesk.Viewing.Navigation.prototype.setFocalLength = function(millimeters) {
  this.setVerticalFov(this.fl2fov(millimeters));
};
Autodesk.Viewing.Navigation.prototype.setReverseZoomDirection = function(state) {
  this.__options.reverseDolly = !!state;
};
Autodesk.Viewing.Navigation.prototype.getReverseZoomDirection = function() {
  return this.__options.reverseDolly;
};
Autodesk.Viewing.Navigation.prototype.setZoomTowardsPivot = function(state) {
  this.__options.dollyToPivot = !!state;
};
Autodesk.Viewing.Navigation.prototype.getZoomTowardsPivot = function() {
  return this.__options.dollyToPivot;
};
Autodesk.Viewing.Navigation.prototype.setOrbitPastWorldPoles = function(state) {
  this.__options.orbitPastPoles = !!state;
};
Autodesk.Viewing.Navigation.prototype.getOrbitPastWorldPoles = function() {
  return this.__options.orbitPastPoles;
};
Autodesk.Viewing.Navigation.prototype.setUsePivotAlways = function(state) {
  this.__options.usePivotAlways = !!state;
};
Autodesk.Viewing.Navigation.prototype.getUsePivotAlways = function() {
  return this.__options.usePivotAlways;
};
Autodesk.Viewing.Navigation.prototype.setUseLeftHandedInput = function(state) {
  this.__options.useLeftHandedInput = !!state;
};
Autodesk.Viewing.Navigation.prototype.getUseLeftHandedInput = function() {
  return this.__options.useLeftHandedInput;
};
Autodesk.Viewing.Navigation.prototype.setIsLocked = function(state) {
  this.__options.lockNavigation = !!state;
};
Autodesk.Viewing.Navigation.prototype.getIsLocked = function() {
  return this.__options.lockNavigation;
};
Autodesk.Viewing.Navigation.prototype.setPivotSetFlag = function(state) {
  this.__pivotIsSetFlag = !!state;
};
Autodesk.Viewing.Navigation.prototype.getPivotSetFlag = function() {
  return this.__pivotIsSetFlag;
};
Autodesk.Viewing.Navigation.prototype.setRequestFitToView = function(state) {
  this.__fitToViewRequested = !!state;
};
Autodesk.Viewing.Navigation.prototype.getRequestFitToView = function() {
  return this.__fitToViewRequested;
};
Autodesk.Viewing.Navigation.prototype.setRequestHomeView = function(state) {
  this.__homeViewRequested = !!state;
};
Autodesk.Viewing.Navigation.prototype.getRequestHomeView = function() {
  return this.__homeViewRequested;
};
Autodesk.Viewing.Navigation.prototype.setRequestTransition = function(state, pos, coi, fov) {
  if (state) {
    var worldUp = this.getWorldUpVector();
    var pivot = this.getPivotPoint();
    this.__destinationView = {position:pos.clone(), coi:coi.clone(), fov:fov, worldUp:worldUp};
  } else {
    this.__destinationView = null;
  }
};
Autodesk.Viewing.Navigation.prototype.getRequestTransition = function() {
  return this.__destinationView;
};
Autodesk.Viewing.Navigation.prototype.setTransitionActive = function(state) {
  this.__transitionActive = !!state;
};
Autodesk.Viewing.Navigation.prototype.getTransitionActive = function() {
  return this.__transitionActive;
};
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ScreenCapture = function(viewer) {
  this.viewer = viewer;
  var imgString = this.viewer.impl.renderer.screenCaptureRenderer.domElement.toDataURL("image/png");
  return imgString;
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.ViewingApplication = function(containerId, options) {
  this.appContainerId = containerId;
  this.container = document.getElementById(containerId);
  this.options = options;
  this.myRegisteredViewers = {};
  this.myDocument = null;
  this.myCurrentViewer = null;
  this.urn = null;
};
Autodesk.Viewing.ViewingApplication.prototype.k3D = "3D";
Autodesk.Viewing.ViewingApplication.prototype.k2D = "2D";
Autodesk.Viewing.ViewingApplication.prototype.registerViewer = function(viewableType, viewerClass, config) {
  this.myRegisteredViewers[viewableType] = {};
  this.myRegisteredViewers[viewableType].class = viewerClass;
  this.myRegisteredViewers[viewableType].config = config;
};
Autodesk.Viewing.ViewingApplication.prototype.getViewerClass = function(viewableType) {
  return this.myRegisteredViewers.hasOwnProperty(viewableType) ? this.myRegisteredViewers[viewableType].class : null;
};
Autodesk.Viewing.ViewingApplication.prototype.getViewerContainer = function() {
  return document.getElementById(this.appContainerId);
};
Autodesk.Viewing.ViewingApplication.prototype.getViewer = function(viewableType, config, onErrorCallback) {
  if (viewableType in this.myRegisteredViewers) {
    this.setCurrentViewer(null);
    var viewerClass = this.myRegisteredViewers[viewableType].class;
    var mergedConfig = {};
    var registeredViewerConfig = this.myRegisteredViewers[viewableType].config;
    var name;
    for (name in registeredViewerConfig) {
      if (registeredViewerConfig.hasOwnProperty(name)) {
        mergedConfig[name] = registeredViewerConfig[name];
      }
    }
    for (name in config) {
      if (config.hasOwnProperty(name)) {
        mergedConfig[name] = config[name];
      }
    }
    var container = this.getViewerContainer();
    while (container.hasChildNodes()) {
      container.removeChild(container.lastChild);
    }
    var viewer = new viewerClass(container, mergedConfig);
    var viewerInitCode = viewer.initialize();
    if (viewerInitCode === 0) {
      this.setCurrentViewer(viewer);
      return viewer;
    } else {
      if (onErrorCallback) {
        onErrorCallback(viewerInitCode, "Viewer failed to initialize.");
      }
    }
  }
  return null;
};
Autodesk.Viewing.ViewingApplication.prototype.setCurrentViewer = function(viewer) {
  if (this.myCurrentViewer) {
    this.myCurrentViewer.uninitialize();
  }
  this.myCurrentViewer = viewer;
};
Autodesk.Viewing.ViewingApplication.prototype.getCurrentViewer = function() {
  return this.myCurrentViewer;
};
Autodesk.Viewing.ViewingApplication.prototype.loadDocument = function(documentId, onDocumentLoadCallback, onLoadFailedCallback) {
  var application = this;
  Autodesk.Viewing.Document.load(documentId, function(document) {
    application.myDocument = document;
    application.onDocumentLoaded(document);
    if (onDocumentLoadCallback) {
      onDocumentLoadCallback(document);
    }
  }, function(errorMsg, errorCode) {
    application.onDocumentFailedToLoad(errorMsg, errorCode);
    if (onLoadFailedCallback) {
      onLoadFailedCallback(errorMsg, errorCode);
    }
  });
};
Autodesk.Viewing.ViewingApplication.prototype.onDocumentLoaded = function(document) {
  console.log(document);
};
Autodesk.Viewing.ViewingApplication.prototype.onDocumentFailedToLoad = function(errorMsg, errorCode) {
  console.log(errorMsg);
};
Autodesk.Viewing.ViewingApplication.prototype.selectItem = function(item, onSuccessCallback, onErrorCallback) {
  var urnToLoad = this.myDocument.getViewablePath(item);
  if (urnToLoad) {
    var viewerType, viewItem, title;
    if (item.type === "geometry" && item.role === "3d") {
      viewerType = this.k3D;
      title = item.name;
    } else {
      if (item.type === "view" && item.role === "3d") {
        viewItem = item;
        viewerType = this.k3D;
        var geometry = this.myDocument.getViewGeometry(item);
        if (geometry) {
          title = geometry.name;
        }
      } else {
        if (item.type === "geometry" && item.role === "2d") {
          viewerType = this.k2D;
          title = item.name;
        }
      }
    }
    Autodesk.Viewing.Private.logger.log({viewer_current_time:Date.now(), viewer_event_type:"switch sheet", viewer_sheet_title:title});
    if (viewerType) {
      var self = this;
      var urnAlreadyLoaded = this.myCurrentViewer && this.urn === urnToLoad;
      var onLoadCallback = null;
      if (viewItem && viewItem.camera) {
        onLoadCallback = function() {
          self.myCurrentViewer.setViewFromArray(viewItem.camera);
          if (onSuccessCallback) {
            onSuccessCallback(self.myCurrentViewer, item);
          }
        };
      } else {
        if (urnAlreadyLoaded) {
          onLoadCallback = function() {
            self.myCurrentViewer.setViewFromFile();
            if (onSuccessCallback) {
              onSuccessCallback(self.myCurrentViewer, item);
            }
          };
        } else {
          onLoadCallback = function() {
            if (onSuccessCallback) {
              onSuccessCallback(self.myCurrentViewer, item);
            }
          };
        }
      }
      var loaded = false;
      if (urnAlreadyLoaded) {
        if (onLoadCallback) {
          onLoadCallback();
        }
        loaded = true;
      } else {
        this.urn = null;
        var config = {defaultModelStructureTitle:title};
        var viewer = this.getViewer(viewerType, config, onErrorCallback);
        if (viewer && viewer.load(this.myDocument.getFullPath(urnToLoad), this.myDocument.getPropertyDbPath(), onLoadCallback, onErrorCallback)) {
          this.urn = urnToLoad;
          loaded = true;
        }
      }
      if (loaded) {
        this.onItemSelected(item);
        return true;
      }
    }
  }
  return false;
};
Autodesk.Viewing.ViewingApplication.prototype.onItemSelected = function(item) {
  console.log("Selected URL: http://" + location.host + location.pathname + "?document=urn:" + this.myDocument.getRootItem().guid + "&item=" + encodeURIComponent(item.guid));
};
Autodesk.Viewing.ViewingApplication.prototype.selectItemById = function(itemId, onItemSelectedCallback, onItemFailedToSelectCallback) {
  var item = this.myDocument.getItemById(itemId);
  if (item) {
    return this.selectItem(item, onItemSelectedCallback, onItemFailedToSelectCallback);
  }
  return false;
};
/*
 Copyright (c) 2013 Autodesk Inc. */
AutodeskNamespace("Autodesk.Viewing");
Autodesk.Viewing.Initializer = function(options, callback) {
  Autodesk.Viewing.Private.initializeEnvironmentVariable(options);
  Autodesk.Viewing.Private.initializeServiceEndPoints();
  Autodesk.Viewing.Private.initializeAuth(callback, options);
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.GuiViewer3D = function(container, config) {
  if (!config) {
    config = {};
  }
  config.startOnInitialize = false;
  this.prefs = new Autodesk.Viewing.Private.Preferences(this, "Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.");
  Autodesk.Viewing.Viewer3D.call(this, container, config);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype = Object.create(Autodesk.Viewing.Viewer3D.prototype);
Autodesk.Viewing.Private.GuiViewer3D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer3D;
Autodesk.Viewing.Private.GuiViewer3D.prototype.resize = function() {
  Autodesk.Viewing.Viewer3D.prototype.resize.call(this);
  if (this.container.clientWidth < 600) {
    this.toolBar.collapse(true);
  } else {
    this.toolBar.collapse(false);
  }
};
Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig = {"click":{"onObject":["isolate"]}, "clickCtrl":{"onObject":["toggleVisibility"]}};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initialize = function() {
  var viewerErrorCode = Autodesk.Viewing.Viewer3D.prototype.initialize.call(this);
  if (viewerErrorCode > 0) {
    return viewerErrorCode;
  }
  var viewer = this;
  var container = viewer.container;
  this.toolBar = new Autodesk.Viewing.UI.ToolBar(container);
  var toolbarcentertop = document.createElement("div");
  toolbarcentertop.className = "toolbarcentertop";
  container.appendChild(toolbarcentertop);
  this.toolbar = document.createElement("div");
  this.toolbar.className = "toolbar";
  toolbarcentertop.appendChild(this.toolbar);
  this.initFocalLengthOverlay();
  this.initSettings();
  this.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, function(e) {
    viewer.resizePanels({viewer:viewer});
    viewer.updateScreenModeButton(e.mode);
  });
  this.propertygrid = new Autodesk.Viewing.Private.PropertyPanel(viewer);
  this.addPanel(this.propertygrid);
  this.propertygrid.addVisibilityListener(function(visible) {
    viewer.setPropertiesButtonEnabled(visible);
  });
  this.propertygrid.setOpenOnSelect(this.prefs.values.openPropertiesOnSelect);
  if (!this.modelstructure) {
    var options = {docStructureConfig:this.config && this.config.docStructureConfig ? this.config.docStructureConfig : Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig, shadow:false};
    this.setModelStructurePanel(new Autodesk.Viewing.Extensions.ViewerModelStructurePanel(this, "Model Structure Loading...", options));
  }
  this.initMinTools();
  this.initNavTools();
  this.initCameraTools();
  this.initCameraStateMachine();
  this.initModelTools();
  this.initHomeButton();
  this.initViewCube();
  if (ENABLE_DEBUG) {
    this.initDebugTools();
  }
  this.initSearchBox();
  this.initContextMenu();
  this.progressbar = new Autodesk.Viewing.Private.ProgressBar(this.container);
  this.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function(e) {
    if (e.percent !== undefined) {
      viewer.progressbar.setPercent(e.percent);
    }
  }, false);
  this.selectionActive = false;
  this.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(event) {
    viewer.selectionActive = event.dbIdArray.length > 0;
  });
  this.initEscapeHandlers();
  this.updateScreenModeButton(this.getScreenMode());
  this.run();
  this.resize();
  return 0;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.uninitialize = function() {
  if (this.modelstructure) {
    this.modelstructure.uninitialize();
    this.modelstructure = null;
  }
  if (this.layersPanel) {
    this.layersPanel.uninitialize();
    this.layersPanel = null;
  }
  if (this.propertygrid) {
    this.propertygrid.uninitialize();
    this.propertygrid = null;
  }
  if (this.renderoptions) {
    this.renderoptions.uninitialize();
    this.renderoptions = null;
  }
  if (this.raaSPanel) {
    this.raaSPanel.uninitialize();
    this.raaSPanel = null;
  }
  if (this.raaSDataPanel) {
    this.raaSDataPanel.uninitialize();
    this.raaSPanel = null;
  }
  Autodesk.Viewing.Viewer3D.prototype.uninitialize.call(this);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setModelStructurePanel = function(modelStructurePanel) {
  var self = this;
  if (Autodesk.Viewing.Viewer3D.prototype.setModelStructurePanel.call(self, modelStructurePanel)) {
    this.modelstructure.addVisibilityListener(function(visible) {
      if (visible) {
        self.onPanelVisible(self.modelstructure, self);
      }
      self.setStructureButtonEnabled(visible);
    });
    return true;
  }
  return false;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initContextMenu = function() {
  var self = this;
  function isMultiSelect(event) {
    var isMac = navigator.userAgent.search("Mac OS") !== -1;
    return isMac && event.metaKey || !isMac && event.ctrlKey;
  }
  function isRightClick(event) {
    var rightButton = self.navigation.getUseLeftHandedInput() ? 0 : 2;
    if (event.button === rightButton) {
      return true;
    }
    return false;
  }
  this.objectContextMenu = new Autodesk.Viewing.Private.ObjectContextMenu(this.impl);
  this.canvas.addEventListener("mousedown", function(event) {
    if (isRightClick(event)) {
      self.startX = event.clientX;
      self.startY = event.clientY;
    }
  });
  this.canvas.addEventListener("mouseup", function(event) {
    if (isRightClick(event)) {
      if (event.clientX === self.startX && event.clientY === self.startY) {
        var result = self.impl.castRay(event.clientX, event.clientY);
        if (result.node) {
          if (!self.impl.selector.isSelectedOrParentIsSelected(result.node)) {
            if (!isMultiSelect(event)) {
              self.impl.selector.setSelection([result.node]);
            }
          }
        }
        return self.objectContextMenu.show(event);
      }
    }
    return true;
  }, false);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addOptionToggle = function(parent, tooltip, initialState, onchange, saveKey) {
  var self = this;
  var storedState = saveKey ? this.prefs.values[saveKey] : null;
  initialState = storedState !== null ? storedState : initialState;
  var handler = function(e) {
    var checked = e.target.checked;
    self.prefs.set(saveKey, checked);
    onchange(checked);
    e.stopPropagation();
  };
  var cbdef = {tooltip:tooltip, checked:initialState, onchange:handler};
  var li = document.createElement("li");
  li.className = "toolbar-submenu-listitem";
  var cb = document.createElement("input");
  cb.className = "toolbar-submenu-checkbox";
  cb.type = "checkbox";
  cb.id = cbdef.tooltip;
  li.appendChild(cb);
  var lbl = document.createElement("label");
  lbl.innerHTML = cbdef.tooltip;
  lbl.setAttribute("for", cbdef.tooltip);
  li.appendChild(lbl);
  parent.appendChild(li);
  cb.checked = cbdef.checked;
  cb.onchange = cbdef.onchange;
  cb.addEventListener("click", function(e) {
    var checked = cb.checked;
    if (saveKey) {
      self.prefs.set(saveKey, checked);
    }
    onchange(checked);
    e.stopPropagation();
  });
  lbl.addEventListener("click", function(e) {
    e.stopPropagation();
  });
  li.addEventListener("click", function(e) {
    var checked = !cb.checked;
    cb.checked = checked;
    if (saveKey) {
      self.prefs.set(saveKey, checked);
    }
    onchange(checked);
    e.stopPropagation();
  });
  if (saveKey) {
    this.prefs.addResetListener(saveKey, function(value) {
      cb.checked = value;
      onchange(value);
    });
  }
  return cb;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addOptionList = function(parent, label, optionList, initialIndex, onchange, saveKey) {
  var self = this;
  var storedState = this.prefs.values[saveKey];
  initialIndex = storedState !== null ? storedState : initialIndex;
  var handler = function(e) {
    var selectedIndex = e.target.selectedIndex;
    self.prefs.set(saveKey, selectedIndex);
    onchange(selectedIndex);
  };
  var selectElem = document.createElement("select");
  selectElem.className = "optionDropDown";
  for (var i = 0;i < optionList.length;i++) {
    var item = document.createElement("option");
    item.value = i;
    item.text = optionList[i];
    selectElem.add(item);
  }
  var li = document.createElement("li");
  li.className = "toolbar-submenu-select";
  var lbl = document.createElement("div");
  lbl.className = "toolbar-submenu-selectlabel";
  lbl.innerHTML = label;
  lbl.setAttribute("for", label);
  li.appendChild(lbl);
  li.appendChild(selectElem);
  parent.appendChild(li);
  selectElem.selectedIndex = initialIndex;
  selectElem.onchange = handler;
  this.prefs.addResetListener(saveKey, function(value) {
    selectElem.selectedIndex = value;
    onchange(value);
  });
  return selectElem;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addMenuButton = function(subtoolBarId, id, tooltip, onclick) {
  var button = Autodesk.Viewing.UI.ToolBar.createMenuButton(id, tooltip, onclick);
  this.toolBar.addToSubToolbar(subtoolBarId, button);
  return button;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initColorPicker = function() {
  var liColor = document.createElement("li");
  liColor.className = "color-picker";
  var backgroundButton = document.createElement("div");
  backgroundButton.className = "backgroundButton";
  var thecolorpicker = document.createElement("div");
  thecolorpicker.className = "cp-small thecolorpicker";
  backgroundButton.appendChild(thecolorpicker);
  liColor.appendChild(backgroundButton);
  var ctop = this.impl.clearColorTop;
  var ctopRGB = ctop.x * 255 << 16 | ctop.y * 255 << 8 | ctop.z * 255;
  var bgColorTextField = document.createElement("input");
  bgColorTextField.className = "backgroundColorText";
  bgColorTextField.type = "text";
  bgColorTextField.value = "#" + ctopRGB.toString(16);
  liColor.appendChild(bgColorTextField);
  var lastColor = bgColorTextField.value;
  var self = this;
  function changeColor(hex, hsv, rgb, skipUpdate) {
    if (hex.length != 7) {
      return;
    }
    for (var i = 1;i < hex.length;i++) {
      var thisNumber = parseInt(hex[i], 16);
      if (thisNumber < 0 || (thisNumber > 16 || thisNumber !== thisNumber)) {
        return;
      }
    }
    function shadeColor(color, scale) {
      var num = parseInt(color.slice(1), 16), R = (num >> 16 & 255) * scale, G = (num >> 8 & 255) * scale, B = (num & 255) * scale;
      return{r:R, g:G, b:B};
    }
    var lightc = shadeColor(hex, 1);
    var darkMultiple = 0.6521739130434783;
    if (!skipUpdate) {
      var carr = [lightc.r, lightc.g, lightc.b, 0 | lightc.r * darkMultiple, 0 | lightc.g * darkMultiple, 0 | lightc.b * darkMultiple];
      self.setBackgroundColor(carr[0], carr[1], carr[2], carr[3], carr[4], carr[5]);
      self.prefs.set("backgroundColorPreset", JSON.stringify(carr));
    }
    backgroundButton.style.background = hex;
    bgColorTextField.value = hex;
    lastColor = hex;
  }
  bgColorTextField.addEventListener("change", function() {
    changeColor(bgColorTextField.value);
    bgColorTextField.value = lastColor;
  });
  this.menuoptions.appendChild(liColor);
  ColorPicker(thecolorpicker, changeColor);
  backgroundButton.style.background = bgColorTextField.value;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initFPSStats = function() {
  var self = this;
  this.addOptionToggle(this.debugMenu.subMenu, "FPS statistics", false, function(checked) {
    if (checked && !self.impl.stats) {
      var stats = new Stats;
      stats.setMode(1);
      stats.domElement.style.position = "absolute";
      stats.domElement.style.bottom = "0px";
      stats.domElement.style.right = "0px";
      stats.domElement.style.visibility = "hidden";
      stats.domElement.style["z-index"] = 1;
      self.container.appendChild(stats.domElement);
      self.impl.stats = stats;
    }
    self.impl.stats.domElement.style.visibility = checked ? "visible" : "hidden";
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelStats = function() {
  var self = this;
  function updateModelStatContent(message) {
    var viewer = self.impl;
    var text = "";
    var model = self.model;
    if (model) {
      text += "Geom&nbsp;polys:&nbsp;" + model.geomPolyCount() + "<br>";
      text += "Instance&nbsp;polys:&nbsp;" + model.instancePolyCount() + "<br>";
      text += "Scenes:&nbsp;" + viewer.modelQueue.getSceneCount() + "<br>";
    }
    text += "# " + (message || "");
    self.modelStats.innerHTML = text;
  }
  function createModelStats() {
    self.modelStats = document.createElement("div");
    self.modelStats.className = "statspanel";
    self.container.appendChild(self.modelStats);
    self.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function(e) {
      if (e.message) {
        updateModelStatContent(e.message);
      }
    });
  }
  this.addOptionToggle(this.debugMenu.subMenu, "Model statistics", false, function(checked) {
    if (checked && !self.modelStats) {
      createModelStats();
      updateModelStatContent("");
    }
    self.modelStats.style.visibility = checked ? "visible" : "hidden";
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initExplodeSlider = function(modelToolsId) {
  var self = this;
  var explodeslider = this.explodeslider = document.createElement("input");
  explodeslider.className = "slider";
  explodeslider.type = "range";
  explodeslider.min = "0";
  explodeslider.max = "100";
  explodeslider.value = "0";
  explodeslider.width = "200";
  this.toolbar.appendChild(explodeslider);
  explodeslider.addEventListener("input", function(e) {
    self.explode(explodeslider.value / 100);
  });
  explodeslider.addEventListener("change", function(e) {
    self.explode(explodeslider.value / 100);
  });
  this.explodebutton = this.addMenuButton(modelToolsId, "toolbar-explodeTool", "Explode model", function(e) {
    var isHidden = explodeslider.style.visibility == "hidden" || explodeslider.style.visibility == "";
    self.showExplodeSlider(isHidden);
  });
  explodeslider.addEventListener("keyup", function(e) {
    if (e.keyCode === 27) {
      self.canvas.focus();
    }
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showExplodeSlider = function(show) {
  if (show) {
    this.modelTools.deselect(this.explodebutton.id);
    this.explodeslider.style.visibility = "visible";
  } else {
    this.modelTools.select(this.explodebutton.id);
    this.explodeslider.style.visibility = "hidden";
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showViewer3dOptions = function(show) {
  this.vieweroptions.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showRenderingOptions = function(show) {
  this.renderoptions.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showLayerManager = function(show) {
  this.layersPanel.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showRaaSPanel = function(show) {
  this.raaSPanel.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showRaaSDataPanel = function(show) {
  this.raaSDataPanel.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initMinTools = function() {
  if (this.canChangeScreenMode()) {
    var minToolsId = "minTools";
    this.minTools = this.toolBar.addSubToolbar(minToolsId, false);
    var viewer = this;
    this.minTools.minfullscreenbutton = this.addMenuButton(minToolsId, "toolbar-minfullscreenTool", "Full screen", function(e) {
      viewer.nextScreenMode();
    });
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initNavTools = function() {
  var viewer = this;
  this.navigationMode = Autodesk.Viewing.NAVIGATION_MODE.ORBIT;
  var navToolsId = "navTools";
  this.navTools = this.toolBar.addSubToolbar(navToolsId, true);
  this.navTools.orbitbutton = this.addMenuButton(navToolsId, "toolbar-orbitTool", "Orbit", function(e) {
    viewer.setNavigationMode(Autodesk.Viewing.NAVIGATION_MODE.ORBIT);
  });
  this.navTools.panbutton = this.addMenuButton(navToolsId, "toolbar-panTool", "Pan", function(e) {
    viewer.setNavigationMode(viewer.getNavigationMode() === Autodesk.Viewing.NAVIGATION_MODE.PAN ? Autodesk.Viewing.NAVIGATION_MODE.ORBIT : Autodesk.Viewing.NAVIGATION_MODE.PAN);
  });
  this.navTools.dollybutton = this.addMenuButton(navToolsId, "toolbar-zoomTool", "Zoom", function(e) {
    viewer.setNavigationMode(viewer.getNavigationMode() === Autodesk.Viewing.NAVIGATION_MODE.DOLLY ? Autodesk.Viewing.NAVIGATION_MODE.ORBIT : Autodesk.Viewing.NAVIGATION_MODE.DOLLY);
  });
  this.navTools.select(this.navTools.orbitbutton.id);
  viewer.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/turntable_cur.cur), wait";
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initRaaSTools = function() {
  var viewer = this;
  var raaSToolsId = "raaSTools";
  this.raaSTools = this.toolBar.addSubToolbar(raaSToolsId, false);
  var layers = this.raaSPanel = new Autodesk.Viewing.Extensions.RaaSPanel(this);
  this.addPanel(layers);
  var layers2 = this.raaSDataPanel = new Autodesk.Viewing.Extensions.RaaSDataPanel(this);
  this.addPanel(layers2);
  this.raaSTools.raaSButton1 = this.addMenuButton(raaSToolsId, "toolbar-raaSTool", "RaaS", function(e) {
    viewer.showRaaSPanel(!layers.isVisible());
  });
  this.raaSTools.raaSButton2 = this.addMenuButton(raaSToolsId, "toolbar-raaSDataTool", "RaaS Data", function(e) {
    document.getElementById("cameraPosition").innerText = "x = " + viewer.impl.camera.position.x + " y = " + viewer.impl.camera.position.y + " z = " + viewer.impl.camera.position.z;
    document.getElementById("cameraIsPerspective").innerText = viewer.impl.camera.isPerspective;
    document.getElementById("cameraUp").innerText = "x = " + viewer.impl.camera.up.x + " y = " + viewer.impl.camera.up.y + " z = " + viewer.impl.camera.up.z;
    document.getElementById("cameraTarget").innerText = "x = " + viewer.impl.camera.target.x + " y = " + viewer.impl.camera.target.y + " z = " + viewer.impl.camera.target.z;
    document.getElementById("cameraNear").innerText = viewer.impl.camera.near;
    document.getElementById("cameraFar").innerText = viewer.impl.camera.far;
    document.getElementById("cameraFov").innerText = viewer.impl.camera.fov;
    document.getElementById("cameraAspect").innerText = viewer.impl.camera.aspect;
    stderr("camera debug outputs start ...");
    stderr("eye : " + JSON.stringify([viewer.impl.camera.position.x, viewer.impl.camera.position.y, viewer.impl.camera.position.z]));
    stderr("target : " + JSON.stringify([viewer.impl.camera.target.x, viewer.impl.camera.target.y, viewer.impl.camera.target.z]));
    stderr("up : " + JSON.stringify([viewer.impl.camera.up.x, viewer.impl.camera.up.y, viewer.impl.camera.up.z]));
    stderr("fov : " + JSON.stringify([viewer.impl.camera.fov]));
    stderr("camera debug outputs end ...");
    document.getElementById("lightName").innerText = viewer.impl.LightPresets[viewer.impl.currentLightPreset].name;
    document.getElementById("lightPath").innerText = viewer.impl.LightPresets[viewer.impl.currentLightPreset].path;
    document.getElementById("lightTonemap").innerText = viewer.impl.LightPresets[viewer.impl.currentLightPreset].tonemap;
    document.getElementById("lightE_bias").innerText = viewer.impl.LightPresets[viewer.impl.currentLightPreset].E_bias;
    document.getElementById("lightDirectLightColor").innerText = "r = " + viewer.impl.dir_light1.color.r + " g = " + viewer.impl.dir_light1.color.g + " b = " + viewer.impl.dir_light1.color.b;
    document.getElementById("lightAmbientColor").innerText = "r = " + viewer.impl.amb_light.color.r + " g = " + viewer.impl.amb_light.color.g + " b = " + viewer.impl.amb_light.color.b;
    document.getElementById("lightMultiplier").innerText = viewer.impl.LightPresets[viewer.impl.currentLightPreset].lightMultiplier;
    document.getElementById("lightBgColorGradientClearColorTop").innerText = "x = " + viewer.impl.clearColorTop.x + " y = " + viewer.impl.clearColorTop.y + " z = " + viewer.impl.clearColorTop.z;
    document.getElementById("lightBgColorGradientClearColorBottom").innerText = "x = " + viewer.impl.clearColorBottom.x + " y = " + viewer.impl.clearColorBottom.y + " z = " + viewer.impl.clearColorBottom.z;
    document.getElementById("renderOptionsSaoToggle").innerText = viewer.renderoptions.saoToggle.checked;
    document.getElementById("renderOptionsSaoRadius").innerText = viewer.renderoptions.saoRadius.value;
    document.getElementById("renderOptionsSaoIntensity").innerText = viewer.renderoptions.saoIntensity.value;
    document.getElementById("renderOptionsGamma").innerText = viewer.renderoptions.gamma.value;
    document.getElementById("renderOptionsExposureBias").innerText = viewer.renderoptions.exposureBias.value;
    document.getElementById("renderOptionsWhitePointIntensity").innerText = viewer.renderoptions.whiteScale.value;
    document.getElementById("renderOptionsFovAngle").innerText = viewer.renderoptions.fovAngle.value;
    viewer.showRaaSDataPanel(!layers2.isVisible());
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.createCameraSubmenu = function() {
  var submenu = document.createElement("ul");
  var viewer = this;
  this.cameraMenu.fittoviewbutton = Autodesk.Viewing.UI.ToolBar.createMenuButton("toolbar-fitToViewTool", "Fit to view (F)", function(e) {
    viewer.impl.controls.fitToView();
  });
  submenu.appendChild(this.cameraMenu.fittoviewbutton);
  this.cameraMenu.fovbutton = Autodesk.Viewing.UI.ToolBar.createMenuButton("toolbar-focalLengthTool", "Focal length (Ctrl+Shift drag)", function(e) {
    viewer.setNavigationMode(viewer.getNavigationMode() === Autodesk.Viewing.NAVIGATION_MODE.FOV ? Autodesk.Viewing.NAVIGATION_MODE.ORBIT : Autodesk.Viewing.NAVIGATION_MODE.FOV);
  });
  var fovButton = this.cameraMenu.fovbutton.childNodes[this.cameraMenu.fovbutton.childNodes.length - 1];
  Autodesk.Viewing.Private.addClass(fovButton, "disabled-button");
  submenu.appendChild(this.cameraMenu.fovbutton);
  this.cameraMenu.rollbutton = Autodesk.Viewing.UI.ToolBar.createMenuButton("toolbar-rollTool", "Roll (Alt+Shift drag)", function(e) {
    viewer.setNavigationMode(viewer.getNavigationMode() === Autodesk.Viewing.NAVIGATION_MODE.ROLL ? Autodesk.Viewing.NAVIGATION_MODE.ORBIT : Autodesk.Viewing.NAVIGATION_MODE.ROLL);
  });
  var rollButton = this.cameraMenu.rollbutton.childNodes[this.cameraMenu.rollbutton.childNodes.length - 1];
  Autodesk.Viewing.Private.addClass(rollButton, "disabled-button");
  submenu.appendChild(this.cameraMenu.rollbutton);
  return submenu;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initCameraTools = function() {
  var cameraToolsId = "cameraTools";
  this.cameraMenu = this.toolBar.addSubToolbar(cameraToolsId, false);
  var cameraButton = this.addMenuButton(cameraToolsId, "toolbar-cameraSubmenuTool", "Camera interactions", null);
  var cameraSubmenu = this.createCameraSubmenu();
  this.toolBar.attachSubMenu(cameraButton, cameraSubmenu);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initCameraStateMachine = function() {
  var viewer = this;
  function disableButton(buttonGroup) {
    var button = buttonGroup.childNodes[buttonGroup.childNodes.length - 1];
    Autodesk.Viewing.Private.addClass(button, "disabled-button");
  }
  function enableButton(buttonGroup) {
    var button = buttonGroup.childNodes[buttonGroup.childNodes.length - 1];
    Autodesk.Viewing.Private.removeClass(button, "disabled-button");
  }
  viewer.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function(event) {
    viewer.navTools.deselectAll();
    disableButton(this.cameraMenu.fovbutton);
    disableButton(this.cameraMenu.rollbutton);
    switch(event.value) {
      case Autodesk.Viewing.NAVIGATION_MODE.ORBIT:
        viewer.navTools.select(viewer.navTools.orbitbutton.id);
        viewer.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/turntable_cur.cur), wait";
        break;
      case Autodesk.Viewing.NAVIGATION_MODE.DOLLY:
        viewer.navTools.select(viewer.navTools.dollybutton.id);
        viewer.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/dolly_cur.cur), wait";
        break;
      case Autodesk.Viewing.NAVIGATION_MODE.PAN:
        viewer.navTools.select(viewer.navTools.panbutton.id);
        viewer.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/pan_cur.cur), wait";
        break;
      case Autodesk.Viewing.NAVIGATION_MODE.FOV:
        enableButton(viewer.cameraMenu.fovbutton);
        viewer.canvas.style.cursor = "url(" + RESOURCE_ROOT + "icons/fov_cur.cur), wait";
        break;
      case Autodesk.Viewing.NAVIGATION_MODE.ROLL:
        enableButton(viewer.cameraMenu.rollbutton);
        viewer.canvas.style.cursor = "auto";
        break;
      default:
        viewer.canvas.style.cursor = "auto";
        break;
    }
    viewer.navigationMode = event.value;
    viewer.showFocalLengthOverlay(viewer.navigationMode === Autodesk.Viewing.NAVIGATION_MODE.FOV);
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelTools = function() {
  var viewer = this;
  var modelToolsId = "modelTools";
  this.modelTools = this.toolBar.addSubToolbar(modelToolsId, false);
  this.modelTools.structurebutton = this.addMenuButton(modelToolsId, "toolbar-modelStructureTool", "Model structure", function(e) {
    if (viewer.modelstructure) {
      viewer.showModelStructurePanel(!viewer.modelstructure.isVisible());
    }
  });
  this.initExplodeSlider(modelToolsId);
  this.addMenuButton(modelToolsId, "toolbar-resetTool", "Reset model", function(e) {
    viewer.explode(0);
    viewer.explodeslider.value = 0;
    viewer.showAll();
  });
  this.modelTools.propertiesbutton = this.addMenuButton(modelToolsId, "toolbar-propertiesTool", "Properties", function(e) {
    if (viewer.propertygrid.isVisible()) {
      viewer.propertygrid.setVisible(false);
      viewer.modelTools.select(viewer.modelTools.propertiesbutton.id);
    } else {
      if (!viewer.propertygrid.getNodeId()) {
        viewer.propertygrid.setDefaultProperties();
      }
      viewer.propertygrid.setVisible(true);
      viewer.modelTools.deselect(viewer.modelTools.propertiesbutton.id);
    }
  });
  this.modelTools.setToolVisibility(this.modelTools.propertiesbutton.id, false);
  var vieweropts = this.vieweroptions = new Autodesk.Viewing.Private.Viewer3dSettingsPanel(this);
  this.addPanel(this.vieweroptions);
  var vieweroptionButton = this.addMenuButton(modelToolsId, "toolbar-settingsTool", "", null);
  var optionMenu = this.createOptionsMenu(vieweroptionButton);
  this.toolBar.attachSubMenu(vieweroptionButton, optionMenu);
  if (ENABLE_DEBUG) {
    var opts = this.renderoptions = new Autodesk.Viewing.Private.RenderOptionsPanel(this);
    this.addPanel(opts);
    this.addMenuButton(modelToolsId, "toolbar-renderOptionsTool", "Rendering options", function(e) {
      viewer.showRenderingOptions(!opts.isVisible());
    });
  }
  if (this.canChangeScreenMode()) {
    this.modelTools.fullscreenbutton = this.addMenuButton(modelToolsId, "toolbar-fullscreenTool", "Full screen", function(e) {
      viewer.nextScreenMode();
    });
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertiesOnSelect = function(onSelect) {
  if (onSelect) {
    this.modelTools.setToolVisibility(this.modelTools.propertiesbutton.id, false);
  } else {
    this.modelTools.setToolVisibility(this.modelTools.propertiesbutton.id, true);
  }
  this.propertygrid.setOpenOnSelect(onSelect);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.addDivider = function(parent) {
  var item = document.createElement("li");
  item.className = "toolbar-submenu-horizontal-divider";
  parent.appendChild(item);
  return item;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.createOptionsMenu = function(parent) {
  var viewer = this;
  this.menuoptions = document.createElement("ul");
  this.menuoptions.style.width = "310px";
  var env_list = [];
  for (var i = 0;i < viewer.impl.LightPresets.length;i++) {
    env_list.push(viewer.impl.LightPresets[i].name);
  }
  var envList = this.addOptionList(this.menuoptions, "Background and lighting", env_list, 4, function(selectedIndex) {
    if (viewer.blockEvent) {
      return;
    }
    viewer.impl.setLightPreset(selectedIndex);
  }, "lightPreset");
  viewer.addEventListener(Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, function(e) {
    viewer.blockEvent = true;
    envList.selectedIndex = viewer.impl.currentLightPreset;
    viewer.blockEvent = false;
  });
  parent.addEventListener("mouseout", function(e) {
    if (!e.target) {
      return;
    }
    if (e.target === viewer.menuoptions || e.target.className === "menu-option") {
      envList.blur();
    }
  });
  envList.addEventListener("mouseout", function(e) {
    if (!e.target) {
      return;
    }
    if (e.target === viewer.container || (e.target === viewer.menuoptions || e.target.className === "menu-option")) {
      envList.blur();
    }
  });
  this.addOptionToggle(this.menuoptions, "Display lines", true, function(checked) {
    viewer.hideLines(!checked);
  }, "lineRendering");
  this.addDivider(this.menuoptions);
  var performanceButton = document.createElement("li");
  performanceButton.className = "toolbar-submenu-listitem";
  var perfLabel = document.createElement("label");
  perfLabel.innerHTML = "Performance and appearance settings";
  performanceButton.appendChild(perfLabel);
  performanceButton.addEventListener("click", function() {
    viewer.showViewer3dOptions(true);
    viewer.vieweroptions.selectTab(Autodesk.Viewing.Private.PerformanceTab);
  });
  performanceButton.style.opacity = 1;
  this.menuoptions.appendChild(performanceButton);
  this.addDivider(this.menuoptions);
  var navigationButton = document.createElement("li");
  navigationButton.className = "toolbar-submenu-listitem";
  var navigLabel = document.createElement("label");
  navigLabel.innerHTML = "Navigation and selection settings";
  navigationButton.appendChild(navigLabel);
  navigationButton.addEventListener("click", function() {
    viewer.showViewer3dOptions(true);
    viewer.vieweroptions.selectTab(Autodesk.Viewing.Private.NavigationTab);
  });
  navigationButton.style.opacity = 1;
  this.menuoptions.appendChild(navigationButton);
  return this.menuoptions;
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initDebugTools = function() {
  var debugMenuId = "debugTools";
  this.debugMenu = this.toolBar.addSubToolbar(debugMenuId, false);
  var viewer = this;
  var layers = this.layersPanel = new Autodesk.Viewing.Private.LayersPanel(this);
  this.addPanel(layers);
  this.addMenuButton(debugMenuId, "toolbar-renderOptionsToolXXX", "Layer Manager", function(e) {
    viewer.showLayerManager(!layers.isVisible());
  });
  var debugButton = this.addMenuButton(debugMenuId, "toolbar-debugTool", "", null);
  this.debugMenu.subMenu = document.createElement("ul");
  this.debugMenu.subMenu.style.width = "180px";
  this.initFPSStats();
  this.addDivider(this.debugMenu.subMenu);
  this.initModelStats();
  this.addDivider(this.debugMenu.subMenu);
  this.addOptionToggle(this.debugMenu.subMenu, "Show search bar", false, function(checked) {
    viewer.searchMenu.setVisibility(checked);
  });
  this.toolBar.attachSubMenu(debugButton, this.debugMenu.subMenu);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initEscapeHandlers = function() {
  var viewer = this;
  this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
    if (viewer.renderoptions) {
      if (viewer.renderoptions.isVisible()) {
        viewer.renderoptions.setVisible(false);
        return;
      }
    }
    if (viewer.explodeslider.style.visibility !== "hidden" && viewer.explodeslider.style.visibility !== "") {
      viewer.showExplodeSlider(false);
      return;
    }
    if (viewer.navigationMode !== Autodesk.Viewing.NAVIGATION_MODE.ORBIT) {
      viewer.setNavigationMode(Autodesk.Viewing.NAVIGATION_MODE.ORBIT);
      return;
    }
    if (viewer.selectionActive) {
      viewer.clearSelection();
      return;
    }
    if (!viewer.areAllVisible()) {
      viewer.showAll();
      return;
    }
    if (Autodesk.Viewing.Private.AlertBox.dismiss()) {
      return;
    }
    for (var i = 0;i < viewer.dockingPanels.length;++i) {
      var panel = viewer.dockingPanels[i];
      if (panel.container.style.display !== "none" && panel.container.style.display !== "") {
        if (panel.container === viewer.modelstructure) {
          viewer.showModelStructurePanel(false);
        } else {
          panel.setVisible(false);
        }
        return;
      }
    }
    if (viewer.escapeScreenMode()) {
      return;
    }
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initHomeButton = function() {
  var homeViewContainer = document.createElement("div");
  homeViewContainer.className = "homeViewWrapper";
  var homeView = document.createElement("img");
  homeView.className = "homeView";
  homeView.src = RESOURCE_ROOT + "icons/resetview_icon.png";
  homeView.style.cursor = "pointer";
  homeViewContainer.appendChild(homeView);
  this.container.appendChild(homeViewContainer);
  this.homeViewContainer = homeViewContainer;
  var self = this;
  homeView.addEventListener("click", function(e) {
    self.navigation.setRequestHomeView(true);
  });
  homeView.addEventListener("contextmenu", function(e) {
    self.navigation.setRequestHomeView(true);
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initViewCube = function() {
  this.viewcube = document.createElement("div");
  this.viewcube.className = "viewcube";
  this.container.appendChild(this.viewcube);
  this.cube = new Autocam.ViewCube("cube", this.autocam, this.viewcube);
  this.displayViewCube(this.prefs.values.viewCube);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.displayViewCube = function(display) {
  this.viewcube.style.display = display ? "block" : "none";
  if (this.homeViewContainer) {
    this.homeViewContainer.style.right = display ? "120px" : "4px";
  }
  if (display) {
    this.impl.needsClear = true;
    this.autocam.refresh();
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initSearchBox = function() {
  var searchMenuId = "searchBox";
  this.searchMenu = this.toolBar.addSubToolbar(searchMenuId, false);
  this.searchMenu.setVisibility(false);
  var lisearch = document.createElement("li");
  var searchbox = document.createElement("input");
  searchbox.type = "search";
  searchbox.results = 5;
  searchbox.placeholder = "Search";
  searchbox.incremental = "incremental";
  searchbox.autosave = this.container.id + "search_autosave";
  lisearch.appendChild(searchbox);
  this.toolBar.addToSubToolbar(searchMenuId, lisearch);
  var self = this;
  this.searchbox = searchbox;
  searchbox.addEventListener("change", function(e) {
    stderr("search " + searchbox.value);
    self.search(searchbox.value, function(resultIds) {
      self.isolateById(resultIds);
    });
  });
  searchbox.addEventListener("keypress", function(e) {
    if (e.keyCode === 27) {
      setTimeout(function() {
        if (searchbox.value !== "") {
          searchbox.value = "";
        }
      }, 0);
    }
  });
  this.toolBar.addEventListener("mouseleave", function(e) {
    var id;
    function reset() {
      clearTimeout(id);
    }
    self.toolBar.addEventListener("mouseenter", reset);
    function clearFocus() {
      self.toolBar.removeEventListener("mouseenter", reset);
      if (document.activeElement === searchbox) {
        self.canvas.focus();
      }
    }
    id = setTimeout(clearFocus, 2E3);
  });
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertiesButtonEnabled = function(enabled) {
  if (enabled) {
    this.modelTools.deselect(this.modelTools.propertiesbutton.id);
  } else {
    this.modelTools.select(this.modelTools.propertiesbutton.id);
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.setStructureButtonEnabled = function(enabled) {
  if (enabled) {
    this.modelTools.deselect(this.modelTools.structurebutton.id);
  } else {
    this.modelTools.select(this.modelTools.structurebutton.id);
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showModelStructurePanel = function(show) {
  this.modelstructure.setVisible(show);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.onPanelVisible = function(panel, viewer) {
  if (!viewer) {
    viewer = this;
  }
  viewer.dockingPanels.splice(viewer.dockingPanels.indexOf(panel), 1);
  viewer.dockingPanels.splice(0, 0, panel);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initFocalLengthOverlay = function() {
  var container = this.focallength = document.createElement("div");
  container.className = "focallength";
  var table = document.createElement("table");
  var tbody = document.createElement("tbody");
  table.appendChild(tbody);
  container.appendChild(table);
  this.container.appendChild(container);
  var row = tbody.insertRow(-1);
  var cell = row.insertCell(0);
  cell.textContent = "Focal Length:";
  cell = row.insertCell(1);
  cell.textContent = "";
  cell.style.width = "4em";
  cell.style.textAlign = "right";
  var myFocalLength = 0;
  var self = this;
  this.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(e) {
    var camFocalLength = self.getFocalLength();
    if (myFocalLength !== camFocalLength) {
      myFocalLength = camFocalLength;
      cell.textContent = camFocalLength.toString() + " mm";
    }
  });
  container.style.visibility = "hidden";
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.showFocalLengthOverlay = function(state) {
  if (this.focallength) {
    var isOn = this.focallength.style.visibility !== "hidden";
    if (isOn !== state) {
      this.focallength.style.visibility = state ? "visible" : "hidden";
    }
  }
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.initSettings = function() {
  var self = this;
  var nav = window.navigator;
  this.isAndroid = nav.platform.indexOf("armv") != -1 || nav.appVersion && nav.appVersion.indexOf("Android") != -1;
  var defaultSettings = {"ambientShadows":!this.isAndroid, "antialiasing":!this.isAndroid, "progressiveRendering":true, "environmentMap":false, "openPropertiesOnSelect":true, "ghosting":true, "viewCube":true, "lineRendering":true, "lightPreset":this.isAndroid || _isIE11 ? 0 : this.impl.DefaultLightPreset, "backgroundColorPreset":null, "reverseMouseZoomDir":false, "alwaysUsePivot":false, "zoomTowardsPivot":false, "orbitPastWorldPoles":true, "leftHandedMouseSetup":false, "clickToSetCOI":false, "optimizeNavigation":false};
  this.prefs.load(defaultSettings);
  this.setQualityLevel(this.prefs.values.ambientShadows, this.prefs.values.antialiasing);
  this.setGhosting(this.prefs.values.ghosting);
  this.setProgressiveRendering(this.prefs.values.progressiveRendering);
  this.setClickToSetCOI(this.prefs.values.clickToSetCOI);
  this.setOptimizeNavigation(this.prefs.values.optimizeNavigation);
  this.navigation.setUsePivotAlways(this.prefs.values.alwaysUsePivot);
  this.navigation.setReverseZoomDirection(this.prefs.values.reverseMouseZoomDir);
  this.navigation.setZoomTowardsPivot(this.prefs.values.zoomTowardsPivot);
  this.navigation.setOrbitPastWorldPoles(this.prefs.values.orbitPastWorldPoles);
  this.navigation.setUseLeftHandedInput(this.prefs.values.leftHandedMouseSetup);
  this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function() {
    this.hideLines(!this.prefs.values.lineRendering);
  });
  var bacStr = this.prefs.values.backgroundColorPreset;
  if (bacStr) {
    var bac;
    try {
      var bac = JSON.parse(bacStr);
      this.impl.setClearColors(bac[0], bac[1], bac[2], bac[3], bac[4], bac[5]);
    } catch (e) {
      this.prefs.set("backgroundColorPreset", null);
    }
  }
  this.impl.setLightPreset(this.prefs.values.lightPreset);
};
Autodesk.Viewing.Private.GuiViewer3D.prototype.updateScreenModeButton = function(mode) {
  this.container.classList.remove("screenMode-kFullBrowser");
  this.container.classList.remove("screenMode-kFullScreen");
  var cls;
  switch(mode) {
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
      if (!this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
        cls = "screenMode-kFullBrowser";
      }
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
      if (this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
        cls = "screenMode-kFullBrowser";
      } else {
        cls = "screenMode-kFullScreen";
      }
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
      cls = "screenMode-kFullScreen";
      break;
  }
  if (cls) {
    this.container.classList.add(cls);
  }
};
AutodeskNamespace("Autodesk.Viewing.Private");
Autodesk.Viewing.Private.GuiViewer2D = function(container, config) {
  Autodesk.Viewing.Viewer2D.call(this, container, config);
};
Autodesk.Viewing.Private.GuiViewer2D.prototype = Object.create(Autodesk.Viewing.Viewer2D.prototype);
Autodesk.Viewing.Private.GuiViewer2D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer2D;
Autodesk.Viewing.Private.GuiViewer2D.prototype.initialize = function() {
  var viewerErrorCode = Autodesk.Viewing.Viewer2D.prototype.initialize.call(this);
  if (viewerErrorCode > 0) {
    return viewerErrorCode;
  }
  this.toolBar = new Autodesk.Viewing.UI.ToolBar(this.container);
  this.initNavTools();
  this.initModelTools();
  this.initEscapeHandlers();
  this.initHomeButton();
  var self = this;
  this.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, function(e) {
    self.updateScreenModeButton(e.mode);
  });
  this.updateScreenModeButton(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal);
  return 0;
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initNavTools = function() {
  var viewer = this;
  var navToolsId = "navTools";
  this.navTools = this.toolBar.addSubToolbar(navToolsId, true);
  this.navTools.panbutton = this.addMenuButton(navToolsId, "toolbar-panTool", "Pan", function(e) {
    viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
  });
  this.navTools.dollybutton = this.addMenuButton(navToolsId, "toolbar-zoomTool", "Zoom", function(e) {
    viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.ZOOM);
  });
  this.navTools.select(this.navTools.panbutton.id);
  this.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function(event) {
    viewer.navTools.deselectAll();
    switch(event.value) {
      case VIEWER2D_NAVIGATION_MODE.PAN:
        viewer.navTools.select(viewer.navTools.panbutton.id);
        viewer.impl.container.style.cursor = "url(" + RESOURCE_ROOT + "icons/pan_cur.cur), wait";
        break;
      case VIEWER2D_NAVIGATION_MODE.ZOOM:
        viewer.navTools.select(viewer.navTools.dollybutton.id);
        viewer.impl.container.style.cursor = "url(" + RESOURCE_ROOT + "icons/dolly_cur.cur), wait";
        break;
      default:
        viewer.impl.container.style.cursor = "auto";
        break;
    }
  });
  this.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initModelTools = function() {
  if (this.canChangeScreenMode()) {
    var modelToolsId = "modelTools";
    this.modelTools = this.toolBar.addSubToolbar(modelToolsId, false);
    var viewer = this;
    this.modelTools.fullscreenbutton = this.addMenuButton(modelToolsId, "toolbar-fullscreenTool", "Full screen", function(e) {
      viewer.nextScreenMode();
    });
  }
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initEscapeHandlers = function() {
  var viewer = this;
  this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
    if (viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN)) {
      return;
    }
    if (viewer.escapeScreenMode()) {
      return;
    }
  }, false);
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.initHomeButton = function() {
  var viewer = this;
  this.homeViewContainer = document.createElement("div");
  var homeViewContainer = this.homeViewContainer;
  homeViewContainer.className = "homeViewWrapper";
  var homeView = document.createElement("img");
  homeView.className = "homeView";
  homeView.src = RESOURCE_ROOT + "icons/resetview_icon.png";
  homeView.style.cursor = "pointer";
  homeViewContainer.appendChild(homeView);
  homeViewContainer.style.width = "auto";
  this.container.appendChild(homeViewContainer);
  homeView.addEventListener("click", function() {
    viewer.impl.goHome();
  });
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.addMenuButton = function(subtoolBarId, id, tooltip, onclick) {
  var button = Autodesk.Viewing.UI.ToolBar.createMenuButton(id, tooltip, onclick);
  this.toolBar.addToSubToolbar(subtoolBarId, button);
  return button;
};
Autodesk.Viewing.Private.GuiViewer2D.prototype.updateScreenModeButton = function(mode) {
  this.container.classList.remove("screenMode-kFullBrowser");
  this.container.classList.remove("screenMode-kFullScreen");
  var cls;
  switch(mode) {
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
      if (!this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
        cls = "screenMode-kFullBrowser";
      }
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
      if (this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
        cls = "screenMode-kFullBrowser";
      } else {
        cls = "screenMode-kFullScreen";
      }
      break;
    case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
      cls = "screenMode-kFullScreen";
      break;
  }
  if (cls) {
    this.container.classList.add(cls);
  }
};
AutodeskNamespace("Autodesk.Viewing.Private");
var auth = null;
var VIEWING_URL;
var SEARCH_URL;
var RESOURCE_ROOT = "";
Autodesk.Viewing.Private.env = null;
Autodesk.Viewing.Private.logger = null;
Autodesk.Viewing.Private.refreshToken = null;
Autodesk.Viewing.Private.lastTokenRefreshTime = null;
var USE_OAUTH_NONE = true;
var USE_OAUTH_ZERO = false;
var USE_OAUTH_ONE = false;
var USE_OAUTH_TWO = false;
var SHOULD_SET_TOKEN = true;
Autodesk.Viewing.Private.EnvironmentConfigurations = {Local:{RESOURCE:"", VIEWING:"https://viewing-dev.api.autodesk.com/viewingservice/v1", SEARCH:"https://search-dev.api.autodesk.com/search/v1"}, Development:{RESOURCE:"https://viewing-dev.api.autodesk.com/viewingservice/v1/viewers/", VIEWING:"https://viewing-dev.api.autodesk.com/viewingservice/v1", SEARCH:"https://search-dev.api.autodesk.com/search/v1"}, Staging:{RESOURCE:"https://viewing-staging.api.autodesk.com/viewingservice/v1/viewers/", VIEWING:"https://viewing-staging.api.autodesk.com/viewingservice/v1", 
SEARCH:"https://search-staging.api.autodesk.com/search/v1"}, Production:{RESOURCE:"https://viewing.api.autodesk.com/viewingservice/v1/viewers/", VIEWING:"https://viewing.api.autodesk.com/viewingservice/v1", SEARCH:"https://search.api.autodesk.com/search/v1"}, AutodeskDevelopment:{RESOURCE:"https://developer-dev.api.autodesk.com/viewingservice/v1/viewers/", VIEWING:"https://developer-dev.api.autodesk.com/viewingservice/v1", SEARCH:"https://search-dev.api.autodesk.com/search/v1"}, AutodeskStaging:{RESOURCE:"https://developer-stg.api.autodesk.com/viewingservice/v1/viewers/", 
VIEWING:"https://developer-stg.api.autodesk.com/viewingservice/v1", SEARCH:"https://search-staging.api.autodesk.com/search/v1"}, AutodeskProduction:{RESOURCE:"https://developer.api.autodesk.com/viewingservice/v1/viewers/", VIEWING:"https://developer.api.autodesk.com/viewingservice/v1", SEARCH:"https://search.api.autodesk.com/search/v1"}};
Autodesk.Viewing.Private.setAuthTokenInCookie = function(accessToken, onSuccessCallback) {
  var token = {"oauth":{"token":""}};
  token.oauth.token = accessToken;
  var xhr = new XMLHttpRequest;
  xhr.open("POST", VIEWING_URL + "/token", true);
  xhr.setRequestHeader("Content-Type", "application/json");
  xhr.withCredentials = true;
  if (onSuccessCallback) {
    xhr.onload = onSuccessCallback;
  }
  xhr.send(JSON.stringify(token));
};
Autodesk.Viewing.Private.setApigeeTokenInCookie = function(accessToken, onSuccessCallback) {
  var xhr = new XMLHttpRequest;
  var url = VIEWING_URL.substring(0, VIEWING_URL.indexOf("/viewingservice"));
  xhr.open("POST", url + "/utility/v1/settoken", true);
  xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  xhr.withCredentials = true;
  if (onSuccessCallback) {
    xhr.onload = onSuccessCallback;
  }
  xhr.send("access-token=" + accessToken);
};
Autodesk.Viewing.Private.initializeEnvironmentVariable = function(options) {
  var env;
  if (options && options.env) {
    env = options.env;
  } else {
    switch(window.location.hostname) {
      case "viewing-dev.api.autodesk.com":
        env = "Development";
        break;
      case "viewing-staging.api.autodesk.com":
        env = "Staging";
        break;
      case "viewing.api.autodesk.com":
        env = "Production";
        break;
      case "developer-dev.api.autodesk.com":
        env = "AutodeskDevelopment";
        break;
      case "developer-stg.api.autodesk.com":
        env = "AutodeskStaging";
        break;
      case "developer.api.autodesk.com":
        env = "AutodeskProduction";
        break;
      case "ec2-23-20-101-198.compute-1.amazonaws.com":
        env = "Development";
        break;
      case "localhost.autodesk.com":
        env = "Local";
        break;
      case "":
        env = "Local";
        break;
      case "127.0.0.1":
        env = "Local";
        break;
      default:
        env = "AutodeskProduction";
    }
  }
  console.log("Host name : " + window.location.hostname);
  console.log("Environment initialized as : " + env);
  Autodesk.Viewing.Private.env = env;
};
Autodesk.Viewing.Private.initializeServiceEndPoints = function() {
  var config = Autodesk.Viewing.Private.EnvironmentConfigurations[Autodesk.Viewing.Private.env];
  VIEWING_URL = config["VIEWING"];
  SEARCH_URL = config["SEARCH"];
  RESOURCE_ROOT = config["RESOURCE"];
};
Autodesk.Viewing.Private.initializeAuth = function(onSuccessCallback, options) {
  auth = true;
  var accessToken;
  if (options) {
    if (options.getAccessToken) {
      accessToken = options.getAccessToken();
    } else {
      if (options.accessToken) {
        accessToken = options.accessToken;
      } else {
        accessToken = Autodesk.Viewing.Private.getParameterByName("accessToken");
      }
    }
    Autodesk.Viewing.Private.refreshToken = options.refreshToken;
  } else {
    accessToken = Autodesk.Viewing.Private.getParameterByName("accessToken");
  }
  if (!accessToken) {
    accessToken = "bebhjjAIDUpa/pz/EBC3RvTeknU=";
    console.log("Warning : no access token is provided. Use built in token : " + accessToken);
  }
  if (SHOULD_SET_TOKEN) {
    if (Autodesk.Viewing.Private.env.indexOf("Autodesk") == 0) {
      Autodesk.Viewing.Private.setApigeeTokenInCookie(accessToken, onSuccessCallback);
    } else {
      Autodesk.Viewing.Private.setAuthTokenInCookie(accessToken, onSuccessCallback);
    }
  }
  Autodesk.Viewing.Private.initializeLogger(accessToken);
  Autodesk.Viewing.Private.lastTokenRefreshTime = Date.now();
  setInterval(Autodesk.Viewing.Private.heartBeat, 60 * 1E3);
  return auth;
};
Autodesk.Viewing.Private.initializeLogger = function(accessToken) {
  var loggerConfig = {console:false, viewingservice:true, webstorage:false, endpoint:VIEWING_URL, flushThreshold:10};
  var logger = Autodesk.Viewing.Private.logger = new Autodesk.Viewing.Private.Logger(loggerConfig);
  var userInfo = {viewer_current_time:Date.now(), viewer_user_access_token:accessToken, viewer_user_host_url:window.location.hostname, viewer_user_agent:navigator.userAgent};
  logger.log(userInfo);
};
Autodesk.Viewing.Private.heartBeat = function() {
  if (Date.now() - Autodesk.Viewing.Private.logger.lastFlushTime > 1E3 * 60) {
    Autodesk.Viewing.Private.logger.flush();
  }
  if (Date.now() - Autodesk.Viewing.Private.lastTokenRefreshTime > 1E3 * 60 * 25) {
    var tokenRefreshFunc = Autodesk.Viewing.Private.refreshToken;
    if (tokenRefreshFunc) {
      var accessToken = tokenRefreshFunc();
      Autodesk.Viewing.Private.lastTokenRefreshTime = Date.now();
      if (Autodesk.Viewing.Private.env.indexOf("Autodesk") == 0) {
        Autodesk.Viewing.Private.setApigeeTokenInCookie(accessToken);
      } else {
        Autodesk.Viewing.Private.setAuthTokenInCookie(accessToken);
      }
    }
  }
};
Autodesk.Viewing.Private.getAuthObject = function() {
  return auth;
};
Autodesk.Viewing.Private.getParameterByName = function(name) {
  return Autodesk.Viewing.Private.getParameterByNameFromPath(name, window.location.href);
};
Autodesk.Viewing.Private.getParameterByNameFromPath = function(name, url) {
  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regexS = "[\\?&]" + name + "=([^&#]*)";
  var regex = new RegExp(regexS);
  var results = regex.exec(url);
  if (results == null) {
    return "";
  } else {
    return decodeURIComponent(results[1].replace(/\+/g, " "));
  }
};
Autodesk.Viewing.Private.getDemoDocumentURN = function() {
  var documentId;
  switch(Autodesk.Viewing.Private.env) {
    case "Development":
      documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvUkMgQ2FyLmR3Zg";
      break;
    case "Staging":
      documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
      break;
    case "Production":
      documentId = "FIXME";
      break;
    default:
      documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvUkMgQ2FyLmR3Zg";
  }
  return documentId;
};
function stderr(msg) {
  if (ENABLE_TRACE) {
    console.log(msg);
  }
}
;
